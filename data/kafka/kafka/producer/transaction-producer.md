# Transaction Producer

Kafka **트랜잭션 프로듀서**는 \*\*정확히 한 번 전송(Exactly Once Semantics, EOS)\*\*을 보장하며, **여러 파티션 또는 여러 토픽에 걸친 메시지를 원자적으로 처리**할 수 있는 기능을 제공합니다. 이 기능을 통해, 프로듀서는 **여러 메시지를 하나의 트랜잭션으로 묶어** 성공적으로 처리되거나 **실패 시 모두 롤백**할 수 있도록 합니다. 특히 **분산 시스템**에서 **데이터 일관성**과 **정확한 메시지 처리**가 필요한 상황에서 유용하게 사용됩니다.

### Kafka 트랜잭션 프로듀서란?

**Kafka 트랜잭션 프로듀서**는 **여러 파티션에 걸쳐 메시지를 전송**할 때, 모든 메시지가 **성공적으로 처리되거나** 아니면 **모두 실패하도록 보장**하는 기능입니다. 이를 통해 메시지가 **중복 없이 정확히 한 번만 전송**되는 \*\*Exactly Once Semantics (EOS)\*\*를 보장할 수 있습니다.

트랜잭션을 통해 Kafka는 **프로듀서가 여러 메시지를 묶어 전송하고**, 해당 메시지들이 처리되었을 때만 **트랜잭션을 커밋**하고 처리되지 않았을 때는 **롤백**하여 무효화합니다. 이를 통해 **데이터의 일관성**을 유지할 수 있습니다.

***

#### 트랜잭션 프로듀서의 주요 특징

1. **트랜잭션 처리**
   * Kafka 트랜잭션 프로듀서는 여러 메시지를 하나의 **트랜잭션**으로 묶어 전송합니다. 만약 트랜잭션이 성공적으로 **커밋**되면 모든 메시지가 처리되며, 실패 시 **롤백**됩니다.
2. **Exactly Once Semantics (EOS)**
   * 트랜잭션 프로듀서는 **정확히 한 번 전송**하는 것을 보장합니다. 이 기능은 **중복 없이** 메시지를 한 번만 처리하고, 재전송 시 중복되지 않도록 보장합니다.
3. **여러 파티션 및 토픽 처리**
   * Kafka 트랜잭션 프로듀서는 **여러 파티션 또는 여러 토픽에 걸친 메시지**를 한 번의 트랜잭션으로 처리할 수 있습니다. 이를 통해 분산 환경에서 **데이터 일관성**을 유지할 수 있습니다.

***

#### 트랜잭션 프로듀서의 동작 원리

Kafka 트랜잭션 프로듀서는 트랜잭션 ID (Transactional ID)를 통해 각 트랜잭션을 관리합니다. Kafka는 이 **트랜잭션 ID**를 기반으로 각 메시지가 **트랜잭션에 속해 있는지** 추적하고, 트랜잭션이 성공적으로 커밋되면 해당 트랜잭션의 모든 메시지를 처리하며, **롤백**될 경우 메시지를 무효화합니다.

1. **트랜잭션 시작**
   * 트랜잭션 프로듀서는 **트랜잭션 ID**를 사용해 트랜잭션을 시작하고, 메시지를 전송합니다. 이때 전송되는 모든 메시지는 **트랜잭션 내에 포함**됩니다.
2. **메시지 전송**
   * 프로듀서는 트랜잭션이 진행 중인 동안 **여러 파티션이나 토픽**에 메시지를 전송할 수 있습니다. 이 메시지들은 트랜잭션이 커밋되기 전까지는 **잠정적인 상태**로 남아있습니다.
3. **트랜잭션 커밋 또는 롤백**
   * 트랜잭션이 **커밋되면**, 트랜잭션 내 모든 메시지가 **정식으로 처리**됩니다. 반면, **트랜잭션이 실패하거나 롤백**되면 해당 메시지는 무효화됩니다.

***

#### 트랜잭션 프로듀서 설정

Kafka에서 트랜잭션 프로듀서를 사용하려면, `transactional.id`를 설정해야 합니다.&#x20;

`transactional.id`는 Kafka가 트랜잭션을 추적하는 데 사용하는 고유 ID입니다. 이 ID는 각 프로듀서 인스턴스마다 부여되며, Kafka는 이를 기반으로 트랜잭션의 상태를 관리합니다.

**트랜잭션 프로듀서 설정 예시:**

```kotlin
val props = Properties()
props[ProducerConfig.BOOTSTRAP_SERVERS_CONFIG] = "localhost:9092"
props[ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG] = StringSerializer::class.java.name
props[ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG] = StringSerializer::class.java.name
props[ProducerConfig.ENABLE_IDEMPOTENCE_CONFIG] = "true"  // 멱등성 활성화
props[ProducerConfig.TRANSACTIONAL_ID_CONFIG] = "transactional-producer-1"  // 트랜잭션 ID 설정

val producer = KafkaProducer<String, String>(props)

// 트랜잭션 초기화
producer.initTransactions()

try {
    // 트랜잭션 시작
    producer.beginTransaction()

    // 여러 파티션 또는 토픽에 메시지 전송
    producer.send(ProducerRecord("my-topic", "key1", "value1"))
    producer.send(ProducerRecord("my-topic", "key2", "value2"))

    // 트랜잭션 커밋
    producer.commitTransaction()
} catch (e: Exception) {
    // 오류 발생 시 트랜잭션 롤백
    producer.abortTransaction()
    e.printStackTrace()
} finally {
    producer.close()
}
```

위 코드는 트랜잭션 프로듀서를 설정하고, `beginTransaction()`을 호출해 트랜잭션을 시작한 후, 여러 메시지를 전송한 뒤 `commitTransaction()`으로 트랜잭션을 커밋하는 예제입니다. 만약 오류가 발생하면, `abortTransaction()`을 호출하여 트랜잭션을 롤백합니다.

***

#### 트랜잭션 컨슈머

트랜잭션 프로듀서가 보낸 메시지를 처리하는 **Kafka 컨슈머**는 **트랜잭션 커밋 여부**를 인식하고, 커밋된 메시지만 읽을 수 있도록 설계되어 있습니다. Kafka 컨슈머는 **`isolation.level`** 설정을 통해 **커밋된 메시지만** 소비할지, **롤백된 메시지도 포함해** 읽을지를 설정할 수 있습니다.

* **`isolation.level=read_committed`**: 커밋된 트랜잭션의 메시지만 읽습니다.
* **`isolation.level=read_uncommitted`**: 모든 트랜잭션의 메시지를 읽습니다(롤백된 메시지도 포함).

**컨슈머 설정 예시**

```properties
isolation.level=read_committed
```

이 설정을 통해, 컨슈머는 트랜잭션이 커밋된 메시지만 처리하게 되어 **정확한 메시지 처리를 보장**합니다.

***

#### 장점

1. **정확한 데이터 일관성**: 트랜잭션 프로듀서는 **여러 파티션** 또는 **여러 토픽**에 걸친 메시지를 **원자적으로 처리**할 수 있습니다. 이를 통해 **일관성 있는 메시지 처리**가 가능합니다.
2. **Exactly Once Semantics (EOS)**: 트랜잭션 프로듀서를 사용하면, Kafka는 **중복 없이 정확히 한 번** 메시지를 처리합니다. 이는 메시지의 중복 전송을 방지하고, 메시지가 한 번만 처리되도록 보장합니다.
3. **분산 시스템 간의 일관성 유지**: Kafka 트랜잭션을 통해, Kafka 외부 시스템(예: 데이터베이스)과 통합하여 **여러 시스템 간 일관성을 유지**할 수 있습니다. 예를 들어, Kafka에 메시지를 전송하는 동시에 외부 데이터베이스에도 데이터를 저장하는 트랜잭션 처리가 가능합니다.

***

단점

**성능 저하**: 트랜잭션 처리는 여러 파티션이나 토픽에 걸쳐 원자적으로 메시지를 처리해야 하기 때문에, 일반 프로듀서에 비해 **처리 속도가 느릴 수** 있습니다. 특히, 많은 메시지를 한 번에 트랜잭션으로 처리할 때 성능 저하가 발생할 수 있습니다.

**복잡성 증가**: 트랜잭션을 사용하면 **코드의 복잡성**이 증가할 수 있습니다. 트랜잭션 시작, 커밋, 롤백 등의 처리가 추가되며, 이를 통해 전체 시스템에서의 오류 처리와 복구 로직이 더욱 복잡해질 수 있습니다.

***

#### 결론

Kafka 트랜잭션 프로듀서는 **정확한 메시지 처리**와 **데이터 일관성**을 보장하기 위해 설계된 강력한 도구입니다. 특히, **여러 파티션이나 여러 토픽**에 걸쳐 메시지를 원자적으로 처리할 수 있어 Exactly Once Semantics (

EOS)를 구현하는 데 유용합니다.

트랜잭션 프로듀서는 **데이터 중복 없이 한 번만 처리**해야 하는 중요한 시스템에서 필수적인 기능을 제공합니다. 하지만, **성능 저하**와 **복잡성 증가**라는 한계가 있기 때문에, 이를 고려하여 애플리케이션에 적절히 적용해야 합니다.
