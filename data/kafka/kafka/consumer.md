# Consumer

## Kafka 컨슈머란?

Kafka 컨슈머는 **Kafka 클러스터**에서 **토픽의 메시지를 읽고 처리하는 컴포넌트**입니다. 컨슈머는 **프로듀서가 전송한 메시지**를 토픽의 **파티션에서 읽어와** 다양한 애플리케이션 로직에 맞춰 데이터를 처리합니다.&#x20;

Kafka는 **고성능 비동기 스트리밍**을 지원하며, 컨슈머는 데이터를 빠르게 소비할 수 있는 주요 구성 요소입니다.

<img src="../../../.gitbook/assets/file.excalidraw (61).svg" alt="" class="gitbook-drawing">



### 개념

컨슈머는 Kafka의 **토픽**으로부터 데이터를 읽어오며, 여러 컨슈머가 **컨슈머 그룹**을 형성해 **병렬 처리**를 수행합니다.&#x20;

각 컨슈머는 **파티션을 할당받아** 데이터를 처리하며, 컨슈머 그룹 내에서 **데이터 중복 없이** 각 파티션에 접근합니다. **오프셋**은 각 파티션 내에서 컨슈머가 어디까지 데이터를 읽었는지 추적하는 중요한 개념입니다.&#x20;

이를 통해 중단되거나 장애가 발생하더라도 이어서 데이터를 처리할 수 있습니다.

### 동작 원리

컨슈머가 **Kafka 클러스터**에서 데이터를 소비하는 과정은 다음과 같습니다.

* 컨슈머는 **토픽을 구독**하여 해당 토픽의 메시지를 읽습니다.
* Kafka는 컨슈머 그룹 내에서 **파티션을 할당**하며, 각 컨슈머가 독립적으로 파티션을 처리하도록 합니다.
* 컨슈머가 파티션에서 메시지를 읽을 때, Kafka는 그 위치를 **오프셋**으로 추적합니다.
* 메시지가 처리되면 컨슈머는 Kafka에 **오프셋을 커밋**하여 어디까지 읽었는지를 기록하고, 다음 메시지부터 이어서 처리할 수 있습니다.

### 상세 설명

Kafka 컨슈머는 **리밸런싱**이라는 개념을 사용해 그룹 내의 컨슈머가 추가되거나 제거될 때 **자동으로 파티션을 재분배**합니다. 이렇게 하면 컨슈머가 동적으로 클러스터에 추가되거나 제거되어도 데이터 처리에 영향이 없게 됩니다.

컨슈머는 **오프셋 자동 커밋**과 **수동 커밋** 기능을 제공하여, 메시지가 성공적으로 처리되었는지 확실히 한 후에 오프셋을 커밋하는 방식으로 **데이터 처리의 일관성을 유지**할 수 있습니다.

#### 옵션

Kafka 컨슈머는 다양한 설정 옵션을 제공하여 **성능과 안정성**을 조정할 수 있습니다.

* **enable.auto.commit**: 자동 커밋 여부를 설정합니다. 기본값은 `true`로, 일정 간격마다 Kafka가 오프셋을 자동으로 커밋합니다.
* **auto.offset.reset**: 컨슈머가 읽기 시작할 오프셋을 설정합니다. 예를 들어, 토픽에 처음 연결될 때 또는 마지막 커밋된 오프셋이 없을 때, **earliest**를 설정하면 가장 오래된 메시지부터 읽고, **latest**를 설정하면 최신 메시지부터 읽습니다.
* **max.poll.records**: 한 번의 요청으로 가져올 수 있는 최대 레코드 수를 정의합니다. 이 값을 조정하면 **처리 속도**와 **메모리 사용량**을 최적화할 수 있습니다.
* **session.timeout.ms**: 컨슈머가 **정상적으로 작동 중인지** Kafka에 신호를 보내는 시간 간격입니다. 지정된 시간 동안 컨슈머가 응답하지 않으면 Kafka는 해당 컨슈머가 장애가 발생한 것으로 간주하고 **리밸런싱**을 시작합니다.

## Fetcher ?&#x20;

**Fetcher**는 **Kafka 컨슈머 내부에서 메시지를 가져오는 역할**을 담당하는 중요한 구성 요소입니다.&#x20;

Fetcher는 **파티션의 리더 브로커**로부터 **메시지를 가져오는 작업**을 수행하며, 여러 파티션에서 데이터를 병렬로 가져오는 것을 효율적으로 처리합니다.

* **메시지 가져오기**: Fetcher는 컨슈머가 구독한 토픽의 **각 파티션의 리더 브로커**에 요청을 보내 **메시지를 가져옵니다**. 이는 각 브로커가 관리하는 파티션에서 메시지를 비동기로 가져오는 방식으로 이루어집니다.
* **Fetch 요청 관리**: Fetcher는 각 파티션에 대해 **fetch 요청**을 보내고, **오프셋을 기준으로 메시지**를 가져옵니다. 가져온 메시지는 컨슈머가 처리할 수 있도록 제공됩니다.
* **데이터 일관성 유지**: Fetcher는 **오프셋을 기반으로 메시지를 읽어오며**, Kafka의 일관성 모델을 따릅니다. 이를 통해, 데이터가 정확하게 처리되고, 메시지의 순서가 유지될 수 있도록 합니다.
* **페칭 성능 최적화**: Kafka 컨슈머는 한 번에 여러 파티션에서 메시지를 가져오기 위해 **최적화된 병렬 처리 구조**를 사용합니다. Fetcher는 이 과정에서 **최적의 성능**을 보장하기 위해, **배치 크기**, **네트워크 상태** 등의 요소를 고려하여 메시지를 가져옵니다.

<img src="../../../.gitbook/assets/file.excalidraw (1).svg" alt="" class="gitbook-drawing">

### 동작 원리

**토픽 구독 및 파티션 할당**: Kafka 컨슈머는 **토픽을 구독**하고, 해당 토픽의 **파티션을 할당**받습니다. \
컨슈머 그룹 내에서 **파티션은 자동으로 분배**됩니다.

#### **Fetcher를 통한 메시지 가져오기**

Fetcher는 컨슈머가 할당받은 파티션에서 **오프셋을 기준으로 메시지를 가져오는 역할**을 수행합니다.

**fetch 요청**이 파티션의 리더 브로커로 보내지며, Fetcher는 브로커로부터 해당 오프셋 이후의 메시지를 가져옵니다.

#### **오프셋 관리 및 메시지 처리**

Fetcher가 가져온 메시지를 컨슈머는 **오프셋을 기준으로 순차적으로 처리**합니다.

메시지가 처리되면, 컨슈머는 **오프셋을 커밋**하여 처리된 메시지의 위치를 기록합니다.

#### **리밸런싱과 파티션 재할당**

컨슈머 그룹에서 **리밸런싱**이 발생할 경우, Fetcher는 새로운 파티션에 대해 **fetch 요청을 다시 설정**하여 데이터를 이어서 가져옵니다.
