# File System

### 카프카는 왜 디스크를 쓸까?

대용량 실시간 데이터 처리의 핵심 플랫폼인 \*\*아파치 카프카(Apache Kafka)\*\*는 데이터를 \*\*메모리(RAM)\*\*에 저장하는 대신, \*\*파일 시스템(디스크)\*\*에 저장합니다. "디스크가 메모리보다 느린데, 왜 카프카는 디스크를 사용할까?" 이것이 바로 카프카의 \*\*영속성(Persistence)\*\*과 고성능 처리를 동시에 잡은 핵심 전략입니다.

### 데이터 영속성(Persistence)과 안정성

카프카가 디스크에 데이터를 쓰는 가장 중요한 이유는 데이터의 유실을 막기 위함입니다.

* 영속적인 로그 기록: 카프카 브로커(서버)가 갑자기 다운되더라도, 데이터는 이미 디스크의 로그 파일에 기록되어 있으므로 손실되지 않습니다.
* 컨슈머 독립성: 메시징 시스템에서 컨슈머가 메시지를 가져가면 보통 메시지가 삭제됩니다. 하지만 카프카는 디스크에 저장된 데이터를 설정된 기간 동안 유지합니다.
  * 예시: 소비자가 밤 10시에 장애가 나서 데이터를 처리하지 못했습니다. 다음 날 아침 8시에 시스템을 복구해도, 디스크에 남아있는 10시간 치 데이터를 처음부터 안전하게 다시 처리할 수 있습니다.

***

### 고성능 처리 (Sequential I/O와 Page Cache)

느린 디스크를 사용하고도 고성능을 내는 카프카의 비결은 운영체제의 기능을 극대화하는 설계에 있습니다.

#### 1. 순차적 I/O (Sequential I/O)

* 데이터 쓰기 방식: 카프카는 디스크의 로그 파일에 \*\*오직 맨 끝에만 데이터를 추가(Append-Only)\*\*합니다.
* 성능 향상: 디스크의 데이터 접근 방식 중 무작위(Random) I/O는 느리지만, 순차적(Sequential) I/O는 매우 빠릅니다. 카프카는 순차적으로 데이터를 쓰고 읽음으로써, 디스크 I/O의 속도를 하드디스크가 아닌, 거의 메모리 수준으로 끌어올립니다.

#### 2. 운영체제 페이지 캐시(OS Page Cache)의 활용

* 더블 버퍼링 회피: 카프카는 애플리케이션 레벨에서 메시지를 캐싱하지 않고, 운영체제(OS)가 관리하는 페이지 캐시 영역을 적극적으로 활용합니다.
* 원리: 프로듀서가 데이터를 보내 디스크에 저장될 때, 이 데이터는 메모리의 페이지 캐시에도 복사되어 저장됩니다. 컨슈머가 데이터를 요청하면, 카프카는 디스크가 아닌 메모리에 있는 페이지 캐시에서 데이터를 빠르게 가져와 전달합니다.
* 결과: 디스크에 영속성을 확보하면서, 실제 읽기/쓰기 작업은 메모리에서 처리되어 고성능을 유지합니다.

#### 3. 제로 카피 (Zero-Copy)

* 네트워크 전송 최적화: 카프카는 컨슈머에게 데이터를 전달할 때, 디스크 버퍼의 데이터를 CPU를 거치지 않고 네트워크 버퍼로 바로 복사하는 Zero-Copy 기술을 사용합니다.
* 효과: 불필요한 데이터 복사 단계를 줄여 CPU 오버헤드를 최소화하고 데이터 전송 처리량을 극대화합니다.

***

### 카프카 데이터 처리 과정

다음은 카프카에서 데이터가 파일 시스템에 저장되고 처리되는 흐름을 간략하게 나타낸 것입니다.

| 단계              | 주체              | 동작                                     | 핵심 원리                |
| --------------- | --------------- | -------------------------------------- | -------------------- |
| 1. 발행 (Publish) | Producer (생산자)  | 메시지를 Kafka Broker로 전송                  | -                    |
| 2. 저장 (Storage) | Broker (카프카 서버) | 메시지를 디스크의 로그 파일에 순차적으로(Append-Only) 기록 | 순차적 I/O, 영속성 확보      |
| 3. 캐싱 (Caching) | OS (운영체제)       | 디스크에 기록된 메시지를 페이지 캐시에 복사해 저장           | 고성능 읽기 준비            |
| 4. 소비 요청        | Consumer (소비자)  | 특정 Offset의 데이터를 Broker에 요청             | -                    |
| 5. 데이터 전송       | Broker          | 페이지 캐시의 데이터를 Zero-Copy로 Consumer에게 전송  | 페이지 캐시 활용, Zero-Copy |

&#x20;
