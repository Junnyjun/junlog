# Topic\&Partition

카프카의 \*\*토픽 (Topic)\*\*과 \*\*파티션 (Partition)\*\*은 분산 시스템의 확장성, 고가용성, 그리고 메시지 순서 보장을 위한 설계의 근간입니다.

***

### 토픽 (Topic): 데이터의 논리적 분류와 불변의 스트림

토픽은 카프카에서 데이터를 분류하는 논리적인 채널입니다. 프로듀서가 특정 주제의 메시지를 발행하고, 컨슈머가 그 주제를 구독하는 기본 단위입니다.

#### 1. 스트림과 로그의 개념

* 이벤트 스트림: 토픽은 데이터베이스의 테이블보다는 \*\*이벤트 스트림(Event Stream)\*\*에 가깝습니다. 즉, 연속적으로 발생하는 레코드(메시지)의 흐름입니다.
* 불변의 로그: 토픽에 기록된 레코드는 \*\*불변(Immutable)\*\*의 성격을 가집니다. 레코드가 한번 저장되면 수정되거나 중간에 삽입되지 않습니다. 컨슈머가 레코드를 읽더라도 삭제되지 않고, 정해진 보존 정책에 따라 시간이 지나야 삭제됩니다. 이 덕분에 여러 컨슈머 그룹이 독립적으로, 혹은 나중에 데이터를 재처리할 수 있습니다.

#### 2. 토픽과 순서 보장의 한계

토픽은 하나 이상의 파티션으로 구성되므로, 토픽 전체 레코드 간의 순서는 보장되지 않습니다. 메시지 순서는 오직 하나의 파티션 내부에서만 보장됩니다.

***

### 파티션 (Partition): 물리적 분할, 병렬 처리의 기본 단위

파티션은 토픽을 구성하는 실제 물리적 저장소입니다. 카프카가 대용량 데이터를 빠르고 안정적으로 처리할 수 있는 모든 비밀이 이 파티션에 담겨 있습니다.

#### 1. 물리적 저장 구조: 순차 로그와 세그먼트

* 순차적 로그 (Append-Only Log): 각 파티션은 디스크에 저장되는 독립적인 순차적(Ordered) 로그 파일입니다. 새로운 레코드는 항상 로그의 \*\*맨 끝에 추가(Append-Only)\*\*됩니다. 이 순차 쓰기 방식이 디스크 I/O 성능을 극대화하는 핵심 원리입니다.
* 로그 세그먼트 (Log Segments): 파티션의 무한한 로그는 관리 효율성을 위해 로그 세그먼트라는 작은 파일들로 분할되어 저장됩니다. 이 세그먼트 단위로 오래된 데이터가 삭제되거나 (Retention Policy) 압축됩니다 (Log Compaction).

#### 2. 오프셋 (Offset): 불변의 레코드 식별자

* 위치 식별: 파티션 내 모든 레코드는 0부터 시작하여 순차적으로 증가하는 오프셋이라는 고유한 번호를 가집니다. 이 오프셋은 레코드의 절대적이고 불변의 위치를 나타냅니다.
* 컨슈머 커서: 컨슈머는 자신이 파티션에서 어디까지 레코드를 읽었는지 이 오프셋을 추적하고 주기적으로 \*\*커밋(Commit)\*\*합니다. 이를 통해 컨슈머에 장애가 발생해도 마지막 처리 위치부터 안전하게 복구하여 작업을 재개할 수 있습니다.

#### 3. 고가용성: 리더, 팔로워, 그리고 ISR

파티션은 데이터의 안정성을 위해 여러 브로커에 복제될 수 있습니다 (복제 계수 설정).

* 리더 (Leader): 복제본 중 하나는 리더가 되어 모든 읽기 및 쓰기 요청을 처리합니다.
* 팔로워 (Follower): 나머지는 팔로워가 되어 리더의 데이터를 복제하여 동기화 상태를 유지합니다.
* ISR (In-Sync Replica): 리더와 완벽하게 동기화되어 있는 팔로워들의 목록입니다. 프로듀서가 높은 안정성으로 레코드를 발행할 때, 해당 레코드는 ISR의 모든 복제본에 기록되어야만 성공으로 간주됩니다. 리더에 장애가 발생하면 ISR 멤버 중에서만 새로운 리더가 선출되어 데이터 유실을 최소화합니다.

#### 4. 파티셔닝 전략: 순서 보장의 열쇠

프로듀서가 메시지를 보낼 때, 파티셔너(Partitioner)는 레코드를 어느 파티션에 저장할지 결정합니다.

| 조건           | 전략                                                                                | 목적         |
| ------------ | --------------------------------------------------------------------------------- | ---------- |
| 키(Key) 지정    | 해시 기반 파티셔닝                                                                        | 키 단위 순서 보장 |
|              | 레코드의 키를 해싱하여 파티션 수를 나눈 나머지 값으로 결정. 동일 키는 항상 동일 파티션에 저장됩니다. (예: `UserID` 기반 순서 보장) |            |
| 키 미지정 (null) | 라운드 로빈 파티셔닝                                                                       | 부하 균등 분산   |
|              | 파티션에 메시지를 순차적으로 고르게 분배하여 브로커 간의 부하를 균형 있게 유지합니다.                                  |            |

***

### 컨슈머 그룹과 동적 할당 (리밸런싱)

파티션은 병렬 처리의 최소 단위이므로, 컨슈머 그룹의 확장성과 직접 연결됩니다.

#### 1. 컨슈머 그룹과 파티션 매핑

* 1:1 매핑 원칙: 하나의 컨슈머 그룹 내에서 각 파티션은 오직 하나의 컨슈머 인스턴스에게만 할당됩니다.
* 최대 병렬성: 토픽의 최대 병렬 처리량은 파티션 수에 의해 결정됩니다. 파티션 수보다 컨슈머 수가 많으면, 남는 컨슈머는 유휴 상태가 됩니다.

#### 2. 리밸런싱 (Rebalancing)

리밸런싱은 컨슈머 그룹의 멤버십이나 구독 중인 파티션 수에 변화가 생길 때, 파티션의 소유권을 동적으로 재분배하는 과정입니다.

* 발생 조건: 신규 컨슈머 추가, 기존 컨슈머 이탈 (장애 또는 정상 종료), 구독 토픽의 파티션 수 변경.
* 작동 영향: 리밸런싱이 진행되는 짧은 시간 동안 컨슈머는 메시지 소비를 일시 중단하고, 파티션 할당을 재조정합니다. 이는 데이터 처리 지연(Lag)을 발생시키므로, 카프카 운영에서 리밸런싱을 최소화하고 빠르게 완료하는 것이 중요합니다.
