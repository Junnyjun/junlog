# 고급 기능

### 파이프라인(Pipelining): 네트워크 RTT 최적화

파이프라인은 여러 명령어를 동시에 처리할 수 있는 레디스의 기능으로, 클라이언트와 서버 간의 네트워크 왕복 시간을 줄일 수 있습니다. 일반적으로 레디스의 명령어들은 요청-응답 방식으로 처리되기 때문에, 각 명령을 처리할 때마다 네트워크 왕복 시간이 발생합니다. 파이프라인을 사용하면 여러 명령어를 하나의 요청으로 묶어 서버에 전송하고, 응답을 한 번에 받을 수 있습니다. 이 방식은 네트워크 RTT(Round Trip Time)를 최소화할 수 있습니다.

**예시:** 여러 개의 `GET` 명령어를 하나의 파이프라인으로 묶어 실행할 때:

```bash
> MULTI
> GET foo
> GET bar
> GET baz
> EXEC
```

위의 예시처럼, 파이프라인을 사용하면 각 명령어마다 기다리는 시간 없이 한 번에 처리할 수 있습니다. 결과적으로, 명령어 실행 시간과 지연 시간을 줄이고 성능을 최적화할 수 있습니다.

**단점:**

* 파이프라인은 복잡한 조건 분기나 로직을 처리하기 어렵습니다.
* 원자성 보장이 필요한 작업에는 적합하지 않습니다.

따라서, 파이프라인은 여러 명령을 한 번에 처리하는 데 유리하지만, 복잡한 로직을 다룰 때는 다른 기능을 사용하는 것이 좋습니다.

### 루아 스크립팅(Lua Scripting): 복잡한 로직 처리 및 원자적 실행

레디스에서 루아(Lua) 스크립트를 사용하면, 여러 명령어를 하나의 스크립트로 묶어서 원자적으로 실행할 수 있습니다. 루아는 레디스의 서버 내에서 직접 실행되며, 이를 통해 데이터베이스의 상태를 변경할 때 다른 클라이언트의 개입 없이 안전하게 실행할 수 있습니다. 루아 스크립트를 사용하면 복잡한 로직이나 조건을 처리할 수 있으며, 성능을 최적화하는 데 매우 유용합니다.

**루아 스크립트의 특징:**

* **조건 분기와 복잡한 로직 처리:** 루아를 사용하면 `if` 문과 같은 조건 분기를 사용하여 복잡한 로직을 처리할 수 있습니다.
* **원자적 처리:** 루아 스크립트는 서버에서 실행되므로, 중간에 다른 클라이언트의 간섭 없이 안전하게 실행됩니다.
* **TTL 설정과 같은 복잡한 작업:** 예를 들어, 키에 TTL(Time to Live)을 설정하거나, 여러 키의 상태를 동시에 확인하는 작업을 루아로 처리할 수 있습니다.

**이페머럴 스크립트와 레디스 함수:** 레디스 7.0에서는 이페머럴 스크립트의 단점을 보완하는 **레디스 함수** 기능을 도입했습니다. 이페머럴 스크립트는 이전 버전에서 루아를 실행하는 방식으로 사용되었으나, 원자성이나 트랜잭션 처리에 한계가 있었습니다. 레디스 함수는 이러한 문제를 해결하며, 더욱 효율적이고 내구성 있는 방식으로 작업을 처리할 수 있습니다.

### 트랜잭션(Transaction): 원자적 명령어 실행

레디스의 트랜잭션은 `MULTI`와 `EXEC` 명령어로 구성되며, 여러 명령어를 하나의 작업 단위로 묶어 처리할 수 있습니다. 트랜잭션 내부에서 실행되는 명령어들은 **다른 클라이언트의 간섭을 받지 않고 원자적으로 처리**됩니다. 이 기능은 여러 명령어가 순차적으로 실행되어야 할 때 유용하며, 예를 들어 여러 데이터 항목을 동시에 갱신하거나 처리할 때 사용할 수 있습니다.

**트랜잭션의 특징:**

* **원자적 실행:** 트랜잭션 내부의 명령어들은 하나의 작업처럼 처리됩니다.
* **다중 명령어 처리:** 여러 명령어를 하나의 단위로 묶어 처리할 수 있습니다.

**단점:**

* 트랜잭션은 복잡한 비즈니스 로직을 처리하기에는 한계가 있습니다. 특히 계산된 결과를 바탕으로 다음 명령어를 실행해야 하는 경우에는 루아 스크립트로 해결하는 것이 좋습니다.

**사용 예시:**

```bash
> MULTI
> SET foo 10
> INCR foo
> INCR foo
> GET foo
> EXEC
```

위 예시에서는 `MULTI`로 시작해 `EXEC`을 호출하면 트랜잭션 내에서 실행된 명령어들이 모두 원자적으로 실행됩니다.

### 모듈(Modules): 레디스의 확장성

레디스는 **모듈** 기능을 제공하여 서버의 기본 기능을 확장할 수 있습니다. C 언어로 작성된 모듈을 레디스 서버에 추가하여, 레디스의 기본 자료형이나 명령어로 처리하기 어려운 작업을 해결할 수 있습니다. 모듈을 사용하면 **사용자 정의 자료형**과 **고급 데이터 처리 기능**을 추가할 수 있어 매우 강력한 확장 기능을 제공합니다.

**모듈의 장점:**

* **사용자 정의 자료형 추가:** 기본적인 자료형 외에도 다양한 데이터 구조를 추가할 수 있습니다.
* **서드파티 라이브러리 연동:** C 라이브러리와 결합하여 복잡한 데이터 모델이나 로직을 처리할 수 있습니다.
* **고수준 및 저수준 API 제공:** 고수준 API는 클라이언트 측에서 레디스와 유사한 방식으로 작업을 처리할 수 있게 하며, 저수준 API는 레디스 서버의 데이터에 빠르게 접근할 수 있게 해줍니다.

### 키 공간 알림(Keyspace Notifications): 실시간 데이터 변경 감지

**키 공간 알림**은 레디스에서 특정 키가 변경되거나 이벤트가 발생했을 때 이를 실시간으로 감지하고 알림을 받을 수 있는 기능입니다. 이 기능은 레디스의 **Pub/Sub** 시스템을 활용하여, 키의 삭제, 만료, 수정 등의 이벤트를 실시간으로 처리할 수 있습니다.

**장점:**

* 데이터베이스의 상태 변화를 실시간으로 감지하여 처리할 수 있습니다.
* 특정 키의 변경이나 삭제를 감지하고 이를 다른 시스템에 알릴 수 있습니다.

**사용 예시:**

```bash
> PSUBSCRIBE '__keyspace@0__:foo'
```

이 명령어는 `foo`라는 키에 대한 변경 이벤트를 감지합니다. 이벤트가 발생하면 해당 정보를 실시간으로 수신하여 처리할 수 있습니다.

### 클라이언트 측 캐시(Client-Side Caching): 성능 향상

클라이언트 측 캐시는 레디스 서버와 클라이언트 간의 요청 횟수를 줄여 성능을 향상시킬 수 있습니다. 클라이언트가 서버에서 데이터를 가져올 때마다 요청을 보내는 대신, 데이터를 로컬 캐시에 저장해두고, 서버로부터 데이터를 가져오는 횟수를 줄입니다. 이 방법은 \*\*지연 시간(RTT)\*\*을 최소화하고, 서버의 부담을 줄이는 데 유용합니다.

**장점:**

* 서버로의 요청과 응답을 줄여 성능을 최적화할 수 있습니다.
* 클라이언트에서 데이터를 로컬 캐시하여 빠르게 접근할 수 있습니다.

**단점:**

* 클라이언트 측 캐시의 무효화 관리가 필요합니다.
* 데이터 정합성을 유지하기 위한 추가적인 관리가 필요합니다.

**예시:**

```bash
> CLIENT TRACKING ON
```

이 명령어는 클라이언트 측에서 데이터를 추적하여 캐시할 수 있게 해줍니다. 또한, 캐시된 데이터가 변경되면 자동으로 클라이언트에게 알림을 보냅니다.
