# 고급 기능

### **파이프라인 (Pipelining)**

파이프라인 기능은 여러 Redis 명령어를 한번에 보내서 네트워크 왕복 시간을 줄이는 기능입니다. 파이프라인을 사용하면 응답을 기다리는 시간을 절약할 수 있지만, **원자성**(Atomicity)이 보장되지 않기 때문에 이를 고려하여 사용해야 합니다.

**옵션 및 기능**

*   **`PIPELINE`**: 여러 Redis 명령어를 한 번에 보내는 파이프라인 기능을 활성화하는 옵션입니다. 이 옵션을 사용하면 여러 명령어를 순차적으로 전송할 수 있으며, 서버에서 명령어들을 처리한 후 한 번에 응답을 받을 수 있습니다. 네트워크 지연을 최소화하는 데 유용합니다.

    ```bash
    PIPELINE
    SET key1 value1
    SET key2 value2
    GET key1
    GET key2
    ```

    * 이 예시에서 `SET`과 `GET` 명령어들이 동시에 처리되며 응답은 나중에 한 번에 받을 수 있습니다.
*   **`NOREPLY`**: 명령어에 대한 응답을 받지 않으려면 `NOREPLY` 옵션을 사용합니다. 예를 들어, `SET` 명령어를 보내고 그에 대한 응답을 기다리지 않도록 할 수 있습니다. 이는 네트워크 대역폭을 절약하고 성능을 향상시킬 수 있습니다.

    ```bash
    SET key value NOREPLY
    ```

    * 이 명령어는 `SET`에 대한 응답을 클라이언트가 받지 않도록 합니다.

파이프라인은 많은 명령어를 동시에 보내는 데 유리하지만, **원자성**이 보장되지 않기 때문에 여러 클라이언트가 동시에 요청을 보낼 수 있는 환경에서는 사용에 주의가 필요합니다.

***

### **루아 스크립팅 (Lua Scripting)**

Redis는 루아 스크립트를 사용하여 복잡한 연산을 처리할 수 있는 기능을 제공합니다. 루아를 사용하면 클라이언트와 서버 간의 네트워크 왕복을 최소화하고, 여러 명령어를 하나의 스크립트로 실행하여 **원자성**을 보장할 수 있습니다.

**옵션 및 기능**

*   **`EVAL`**: Redis에서 루아 스크립트를 실행하는 가장 기본적인 명령어입니다. 루아 스크립트를 서버에서 실행하며, 그 스크립트에서 사용하는 키와 값을 인수로 전달할 수 있습니다.

    ```bash
    EVAL "return redis.call('GET', KEYS[1])" 1 mykey
    ```

    * 이 예시에서 `mykey`에 해당하는 값을 가져오는 루아 스크립트를 실행합니다.
*   **`EVALSHA`**: `EVAL` 명령어의 대체 명령어로, 이미 로드된 루아 스크립트의 SHA1 해시값을 사용하여 실행합니다. 이 방식은 대역폭을 절약하고 성능을 향상시킬 수 있습니다.

    ```bash
    EVALSHA <SHA1> 1 mykey
    ```

    * `EVALSHA`를 사용하면 매번 스크립트를 전송하지 않고 이미 서버에 로드된 스크립트를 실행할 수 있습니다.
*   **`SCRIPT LOAD`**: 루아 스크립트를 Redis 서버에 로드하는 명령어로, 서버에 로드된 스크립트는 SHA1 해시값으로 구별되며, 이 해시값을 사용하여 `EVALSHA`로 실행할 수 있습니다.

    ```bash
    SCRIPT LOAD "return redis.call('GET', KEYS[1])"
    ```

    * 이 명령어는 루아 스크립트를 Redis 서버에 로드하고, 해당 스크립트의 SHA1 해시값을 반환합니다.
*   **`SCRIPT FLUSH`**: 서버에서 로드된 모든 스크립트를 삭제하는 명령어입니다. 이를 통해 서버의 메모리 사용을 관리할 수 있습니다.

    ```bash
    SCRIPT FLUSH
    ```

루아 스크립팅을 활용하면 여러 명령어를 하나의 원자적인 연산으로 처리할 수 있기 때문에 성능이 향상됩니다. 또한, 복잡한 로직을 서버에서 처리하므로 클라이언트의 부하를 줄일 수 있습니다.

***

### **트랜잭션 (Transactions)**

Redis 트랜잭션은 **원자성**을 보장하는 명령어의 묶음입니다. 트랜잭션 내의 명령어들은 `MULTI`와 `EXEC` 명령어로 묶어 실행하며, 트랜잭션을 시작한 후에는 다른 클라이언트의 작업에 방해받지 않습니다.

**옵션 및 기능**

*   **`MULTI`**: 트랜잭션의 시작을 알리는 명령어입니다. 이 명령어 뒤에 실행되는 모든 명령어는 큐에 들어가며, `EXEC` 명령어가 호출될 때 한 번에 실행됩니다.

    ```bash
    MULTI
    SET key1 value1
    INCR key1
    EXEC
    ```

    * `MULTI` 명령어 뒤에 여러 명령어를 실행하면, `EXEC`이 호출될 때 해당 명령어들이 원자적으로 실행됩니다.
*   **`EXEC`**: `MULTI`로 시작된 트랜잭션을 실행하는 명령어입니다. 큐에 들어간 명령어들을 원자적으로 실행합니다.

    ```bash
    EXEC
    ```
*   **`DISCARD`**: 트랜잭션을 취소하고 큐에 들어간 명령어들을 모두 삭제하는 명령어입니다.

    ```bash
    DISCARD
    ```
*   **`WATCH`**: 특정 키를 감시하여 해당 키가 다른 클라이언트에 의해 변경되면 트랜잭션을 중단하는 명령어입니다. 이를 통해 **낙관적 락**을 구현할 수 있습니다.

    ```bash
    WATCH mykey
    MULTI
    SET mykey new_value
    EXEC
    ```

    * `WATCH`는 트랜잭션이 실행되기 전에 특정 키의 변경을 감지하고, 변경이 있을 경우 트랜잭션을 중단합니다.
*   **`UNWATCH`**: `WATCH`로 감시 중인 키에 대한 감시를 중단합니다.

    ```bash
    UNWATCH
    ```

Redis 트랜잭션은 여러 명령어를 하나의 묶음으로 처리할 수 있도록 하며, 중간에 오류가 발생하더라도 실행된 명령어들은 그대로 처리됩니다.

***

### **모듈 (Modules)**

Redis 모듈은 레디스의 기본적인 기능을 확장할 수 있도록 도와주는 기능입니다. C 언어로 작성된 모듈을 Redis 서버에 추가하여, 사용자 정의 자료형이나 복잡한 로직을 구현할 수 있습니다.

**옵션 및 기능**

*   **`MODULE LOAD`**: 외부 모듈을 Redis 서버에 로드하는 명령어입니다. 모듈 파일의 경로를 지정하여 서버에 로드합니다.

    ```bash
    MODULE LOAD /path/to/module.so
    ```
*   **`MODULE LIST`**: 서버에 로드된 모든 모듈을 확인하는 명령어입니다.

    ```bash
    MODULE LIST
    ```
*   **`MODULE UNLOAD`**: 로드된 모듈을 서버에서 언로드하는 명령어입니다. 일부 모듈은 언로드할 수 없을 수 있습니다.

    ```bash
    MODULE UNLOAD mymodule
    ```

모듈을 사용하면 Redis 서버에 고유한 데이터 타입이나 기능을 추가할 수 있습니다. 이를 통해 기존의 자료형만으로 처리하기 어려운 데이터 모델을 표현할 수 있습니다.

***

### **키 공간 알림 (Keyspace Notifications)**

Redis는 키 공간 알림을 통해 특정 키의 변화나 이벤트가 발생할 때 클라이언트에게 알림을 제공합니다. 이를 통해 실시간으로 키의 상태 변화를 추적할 수 있습니다.

**옵션 및 기능**

*   **`notify-keyspace-events`**: 알림을 받을 이벤트 종류를 설정하는 디렉티브입니다. 키의 변경, 만료, 제거 등 여러 이벤트를 구독할 수 있습니다.

    ```bash
    notify-keyspace-events "K"
    ```

    * `"K"`는 키의 변경이 발생했을 때 알림을 받을 수 있도록 설정합니다.
*   **`PSUBSCRIBE`**: Pub/Sub 시스템에서 키 공간과 이벤트에 대한 알림을 구독합니다.

    ```bash
    PSUBSCRIBE '__keyspace@0__:foo'
    ```

    * `__keyspace@0__:foo`는 `foo` 키에 대한 변경 알림을 수신하기 위한 패턴입니다.
*   **`PUBLISH`**: 키 변경 시 해당 키에 대한 알림을 전송하는 명령어입니다.

    ```bash
    PUBLISH "__keyspace@0__:foo" "set"
    ```

키 공간 알림을 사용하면 키의 변경을 실시간으로 감지할 수 있어, 데이터 처리나 캐시 무효화 등의 작업에 유용하게 활용할 수 있습니다.

***

### **클라이언트 측 캐시 (Client-Side Caching)**

클라이언트 측 캐시는 레디스 서버로의 요청을 줄여 성능을 향상시키는 기능입니다. 클라이언트가 데이터를 캐시하고, 다른 클라이언트가 데이터를 변경하면 해당 클라이언트에게 무효화 메시지를 전송하여 데이터 정합성을 유지합니다.

**옵션 및 기능**

*   **`CLIENT TRACKING`**: 클라이언트 측 캐시를 활성화하는 명령어입니다. 이를 통해 서버는 어떤 키가 클라이언트에서 캐시되고 있는지 추적할 수 있습니다.

    ```bash
    CLIENT TRACKING ON
    ```
*   **`PREFIX`**: 캐시를 추적할 키의 접두사를 지정합니다. 이 접두사에 해당하는 키들이 클라이언트 측 캐시로 저장됩니다.

    ```bash
    CLIENT TRACKING ON PREFIX "user:"
    ```
*   **`BCAST`**: 키 변경 시 다른 클라이언트로 무효화 메시지를 전송하는 방식입니다. 브로드캐스트 모드에서 사용됩니다.

    ```bash
    CLIENT TRACKING ON BCAST
    ```

클라이언트 측 캐시는 서버와의 요청 횟수를 줄이고 응답 속도를 높일 수 있지만, 데이터 정합성을 관리하는 데 신경을 써야 합니다.
