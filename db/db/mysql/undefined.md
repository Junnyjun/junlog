# 아키텍쳐

MySQL 서버는 크게 두 가지 주요 구성 요소로 나눌 수 있습니다: **MySQL 엔진**과 **스토리지 엔진**입니다. MySQL 엔진은 주로 쿼리 처리와 최적화를 담당하며, 스토리지 엔진은 실제 데이터를 저장하고 읽어오는 역할을 수행합니다. 이러한 구조로 인해 MySQL은 다른 DBMS와 차별화된 성능을 제공합니다.

## **MySQL 엔진 아키텍처**

MySQL 엔진은 클라이언트로부터의 쿼리 요청을 처리하는 **커넥션 핸들러**와 **쿼리 파서** 및 **옵티마이저**로 구성됩니다. 이 엔진은 표준 SQL(ANSI SQL) 문법을 지원하여 타 DBMS와 호환성을 유지합니다.

#### **스토리지 엔진**

MySQL 서버에는 다양한 스토리지 엔진을 동시에 사용할 수 있습니다. 각 스토리지 엔진은 데이터의 저장 및 조회를 담당하며, 특정 테이블이 사용하는 스토리지 엔진을 명시할 수 있습니다. 예를 들어, 다음 SQL 문에서 `test_table`은 **InnoDB** 스토리지 엔진을 사용하도록 정의되었습니다:

```sql
CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```

이후 `test_table`에 대해 발생하는 모든 데이터 작업은 InnoDB 스토리지 엔진이 처리합니다. 각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM)나 InnoDB 버퍼 풀과 같은 기능을 내장하고 있습니다.

#### **핸들러 API**

쿼리 실행기에서 데이터를 읽거나 쓰는 작업이 필요할 때, MySQL 엔진은 각 스토리지 엔진에 요청을 전달합니다. 이러한 요청을 **핸들러 요청**이라 하며, 여기서 사용되는 API를 **핸들러 API**라고 합니다. InnoDB 스토리지 엔진도 이 API를 통해 MySQL 엔진과 데이터를 주고받습니다.

핸들러 API를 통해 얼마나 많은 데이터 작업이 이루어졌는지는 다음 명령으로 확인할 수 있습니다:

```sql
SHOW GLOBAL STATUS LIKE 'Handler%';
```

이 명령은 다양한 핸들러 변수의 값을 보여주며, 각 변수는 특정 데이터 작업의 빈도를 나타냅니다.

### MySQL 스레딩 구조

MySQL 서버는 **프로세스 기반**이 아닌 **스레드 기반**으로 작동합니다. 이는 크게 **포그라운드 스레드**와 **백그라운드 스레드**로 나눌 수 있습니다. 각 스레드는 특정 작업을 처리하며, MySQL 서버 내의 모든 스레드는 `performance_schema.threads` 테이블을 통해 확인할 수 있습니다.

```sql
SELECT thread_id, name, type, processlist_user, processlist_host FROM performance_schema.threads ORDER BY type, thread_id;
```

**포그라운드 스레드 (클라이언트 스레드)**

포그라운드 스레드는 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 클라이언트가 요청한 쿼리문을 처리합니다. 클라이언트의 작업이 종료되면 해당 스레드는 **스레드 캐시**로 돌아갑니다. `thread_cache_size` 시스템 변수를 통해 캐시에 유지할 수 있는 최대 스레드 개수를 설정할 수 있습니다.

포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시에서 가져오며, 필요한 경우 디스크에서 직접 데이터를 읽어옵니다.

**백그라운드 스레드**

백그라운드 스레드는 주로 InnoDB 스토리지 엔진과 관련된 작업을 처리합니다. 이 작업에는 **인서트 버퍼 병합**, **로그 기록**, **버퍼의 데이터 디스크 기록**, **데이터 읽기** 등이 포함됩니다. 특히 중요한 것은 **로그 스레드**와 **쓰기 스레드**입니다. MySQL 5.5 버전부터는 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 `innodb_write_io_threads`와 `innodb_read_io_threads` 시스템 변수로 설정할 수 있습니다.

쓰기 작업은 버퍼링될 수 있지만, 읽기 작업은 지연될 수 없기 때문에 InnoDB는 쓰기 작업을 백그라운드에서 처리하며, 이 과정에서 성능을 최적화합니다.
