# 아키텍쳐

MySQL 서버는 크게 두 가지 주요 구성 요소로 나눌 수 있습니다: **MySQL 엔진**과 **스토리지 엔진**입니다. MySQL 엔진은 주로 쿼리 처리와 최적화를 담당하며, 스토리지 엔진은 실제 데이터를 저장하고 읽어오는 역할을 수행합니다. 이러한 구조로 인해 MySQL은 다른 DBMS와 차별화된 성능을 제공합니다.

## **MySQL 엔진 아키텍처**

MySQL 엔진은 클라이언트로부터의 쿼리 요청을 처리하는 **커넥션 핸들러**와 **쿼리 파서** 및 **옵티마이저**로 구성됩니다. 이 엔진은 표준 SQL(ANSI SQL) 문법을 지원하여 타 DBMS와 호환성을 유지합니다.

#### **스토리지 엔진**

MySQL 서버에는 다양한 스토리지 엔진을 동시에 사용할 수 있습니다. 각 스토리지 엔진은 데이터의 저장 및 조회를 담당하며, 특정 테이블이 사용하는 스토리지 엔진을 명시할 수 있습니다. 예를 들어, 다음 SQL 문에서 `test_table`은 **InnoDB** 스토리지 엔진을 사용하도록 정의되었습니다:

```sql
CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```

이후 `test_table`에 대해 발생하는 모든 데이터 작업은 InnoDB 스토리지 엔진이 처리합니다. 각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyISAM)나 InnoDB 버퍼 풀과 같은 기능을 내장하고 있습니다.

#### **핸들러 API**

쿼리 실행기에서 데이터를 읽거나 쓰는 작업이 필요할 때, MySQL 엔진은 각 스토리지 엔진에 요청을 전달합니다. 이러한 요청을 **핸들러 요청**이라 하며, 여기서 사용되는 API를 **핸들러 API**라고 합니다. InnoDB 스토리지 엔진도 이 API를 통해 MySQL 엔진과 데이터를 주고받습니다.

핸들러 API를 통해 얼마나 많은 데이터 작업이 이루어졌는지는 다음 명령으로 확인할 수 있습니다:

```sql
SHOW GLOBAL STATUS LIKE 'Handler%';
```

이 명령은 다양한 핸들러 변수의 값을 보여주며, 각 변수는 특정 데이터 작업의 빈도를 나타냅니다.

### MySQL 스레딩 구조

MySQL 서버는 **프로세스 기반**이 아닌 **스레드 기반**으로 작동합니다. 이는 크게 **포그라운드 스레드**와 **백그라운드 스레드**로 나눌 수 있습니다. 각 스레드는 특정 작업을 처리하며, MySQL 서버 내의 모든 스레드는 `performance_schema.threads` 테이블을 통해 확인할 수 있습니다.

```sql
SELECT thread_id, name, type, processlist_user, processlist_host FROM performance_schema.threads ORDER BY type, thread_id;
```

**포그라운드 스레드 (클라이언트 스레드)**

포그라운드 스레드는 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 주로 클라이언트가 요청한 쿼리문을 처리합니다. 클라이언트의 작업이 종료되면 해당 스레드는 **스레드 캐시**로 돌아갑니다. `thread_cache_size` 시스템 변수를 통해 캐시에 유지할 수 있는 최대 스레드 개수를 설정할 수 있습니다.

포그라운드 스레드는 데이터를 MySQL의 데이터 버퍼나 캐시에서 가져오며, 필요한 경우 디스크에서 직접 데이터를 읽어옵니다.

**백그라운드 스레드**

백그라운드 스레드는 주로 InnoDB 스토리지 엔진과 관련된 작업을 처리합니다. 이 작업에는 **인서트 버퍼 병합**, **로그 기록**, **버퍼의 데이터 디스크 기록**, **데이터 읽기** 등이 포함됩니다. 특히 중요한 것은 **로그 스레드**와 **쓰기 스레드**입니다. MySQL 5.5 버전부터는 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 `innodb_write_io_threads`와 `innodb_read_io_threads` 시스템 변수로 설정할 수 있습니다.

쓰기 작업은 버퍼링될 수 있지만, 읽기 작업은 지연될 수 없기 때문에 InnoDB는 쓰기 작업을 백그라운드에서 처리하며, 이 과정에서 성능을 최적화합니다.

### 플러그인 스토리지 엔진 모델

MySQL의 독특한 구조 중 하나는 **플러그인 모델**입니다. 플러그인을 통해 사용할 수 있는 것은 스토리지 엔진에 국한되지 않습니다. 예를 들어, 전문 검색 엔진을 위한 검색어 파서(인덱싱할 키워드를 분리하는 작업)도 플러그인 형태로 개발해서 사용할 수 있으며, 사용자 인증을 위한 Native Authentication과 CachingSHA-2 Authentication 등도 모두 플러그인으로 구현되어 제공됩니다.

MySQL에서 쿼리가 실행되는 과정을 살펴보면 대부분의 작업은 MySQL 엔진에서 처리되고, 마지막 단계인 '데이터 읽기/쓰기' 작업만 스토리지 엔진에서 처리됩니다. 즉, 사용자가 새로운 용도의 스토리지 엔진을 만든다 하더라도 DBMS의 전체 기능이 아닌 일부 기능만 수행하는 엔진을 작성하게 된다는 의미입니다.

**MySQL 엔진과 스토리지 엔진의 역할 분담**

MySQL 엔진은 쿼리 파서, 옵티마이저, 쿼리 실행기 등의 주요 기능을 처리하며, 실제 데이터의 읽기와 쓰기 작업은 스토리지 엔진에서 처리됩니다. 이처럼 MySQL 엔진은 사람의 두뇌 역할을 하고, 스토리지 엔진은 손과 발 역할을 한다고 비유할 수 있습니다.

MySQL 엔진이 스토리지 엔진에게 데이터 읽기/쓰기를 명령할 때는 반드시 핸들러를 통해 이루어집니다. 'Handler\_'로 시작하는 상태 변수들은 MySQL 엔진이 각 스토리지 엔진에게 보낸 명령의 횟수를 의미합니다. 따라서 MySQL에서 MyISAM이나 InnoDB 같은 다른 스토리지 엔진을 사용하는 테이블에 대해 쿼리를 실행하더라도, MySQL의 처리 과정은 대부분 동일하며, 단지 데이터 읽기/쓰기 영역의 처리만 차이가 있을 뿐입니다.

#### 설치된 스토리지 엔진 확인

설치된 MySQL 서버(mysqld)에서 지원되는 스토리지 엔진을 확인하기 위해서는 `SHOW ENGINES;` 명령을 사용할 수 있습니다. 이 명령을 통해 MySQL 서버에 포함된 스토리지 엔진과 그 상태를 확인할 수 있습니다.

예를 들어:

```sql
SHOW ENGINES;
```

위 명령을 실행하면 MySQL 서버에 포함된 스토리지 엔진 목록이 출력됩니다. 각 엔진의 상태는 YES, DEFAULT, NO, DISABLED로 표시되며, 각 값의 의미는 다음과 같습니다:

* **YES:** MySQL 서버에 해당 스토리지 엔진이 포함되어 있으며 활성화된 상태입니다.
* **DEFAULT:** 'YES'와 동일하지만 필수 스토리지 엔진임을 의미합니다. 이 엔진이 없으면 MySQL이 시작되지 않을 수도 있습니다.
* **NO:** 현재 MySQL 서버에 포함되지 않았음을 의미합니다.
* **DISABLED:** MySQL 서버에 포함되었으나 파라미터에 의해 비활성화된 상태입니다.

만약 MySQL 서버에 포함되지 않은 스토리지 엔진을 사용하려면 MySQL 서버를 다시 빌드(컴파일)해야 합니다. 그러나 플러그인 형태로 빌드된 스토리지 엔진 라이브러리를 다운로드하여 쉽게 추가할 수 있으며, 플러그인 형태의 스토리지 엔진은 손쉽게 업그레이드할 수도 있습니다.

#### 플러그인 확인

모든 플러그인의 내용은 `SHOW PLUGINS;` 명령으로 확인할 수 있습니다. 이 명령을 사용하면 설치된 스토리지 엔진뿐만 아니라 인증, 전문 검색용 파서, 쿼리 재작성과 같은 다른 플러그인도 확인할 수 있습니다.

### 쿼리 실행 구조

MySQL의 쿼리 실행 구조는 여러 단계로 나누어져 있으며, 각 단계에서 쿼리를 처리하고 최적화하는 작업이 이루어집니다. 이 구조는 MySQL 엔진과 스토리지 엔진으로 나누어져 있으며, 각 엔진이 서로 다른 역할을 담당합니다.

**1. 쿼리 파서**

쿼리 파서는 사용자가 입력한 SQL 문장을 토큰(token)으로 분리하고 트리 형태의 구조로 만드는 작업을 담당합니다. 이 과정에서 SQL 문장의 기본 문법 오류를 검출하며, 오류가 발견되면 사용자에게 오류 메시지를 반환합니다. 이 단계에서는 SQL 쿼리를 MySQL이 이해할 수 있는 내부 표현으로 변환합니다.

**2. 전처리기**

전처리기는 쿼리 파서가 생성한 파서 트리를 기반으로 SQL 문장의 구조적인 문제를 확인합니다. 이 과정에서 쿼리에 참조된 테이블, 칼럼, 내장 함수 등의 객체가 실제로 존재하는지, 사용자가 해당 객체에 접근할 권한이 있는지를 검사합니다. 이 단계에서 존재하지 않거나 접근할 수 없는 객체가 있으면 쿼리 실행이 중단되고 오류가 반환됩니다.

**3. 옵티마이저**

옵티마이저는 SQL 쿼리를 가장 저렴한 비용으로, 가장 빠르게 실행할 방법을 결정합니다. 이 단계는 쿼리 실행 계획을 수립하는 데 중점을 둡니다. 옵티마이저는 다양한 쿼리 처리 전략을 평가하여 최적의 실행 계획을 선택합니다. 예를 들어, 테이블을 스캔할 때 인덱스를 사용할지, 조인 순서를 어떻게 할지 등을 결정합니다. 이 과정에서 옵티마이저는 SQL 쿼리를 가능한 한 효율적으로 실행하기 위한 다양한 전략을 고려합니다.

**4. 실행 엔진**

실행 엔진은 옵티마이저가 수립한 실행 계획을 실제로 실행하는 역할을 합니다. 이 엔진은 각 단계에서 데이터를 읽고 처리하며, 필요한 경우 데이터를 저장하기도 합니다. 예를 들어, GROUP BY를 처리하기 위해 임시 테이블이 필요하다면, 실행 엔진은 이를 생성하고 데이터를 임시 테이블에 저장하는 작업을 수행합니다. 실행 엔진은 옵티마이저의 지시에 따라 작업을 진행하며, 각 작업 결과를 다음 작업의 입력으로 사용합니다.

**5. 핸들러 (스토리지 엔진)**

핸들러는 MySQL 서버의 가장 하단에서 실행 엔진의 요청에 따라 데이터를 디스크에 저장하거나 디스크로부터 데이터를 읽어오는 역할을 담당합니다. 핸들러는 결국 스토리지 엔진을 의미하며, MyISAM, InnoDB, Memory와 같은 스토리지 엔진이 각각의 핸들러로 작동합니다. 예를 들어, MyISAM 테이블을 조작하는 경우 MyISAM 스토리지 엔진의 핸들러가, InnoDB 테이블을 조작하는 경우 InnoDB 스토리지 엔진의 핸들러가 작업을 수행합니다.

#### 복제

MySQL 서버에서 \*\*복제(Replication)\*\*는 매우 중요한 기능입니다. 복제는 MySQL 서버 간에 데이터를 동기화하고 고가용성을 유지하는 데 중요한 역할을 합니다. 이 기능은 데이터베이스 서버의 백업, 로드 밸런싱, 데이터 분석 등의 다양한 목적에 사용됩니다. MySQL 복제의 아키텍처와 세부적인 내용은 복제 관련 장에서 자세히 다루게 됩니다.

#### 쿼리 캐시

MySQL 서버에서 \*\*쿼리 캐시(Query Cache)\*\*는 웹 기반의 응용 프로그램에서 빠른 응답을 제공하는 데 중요한 역할을 했습니다. 쿼리 캐시는 SQL 실행 결과를 메모리에 캐시하여 동일한 SQL 쿼리가 실행될 때 테이블을 다시 읽지 않고 즉시 결과를 반환할 수 있게 했습니다. 이는 데이터가 변경되지 않은 경우에 매우 빠른 성능을 제공했습니다.

하지만 MySQL 8.0에서는 쿼리 캐시 기능이 제거되었습니다. 그 이유는 데이터가 변경되면 쿼리 캐시에 저장된 결과를 무효화해야 하는데, 이 과정에서 성능 저하와 동시 처리 성능 문제가 발생했기 때문입니다. 또한, 쿼리 캐시 기능은 특정한 환경에서만 유용하며, 대부분의 경우 성능 향상보다는 오히려 문제가 되는 경우가 많았습니다. 따라서 MySQL 8.0에서는 쿼리 캐시 기능을 제거하는 것이 좋은 선택이었습니다.

### 스레드풀

MySQL 서버의 스레드풀(Thread Pool) 기능은 MySQL 서버의 성능을 최적화하는 데 사용됩니다. 이 기능은 MySQL 서버 엔터프라이즈 에디션에서 제공되며, Percona Server에서도 유사한 기능을 플러그인 형태로 사용할 수 있습니다.

스레드풀은 사용자의 요청을 처리하는 스레드의 수를 제한하여, 동시에 처리되는 요청이 많아도 MySQL 서버의 CPU가 효율적으로 작동하도록 합니다. 많은 사용자가 스레드풀 기능을 설치하면 성능이 크게 향상될 것으로 기대하지만, 실제로는 스레드풀이 모든 상황에서 성능 향상을 보장하지는 않습니다. 스레드풀은 서버의 자원 소모를 줄이고, CPU의 프로세서 친화도를 높이는 데 기여하지만, 잘못된 설정으로 인해 오히려 성능이 저하될 수도 있습니다.

Percona Server의 스레드풀은 CPU 코어의 개수만큼 스레드 그룹을 생성하며, 각 스레드 그룹은 사용자의 요청을 처리합니다. 스레드 그룹의 수는 `thread_pool_size` 시스템 변수로 조정할 수 있으며, 사용자의 요청이 많을 때는 추가 스레드를 생성하여 처리할 수도 있습니다. 그러나 스레드 그룹이 이미 많은 작업을 처리하고 있다면, 새로운 작업은 일정 시간이 지나야 처리될 수 있습니다.

스레드풀은 또한 선순위 큐와 후순위 큐를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능도 제공합니다. 이렇게 하면 잠금 경합을 줄이고, 전체적인 처리 성능을 향상시킬 수 있습니다.

#### 트랜잭션 지원 메타데이터

데이터베이스 서버에서 테이블의 구조 정보와 스토어드 프로그램 등의 정보는 데이터 딕셔너리 또는 메타데이터라고 불립니다. MySQL 서버는 5.7 버전까지 테이블의 구조를 파일(`.FRM` 파일)에 저장하고, 일부 스토어드 프로그램도 파일 기반으로 관리했습니다. 그러나 이러한 파일 기반 메타데이터는 트랜잭션을 지원하지 않아, 테이블 생성이나 변경 도중 MySQL 서버가 비정상적으로 종료되면 일관되지 않은 상태로 남을 수 있었습니다.

MySQL 8.0부터는 이러한 문제를 해결하기 위해, 테이블의 구조 정보나 스토어드 프로그램의 코드를 모두 InnoDB 테이블에 저장하도록 개선되었습니다. 이로 인해 MySQL 서버가 비정상적으로 종료되더라도 스키마 변경 작업은 완전한 성공 또는 완전한 실패로 정리되어, 데이터베이스의 일관성이 유지됩니다.

InnoDB 스토리지 엔진을 사용하는 테이블의 메타정보는 InnoDB 기반의 데이터 딕셔너리에 저장되며, MyISAM이나 CSV와 같은 다른 스토리지 엔진의 메타정보는 여전히 파일로 저장됩니다. MySQL 서버는 InnoDB 이외의 스토리지 엔진을 사용하는 테이블을 위해 `.sdi` 파일을 사용하며, 이 파일은 기존의 `.FRM` 파일과 동일한 역할을 합니다.

MySQL 8.0의 이러한 개선 사항은 데이터베이스의 안정성과 일관성을 높이는 데 크게 기여하며, 시스템 테이블과 데이터 딕셔너리 정보를 InnoDB 테이블에 저장함으로써 트랜잭션 기반의 데이터 관리를 가능하게 합니다.

#### 프라이머리 키에 의한 클러스터링

InnoDB의 모든 테이블은 기본적으로 프라이머리 키(Primary Key)를 기준으로 클러스터링되어 저장됩니다. 이 말은 프라이머리 키 값의 순서대로 레코드가 디스크에 물리적으로 저장된다는 것을 의미합니다. 이러한 클러스터링 덕분에, 세컨더리 인덱스(Secondary Index)는 실제 레코드의 물리적 주소 대신, 프라이머리 키의 값을 참조하여 해당 레코드를 찾습니다. 따라서 프라이머리 키가 클러스터링 인덱스(Clustering Index) 역할을 하며, 이를 이용한 레인지 스캔(Range Scan)은 매우 빠르게 수행될 수 있습니다.

쿼리의 실행 계획에서 프라이머리 키는 다른 보조 인덱스에 비해 우선적으로 선택되는 경향이 있습니다. 이는 오라클 DBMS의 IOT(Index-Organized Table)와 동일한 개념으로, InnoDB에서는 이러한 클러스터링 인덱스 구조가 일반 테이블 구조로 사용됩니다. 클러스터링 인덱스에 대한 더 자세한 내용은 8.8절에서 다루게 됩니다.

반면, MyISAM 스토리지 엔진은 클러스터링 키를 지원하지 않습니다. 따라서 MyISAM 테이블에서는 프라이머리 키와 세컨더리 인덱스 간에 구조적 차이가 없습니다. 프라이머리 키는 단지 유니크 제약을 가진 세컨더리 인덱스일 뿐이며, MyISAM 테이블의 모든 인덱스는 레코드의 물리적 주소 값(ROWID)을 참조합니다. MyISAM 테이블의 구조와 인덱스에 대해서는 4.3.3절 '데이터 파일과 프라이머리 키(인덱스) 구조'를 참고하시기 바랍니다.

### 외래 키 지원

InnoDB 스토리지 엔진은 외래 키(Foreign Key)를 지원합니다. 외래 키는 데이터베이스의 참조 무결성을 유지하는 데 중요한 역할을 합니다. 그러나 MyISAM이나 MEMORY 스토리지 엔진에서는 외래 키를 사용할 수 없습니다.

외래 키를 사용하면 부모 테이블과 자식 테이블의 특정 칼럼 간에 참조 관계가 설정되며, 이 칼럼들에는 인덱스가 생성되어야 합니다. 또한, 부모 테이블이나 자식 테이블에서 데이터 변경이 발생할 때마다 해당 테이블에 데이터가 존재하는지 확인하는 작업이 필요합니다. 이러한 작업이 추가적인 잠금을 유발하고, 이는 여러 테이블로 전파되어 데드락(Deadlock)이 발생할 가능성을 높입니다. 따라서 외래 키 사용 시 주의가 필요합니다.

서비스 환경에서 외래 키를 사용하는 것이 번거롭거나 성능 저하를 유발할 수 있으므로, 많은 경우 외래 키를 사용하지 않는 방향으로 설계하기도 합니다. 하지만 개발 환경에서는 데이터 무결성을 유지하는 데 도움이 되므로 외래 키 사용을 고려할 수 있습니다.

외래 키 체크를 일시적으로 비활성화하여 데이터 적재나 스키마 변경 등의 작업을 신속하게 처리할 수 있습니다. 이 경우, `foreign_key_checks` 시스템 변수를 `OFF`로 설정하면 외래 키 체크 작업을 중지할 수 있습니다. 작업이 완료되면 `foreign_key_checks`를 다시 `ON`으로 설정하여 외래 키 체크를 활성화하는 것이 중요합니다.

```sql
SET SESSION foreign_key_checks = OFF; -- 작업 실행
SET SESSION foreign_key_checks = ON;
```

이 설정은 세션 범위에서만 유효하며, 작업을 완료한 후에는 외래 키 체크 기능을 반드시 활성화해야 데이터의 무결성을 유지할 수 있습니다. 외래 키 체크를 비활성화한 상태에서 부모 테이블의 레코드를 삭제한 경우, 자식 테이블의 관련 레코드도 삭제하여 일관성을 유지해야 합니다. 또한, 외래 키 체크를 비활성화하면 `ON DELETE CASCADE`와 `ON UPDATE CASCADE` 옵션도 무시되므로, 이에 주의해야 합니다.

### MVCC (Multi-Version Concurrency Control)

MVCC(다중 버전 동시성 제어)는 레코드 수준의 트랜잭션을 지원하는 DBMS에서 제공하는 기능입니다. MVCC의 주요 목적은 잠금을 사용하지 않고도 일관된 읽기(Consistent Read)를 제공하는 데 있습니다. InnoDB는 언두 로그(Undo Log)를 활용하여 이 기능을 구현합니다.

'멀티 버전'이란, 하나의 레코드에 대해 여러 개의 버전이 동시에 관리된다는 의미입니다. 이를 통해 트랜잭션 격리 수준(Isolation Level)에 따라 각 트랜잭션이 다른 버전의 데이터를 읽을 수 있게 됩니다. 예를 들어, 트랜잭션 격리 수준이 READ\_COMMITTED인 MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블에서 데이터 변경이 어떻게 처리되는지 살펴보겠습니다.

**예시: MVCC를 이용한 데이터 변경**

먼저, 다음과 같은 테이블에 한 건의 레코드를 `INSERT`한 후 `UPDATE`하여 데이터 변경 작업을 확인합니다.

```sql
CREATE TABLE member (
    m_id INT NOT NULL,
    m_name VARCHAR(20) NOT NULL,
    m_area VARCHAR(100) NOT NULL,
    PRIMARY KEY (m_id),
    INDEX ix_area (m_area)
);
INSERT INTO member (m_id, m_name, m_area) VALUES (12, '홍길동', '서울');
```

`INSERT` 문이 실행되면, InnoDB 버퍼 풀과 데이터 파일에 레코드가 기록됩니다.

그 다음, `UPDATE` 문을 실행하여 데이터를 변경합니다.

```sql
UPDATE member SET m_area = '경기' WHERE m_id = 12;
```

이 경우, InnoDB 버퍼 풀은 즉시 새로운 값(‘경기’)으로 업데이트되며, 기존 값(‘서울’)은 언두 로그에 저장됩니다. 데이터 파일에 새로운 값이 기록될 수 있지만, 아직 커밋되지 않은 상태에서는 변경된 데이터를 다른 트랜잭션이 읽을 수 없습니다.

```sql
SELECT * FROM member WHERE m_id = 12;
```

이 쿼리에 대한 응답은 트랜잭션 격리 수준에 따라 달라집니다. 격리 수준이 READ\_UNCOMMITTED인 경우, InnoDB 버퍼 풀에 있는 변경된 데이터를 읽습니다. 그러나 READ\_COMMITTED 이상의 격리 수준에서는 아직 커밋되지 않았기 때문에, 언두 영역에 있는 기존 데이터를 반환합니다. 이는 MVCC의 동작 원리입니다.

#### 잠금 없는 일관된 읽기 (Non-Locking Consistent Read)

InnoDB 스토리지 엔진은 MVCC 기술을 활용하여 잠금을 걸지 않고도 읽기 작업을 수행합니다. 이 덕분에, 다른 트랜잭션이 잠금을 걸고 있더라도 읽기 작업은 지연되지 않고 수행될 수 있습니다.

예를 들어, 트랜잭션 격리 수준이 SERIALIZABLE이 아닌 READ\_UNCOMMITTED, READ\_COMMITTED, REPEATABLE\_READ 수준인 경우, INSERT와 연결되지 않은 순수한 읽기(SELECT) 작업은 다른 트랜잭션의 변경 작업과 상관없이 잠금 없이 바로 실행됩니다. InnoDB에서는 변경되기 전의 데이터를 읽기 위해 언두 로그를 사용하여, 잠금 없이 일관된 읽기를 제공합니다.

### 자동 데드락 감지

InnoDB 스토리지 엔진은 내부적으로 데드락(Deadlock)을 감지하기 위해 잠금 대기 목록을 그래프 형태로 관리합니다. InnoDB는 데드락 감지 스레드를 통해 주기적으로 잠금 대기 그래프를 검사하여 교착 상태에 빠진 트랜잭션을 찾아내고, 그 중 하나를 강제로 롤백합니다. 이때 롤백 대상이 되는 트랜잭션은 일반적으로 언두 로그의 양이 적은 트랜잭션이 선택됩니다. 언두 로그가 적다는 것은 롤백을 할 때 처리해야 할 내용이 적다는 의미이며, 서버에 미치는 부하도 덜합니다.

InnoDB는 MySQL 엔진에서 관리되는 테이블 잠금을 볼 수 없으므로, 데드락 감지가 불확실할 수 있습니다. 이를 보완하기 위해 `innodb_table_locks` 시스템 변수를 활성화하면 InnoDB 내부의 레코드 잠금뿐만 아니라 테이블 수준의 잠금까지 감지할 수 있습니다.

동시 처리 스레드가 많아지거나, 각 트랜잭션이 가진 잠금의 개수가 많아지면 데드락 감지 스레드가 느려질 수 있습니다. 이로 인해 서비스에 영향을 미칠 수 있습니다. 이러한 경우, `innodb_deadlock_detect` 시스템 변수를 `OFF`로 설정하여 데드락 감지 스레드를 비활성화할 수 있습니다. 이 경우, 데드락 상황에서는 `innodb_lock_wait_timeout` 시스템 변수를 설정하여 일정 시간이 지나면 트랜잭션이 실패하고 에러 메시지를 반환하도록 설정할 수 있습니다.

```sql
SET innodb_deadlock_detect = OFF;
SET innodb_lock_wait

_timeout = 10; -- 10초로 설정
```

이와 같이 설정하면 데드락 감지 스레드의 부하를 줄이고, 시스템 성능을 최적화할 수 있습니다. `innodb_deadlock_detect`를 비활성화한 경우, `innodb_lock_wait_timeout` 값을 낮추어 설정하는 것이 좋습니다. 이는 트랜잭션이 교착 상태에 빠졌을 때 빠르게 처리할 수 있도록 도와줍니다.

따라서 이 기능을 비활성화할 수 있도록 MySQL 소스 코드를 수정하여 사용했으며, 이 기능의 필요성을 오라클에 요청하여 MySQL 서버에 추가했습니다. 만약 PK 또는 세컨더리 인덱스를 기반으로 높은 동시성 처리를 요구하는 서비스가 있다면, `innodb_deadlock_detect`를 비활성화하고 성능을 비교해보는 것도 좋은 방법일 수 있습니다.
