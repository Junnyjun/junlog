# 도메인 객체 생명 주기

### 도메인 객체의 생명주기

모든 객체는 생명주기를 가지고 있습니다. 객체는 생성되고, 다양한 상태를 거치며, 결국 삭제되거나 보관됩니다. 간단하고 일시적인 객체는 생성자 호출을 통해 쉽게 생성되고 사용된 후 가비지 컬렉터에 의해 제거됩니다. 하지만 대부분의 경우, 우리는 더 복잡하고 긴 생명주기를 가진 객체에 대해 작업하게 됩니다. 이러한 지속적인 객체들을 관리하는 것은 모델 기반 설계(Model-Driven Design)를 실현하는 데 있어서 큰 도전 과제가 됩니다.

#### 생명주기 관리의 문제점

객체의 생명주기 관리는 두 가지 주요 문제를 야기합니다:

1. 생명주기 전반에 걸쳐 객체의 무결성을 유지하는 것.
2. 생명주기 관리를 복잡하게 만드는 것을 방지하는 것.

#### 생명주기 문제 해결을 위한 패턴

이 문제들을 해결하기 위해 세 가지 패턴이 사용됩니다: AGGREGATES, FACTORIES, 그리고 REPOSITORIES입니다. 이들 패턴은 각각 객체의 특정 생명주기 단계에서 발생하는 문제를 해결하고, 전체적인 모델의 복잡성을 관리하는 데 도움을 줍니다.

**AGGREGATES**

AGGREGATES는 객체 간의 관계를 간소화하고 무결성을 유지하기 위한 방법입니다. AGGREGATE는 관련된 객체의 집합으로, 데이터 변경의 단위로 취급됩니다. 각 AGGREGATE는 루트 엔티티와 경계를 가집니다. AGGREGATE 내의 객체는 서로 참조할 수 있지만, 외부 객체는 루트 엔티티를 통해서만 참조할 수 있습니다.

**AGGREGATE 규칙**

AGGREGATE 패턴을 사용하면 모델의 무결성을 유지하면서 객체 간의 관계를 간단하게 만들 수 있습니다. AGGREGATE의 주요 규칙은 다음과 같습니다:

1. 루트 엔티티는 전역 식별성을 가지며, 내부 엔티티는 지역 식별성을 가집니다.
2. AGGREGATE 내부 객체 간의 참조는 허용되지만, 외부 객체는 루트 엔티티에만 참조할 수 있습니다.
3. 데이터베이스 쿼리를 통해 직접 접근할 수 있는 것은 AGGREGATE의 루트 엔티티뿐입니다.
4. 삭제 작업은 AGGREGATE 경계 내의 모든 객체를 한 번에 제거해야 합니다.
5. AGGREGATE 경계 내의 모든 객체가 커밋될 때, 모든 불변 조건이 충족되어야 합니다.

이러한 규칙을 통해 AGGREGATE는 객체의 복잡한 관계를 간소화하고, 객체의 생명주기 동안 무결성을 유지할 수 있습니다. 이를 통해 객체 모델의 복잡성을 줄이고, 유지보수를 쉽게 할 수 있습니다.

**AGGREGATE의 장점**

AGGREGATE를 사용하면 다음과 같은 장점을 얻을 수 있습니다:

* 객체 간의 관계를 명확하게 정의하여 모델의 복잡성을 줄입니다.
* 객체의 생명주기 동안 무결성을 유지하여 데이터 일관성을 보장합니다.
* 트랜잭션 범위를 정의하여 동시성 문제를 효과적으로 관리합니다.

**FACTORIES**

FACTORIES는 객체의 생성과 관련된 복잡성을 캡슐화하여 클라이언트가 객체 생성의 내부 구조를 알 필요 없게 합니다. FACTORY 패턴은 객체 또는 AGGREGATE를 생성할 때 사용됩니다. FACTORY는 객체의 내부 구조를 숨기고, 클라이언트가 단순한 인터페이스를 통해 객체를 생성할 수 있도록 합니다.

**FACTORY의 주요 역할**

FACTORY의 주요 역할은 객체의 초기 상태를 설정하고, 생성 과정에서 모든 불변 조건이 충족되도록 하는 것입니다. FACTORY는 객체 생성 시 필요한 모든 데이터를 받아서 객체를 생성하고 초기화합니다. 이를 통해 클라이언트는 객체의 내부 구조나 생성 과정에 대해 알 필요 없이 객체를 사용할 수 있습니다.

**FACTORY의 규칙**

FACTORY의 주요 규칙은 다음과 같습니다:

1. 생성 메서드는 원자적이어야 하며, 생성된 객체 또는 AGGREGATE의 모든 불변 조건을 만족시켜야 합니다.
2. FACTORY는 구체적인 클래스가 아닌, 추상 타입을 반환해야 합니다.

이러한 규칙을 통해 FACTORY는 객체 생성의 복잡성을 줄이고, 객체의 초기 상태를 쉽게 설정할 수 있습니다. 이를 통해 클라이언트는 객체 생성 과정에 대한 복잡성을 신경 쓰지 않고, 객체의 기능에 집중할 수 있습니다.

**FACTORY의 장점**

FACTORY를 사용하면 다음과 같은 장점을 얻을 수 있습니다:

* 객체 생성 과정의 복잡성을 캡슐화하여 클라이언트 코드를 단순화합니다.
* 객체의 내부 구조를 숨겨서 캡슐화를 유지합니다.
* 객체 생성 시 불변 조건을 충족하여 데이터 무결성을 보장합니다.

**REPOSITORIES**

REPOSITORIES는 객체의 저장, 검색, 삭제와 관련된 복잡성을 캡슐화하여 클라이언트가 간단한 인터페이스를 통해 객체를 조작할 수 있도록 합니다. REPOSITORY 패턴은 특정 타입의 모든 객체를 개념적으로 모은 집합체로, 객체를 저장하고 검색하는 기능을 제공합니다.

**REPOSITORY의 주요 역할**

REPOSITORY의 주요 역할은 데이터베이스와 같은 저장소와의 상호작용을 캡슐화하여 클라이언트가 도메인 모델의 용어로 객체를 조작할 수 있도록 하는 것입니다. REPOSITORY는 데이터베이스 쿼리 및 매핑의 복잡성을 숨기고, 클라이언트가 필요한 객체를 쉽게 검색하고 조작할 수 있도록 합니다.

**REPOSITORY의 규칙**

REPOSITORY의 주요 규칙은 다음과 같습니다:

1. REPOSITORY는 객체를 추가하고 제거하는 메서드를 제공해야 합니다.
2. REPOSITORY는 특정 기준에 따라 객체를 검색하는 메서드를 제공해야 합니다.
3. REPOSITORY는 AGGREGATE 루트에 대해서만 제공해야 합니다.

이러한 규칙을 통해 REPOSITORY는 데이터베이스와의 상호작용을 단순화하고, 클라이언트가 필요한 객체를 쉽게 검색하고 조작할 수 있습니다. 이를 통해 클라이언트는 데이터베이스의 세부 사항에 신경 쓰지 않고, 도메인 모델의 용어로 작업할 수 있습니다.

**REPOSITORY의 장점**

REPOSITORY를 사용하면 다음과 같은 장점을 얻을 수 있습니다:

* 객체의 생명주기 관리를 단순화하여 클라이언트 코드를 단순화합니다.
* 데이터베이스와의 상호작용을 캡슐화하여 도메인 모델의 무결성을 유지합니다.
* 다양한 검색 기능을 제공하여 클라이언트가 필요한 데이터를 쉽게 얻을 수 있도록 합니다.

#### 생명주기의 적용

이제 이러한 개념들을 실제 도메인 객체의 생명주기에 적용해보겠습니다. 예를 들어, 브로커리지 계좌 시스템을 통해 AGGREGATE, FACTORY, REPOSITORY 패턴이 어떻게 사용되는지 설명하겠습니다.

**브로커리지 계좌 시스템의 초기 모델**

브로커리지 계좌 시스템의 초기 모델은 고객과 투자 객체 간의 관계를 설정합니다. 이 연관 관계는 객체 포인터나 데이터베이스 조회를 통해 구현될 수 있습니다. 브로커리지 계좌는 AGGREGATE 루트로, 고객과 투자 객체는 AGGREGATE 내의 객체로 간주됩니다. 외부 객체는 브로커리지 계좌를 통해서만 고객과 투자 객체에 접근할 수 있습니다.

**브로커리지 계좌 시스템에서 FACTORY 패턴의 적용**

브로커리지 계좌 시스템에서 FACTORY 패턴을 적용하여 객체 생성의 복잡성을 줄입니다. FACTORY는 브로커리지 계좌와 관련된 모든 객체의 초기 상태를 설정하고, 생성 과정에서 모든 불변 조건이 충족되도록 합니다. FACTORY는 추상 타입을 반환하여 클라이언트가 구체적인 클래스에 의존하지 않도록 합니다.

**브로커리지 계좌 시스템에서 REPOSITORY 패턴의 적용**

브로커리지 계좌 시스템에서 REPOSITORY 패턴을 적용하여 객체의 저장, 검색, 삭제와 관련된 복잡성을 줄입니다. REPOSITORY는 브로커리지 계좌를 추가하고 제거하는 메서드를 제공하고, 특정 기준에 따라 브로커리지 계좌를 검색하는 메서드를 제공합니다. REPOSITORY는 브로커리지 계좌의 AGGREGATE 루트에 대해서만 제공됩니다.



도메인 객체의 생명주기를 관리하기 위해 AGGREGATES, FACTORIES, REPOSITORIES 패턴을 사용하는 것은 모델 기반 설계의 핵심입니다. AGGREGATES는 객체 간의 관계를 간소화하고 무결성을 유지하며, FACTORIES는 객체 생성의 복잡성을 캡슐화하고, REPOSITORIES는 객체의 저장, 검색, 삭제와 관련된 복잡성을 관리합니다. 이러한 패턴을 통해 도메인 모델의 무결성을 유지하고, 복잡성을 줄이며, 모델 기반 설계를 실현할 수 있습니다.

이러한 패턴들을 통해 객체

의 생명주기를 효율적으로 관리하고, 모델의 복잡성을 줄이며, 유지보수를 쉽게 할 수 있습니다. AGGREGATES, FACTORIES, REPOSITORIES 패턴은 각각 객체의 특정 생명주기 단계에서 발생하는 문제를 해결하고, 전체적인 모델의 복잡성을 관리하는 데 큰 도움을 줍니다. 이를 통해 도메인 모델의 일관성을 유지하고, 시스템의 신뢰성을 높일 수 있습니다.
