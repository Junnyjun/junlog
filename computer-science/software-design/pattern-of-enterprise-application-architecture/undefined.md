# 계층화

### 1장: 레이어링

레이어링은 소프트웨어 설계자가 복잡한 소프트웨어 시스템을 분해하는 데 사용하는 일반적인 기법 중 하나이다. 머신 아키텍처에서 레이어는 프로그래밍 언어와 운영 체제 호출, 디바이스 드라이버, CPU 명령어 세트, 칩 내부의 논리 게이트까지 다양하게 구성된다. 네트워킹에서는 FTP가 TCP 위에, TCP는 IP 위에, IP는 이더넷 위에 위치한다.

시스템을 레이어로 구성할 때, 소프트웨어의 주요 하위 시스템을 케이크 층처럼 배열하여 각 레이어가 하위 레이어에 의존하지만, 하위 레이어는 상위 레이어를 인식하지 못하는 구조를 상상할 수 있다. 또한, 각 레이어는 보통 하위 레이어를 상위 레이어로부터 숨기기 때문에, 레이어 4는 레이어 3의 서비스를 사용하고, 레이어 3은 레이어 2의 서비스를 사용하지만, 레이어 4는 레이어 2를 인식하지 못한다. 모든 레이어링 아키텍처가 이렇게 불투명한 것은 아니지만, 대부분은 이러한 구조를 가지고 있다.

레이어로 시스템을 분해하는 것은 여러 중요한 이점을 제공한다:

* 각 레이어를 별개의 전체로 이해할 수 있어 다른 레이어에 대해 잘 알지 못해도 된다. 예를 들어, 이더넷이 어떻게 작동하는지 몰라도 TCP 위에 FTP 서비스를 구축하는 방법을 이해할 수 있다.
* 동일한 기본 서비스를 제공하는 대체 구현으로 레이어를 교체할 수 있다. FTP 서비스는 이더넷, PPP 또는 케이블 회사가 사용하는 어떤 기술 위에서도 변경 없이 실행될 수 있다.
* 레이어 간의 의존성을 최소화할 수 있다. 케이블 회사가 물리적 전송 시스템을 변경하더라도, IP가 작동하기만 하면 FTP 서비스를 수정할 필요가 없다.
* 레이어는 표준화하기 좋은 위치이다. TCP와 IP는 레이어의 작동 방식을 정의하는 표준이다.
* 레이어를 한 번 구축하면 많은 고급 서비스에 사용할 수 있다. 따라서 TCP/IP는 FTP, 텔넷, SSH, HTTP 등에 사용된다. 그렇지 않으면 모든 고급 프로토콜은 자체 하위 프로토콜을 작성해야 할 것이다.

레이어링은 중요한 기술이지만 단점도 존재한다:

* 레이어는 모든 것을 잘 캡슐화하지 못한다. 그 결과 종종 연쇄적인 변화가 발생할 수 있다. 예를 들어, 엔터프라이즈 애플리케이션에서 UI에 표시해야 할 필드를 추가하는 경우, 데이터베이스에서 UI까지 모든 레이어에 이를 추가해야 한다.
* 추가 레이어는 성능을 저하시킬 수 있다. 각 레이어에서 일반적으로 다른 표현으로 변환해야 하기 때문이다. 그러나 하위 기능을 캡슐화하면 효율성이 증가하여 이를 상쇄할 수 있다. 예를 들어, 트랜잭션을 제어하는 레이어는 최적화되어 전체 성능을 향상시킬 수 있다.

레이어 아키텍처에서 가장 어려운 부분은 어떤 레이어를 가져야 하고 각 레이어의 책임이 무엇인지 결정하는 것이다.

#### 엔터프라이즈 애플리케이션의 레이어 진화

초기 배치 시스템 시절에는 레이어에 대해 별로 생각하지 않았다고 생각된다. 프로그램을 작성하여 파일(ISAM, VSAM 등)을 조작하는 것이 애플리케이션의 전부였다. 레이어는 필요하지 않았다.

레이어 개념은 90년대 클라이언트-서버 시스템이 등장하면서 더 분명해졌다. 클라이언트-서버 시스템은 두 레이어 시스템이었다: 클라이언트는 사용자 인터페이스와 애플리케이션 코드를, 서버는 주로 관계형 데이터베이스를 보유하고 있었다. 일반적인 클라이언트 도구로는 VB, Powerbuilder, Delphi 등이 있었다. 이러한 도구는 SQL을 인식하는 UI 위젯을 제공하여 데이터 집약적인 애플리케이션을 쉽게 구축할 수 있었다. 예를 들어, 디자인 영역에 컨트롤을 드래그하고 속성 시트를 사용하여 데이터베이스에 컨트롤을 연결하면 화면을 구축할 수 있었다.

애플리케이션이 관계형 데이터를 표시하고 단순히 업데이트하는 것이라면, 이러한 클라이언트-서버 시스템은 매우 잘 작동했다. 문제는 도메인 로직, 즉 비즈니스 규칙, 검증, 계산 등에서 발생했다. 일반적으로 사람들은 이를 클라이언트에 작성했지만, 이는 UI 화면에 직접 논리를 내장하는 불편한 작업이었다. 도메인 로직이 복잡해질수록 이 코드는 다루기 어려워졌다. 또한, 화면에 논리를 내장하면 코드 중복이 발생하기 쉬워 단순한 변경도 여러 화면에서 유사한 코드를 찾아야 했다.

대안으로는 도메인 로직을 데이터베이스의 저장 프로시저로 옮기는 것이었다. 그러나 저장 프로시저는 구조화 메커니즘이 제한되어 있어 다시 코드가 불편해졌다. 또한, 많은 사람들은 SQL이 표준이기 때문에 데이터베이스 벤더를 변경할 수 있다는 점에서 관계형 데이터베이스를 선호했다. 하지만 저장 프로시저는 모든 벤더가 독자적이기 때문에 이 옵션을 제거했다.

클라이언트-서버가 인기를 얻는 동안 객체 지향 세계도 부상하고 있었다. 객체 지향 커뮤니티는 도메인 로직 문제에 대한 답을 제공했다: 3층 시스템으로 이동하는 것이었다. 이 접근법에서는 프레젠테이션 레이어(사용자 인터페이스), 도메인 레이어(도메인 로직), 데이터 소스를 구분했다. 이렇게 하면 복잡한 도메인 로직을 UI에서 분리하여 객체로 구조화할 수 있는 레이어에 넣을 수 있었다.

하지만 객체 지향 접근법은 큰 진전을 이루지 못했다. 많은 시스템이 단순하거나 최소한 시작은 단순했기 때문이다. 3층 접근법은 많은 이점이 있었지만, 클라이언트-서버 도구는 문제가 단순할 경우 매력적이었다. 또한, 클라이언트-서버 도구는 3층 구성에서 사용하기 어렵거나 불가능했다.

웹의 등장은 커다란 충격을 주었다. 사람들은 웹 브라우저로 클라이언트-서버 애플리케이션을 배포하고 싶어했다. 그러나 모든 비즈니스 로직이 리치 클라이언트에 묻혀 있다면, 모든 비즈니스 로직을 웹 인터페이스로 다시 작성해야 했다. 잘 설계된 3층 시스템은 새로운 프레젠테이션 레이어만 추가하면 되었다. 또한, 자바의 등장은 객체 지향 언어가 주류에 진입하는 계기가 되었다. 웹 페이지를 구축하는 도구는 SQL에 덜 의존하여 3층 구조에 더 적합했다.

레이어에 대해 논의할 때 레이어와 티어라는 용어에 혼동이 있을 수 있다. 종종 두 용어는 동의어로 사용되지만, 대부분의 사람들은 티어가 물리적 분리를 의미한다고 본다. 클라이언트-서버 시스템은 종종 두 티어 시스템으로 설명되며, 분리는 물리적이다: 클라이언트는 데스크탑이고 서버는 서버이다. 레이어라는 용어를 사용할 때는 레이어가 다른 머신에서 실행되지 않아도 된다는 점을 강조한다. 도메인 로직의 별도의 레이어는 데스크탑이나 데이터베이스 서버에서 실행될 수 있다. 이 경우 두 개의 노드가 있지만, 세 개의 별개의 레이어가 존재한다. 로컬 데이터베이스를 사용하면 모든 레이어를 단일 랩탑에서 실행할 수 있지만, 여전히 세 개의 별개의 레이어가 존재한다.

#### 세 가지 주요 레이어

이 책에서는 프레젠테이션, 도메인, 데이터 소스라는 세 가지 주요 레이어 중심으로 논의한다. \[Brown et al.]의 이름을 따랐다. 표 1.1은 이러한 레이어를 요약한 것이다.

**프레젠테이션 레이어**

프레젠테이션 로직은 사용자와 소프트웨어 간의 상호작용을 처리하는 것이다. 이는 명령 줄이나 텍스트 기반 메뉴 시스템처럼 간단할 수 있지만, 요즘은 리치 클라이언트 그래픽 UI나 HTML 기반 브라우저 UI일 가능성이 높다. (이 책에서는 리치 클라이언트를 Windows/Swing/풍부한 클라이언트 UI로, HTML 브라우저와는 반대 개념으로 사용한다.) 프레젠테이션 레이어의 주요 책임은 사용자에게 정보를 표시하고, 사용자의 명령을 도메인과 데이터 소스에 대한 작업으로 해석하는 것이다.

**데이터 소스 레이어**

데이터 소스 로직은 애플리케이션을 대신하여 작업을 수행하는 다른 시스템과의 통신을 담당한다. 이는 트랜잭션 모니터, 다른 애플리케이션, 메시징 시스템 등이 될 수 있다. 대부분의 엔터프라이즈 애플리케이션에서 데이터 소스 로직의 가장 큰 부분은 영구 데이터를 저장하는 데이터베이스이다.

**도메인 레이어**

도메인 로직은 비즈니스 로직으로도 불린다. 이는 애플리케이션이 도메인에서 수행해야 하는 작업이다. 입력 데이터와 저장된 데이터를 기반으로 한 계산, 프레젠테이션에서 들어오는 데이터의 검증, 프레젠테이션에서 받은 명령에 따라 어떤 데이터 소스 로직을 실행할지 결정하는 것이 포함된다.

레이어는 도메인 레이어가 프레젠테이션으로부터 데이터 소스를 완전히 숨기도록 배열될 수 있다. 그러나 실제로는 프레젠테이션이 데이터 스토어에 직접 접근하는 경우가 더 많다. 이는 순수하지 않지만, 실제로는 더 잘 작동한다. 프레젠테이션은 사용자의 명령을 해석하여 데이터 소스를 사용해 데이터베이스에서 관련 데이터를 가져오고, 도메인 로직이 해당 데이터를 조작한 후 이를 화면에 표시한다.

하나의 애플리케이션은 각 세 가지 주제 영역에 여러 패키지를 포함할 수 있다. 예를 들어, 리치 클라이언트 인터페이스와 명령 줄을 통해 조작되는 애플리케이션은 두 가지 프레젠테이션을 가질 수 있다: 하나는 리치 클라이언트 인터페이스를 위한 것이고, 다른 하나는 명령 줄을 위한 것이다. 여러 데이터 소스 컴포넌트가 다른 데이터베이스와 통신하기 위해 존재할 수 있다. 심지어 도메인은 서로 상대적으로 분리된 영역으로 나뉠 수 있다.

시스템이 사람에 의해 조작되지 않는 경우에는 어떻게 되는지에 대한 의문이 생길 수 있다. 이것은 웹 서비스나 배치 프로세스와 같은 것일 수 있다. 후자의 경우, 사용자(Client)는 클라이언트 프로그램이다. 이 시점에서 프레젠테이션과 데이터 소스 레이어는 모두 외부 세계와의 연결에 관한 것이라는 점에서 유사성이 있다. 이는 Alistair Cockburn의 헥사고날 아키텍처 패턴에서 시스템을 외부 인터페이스로 둘러싸인 코어로 시각화하는 논리와 동일하다. 헥사고날 아키텍처에서는 모든 외부가 기본적으로 외부 인터페이스이며, 따라서 대칭적 구조를 가진다.

그러나 비대칭 구조는 서비스 제공과 서비스 이용 간의 차이를 구분하는 데 유용하다. 프레젠테이션은 시스템이 다른 사람에게 제공하는 서비스의 외부 인터페이스이며, 데이터 소스는 시스템이 사용하는 외부 서비스의 인터페이스이다. 이러한 구분은 클라이언트의 차이가 서비스를 생각하는 방식에 영향을 미치기 때문에 유용하다.

엔터프라이즈 애플리케이션의 세 가지 일반적인 책임 레이어인 프레젠테이션, 도메인, 데이터 소스를 식별할 수 있지만, 이를 분리하는 방법은 애플리케이션의 복잡성에 따라 다르다. 데이터베이스에서 데이터를 가져와 웹 페이지에 표시하는 간단한 스크립트는 모두 하나의 프로시저일 수 있다. 나는 여전히 세 레이어를 분리하려고 노력할 것이지만, 이 경우에는 각 레이어의 동작을 별도의 서브루틴에 배치하는 것만으로도 충분할 수 있다. 시스템이 더 복잡해지면, 세 레이어를 별도의 클래스로 분리할 것이다. 복잡성이 더 증가하면 클래스를 별도의 패키지로 나눌 것이다. 내 일반적인 조언은 문제에 가장 적합한 형태의 분리를 선택하되, 최소한 서브루틴 수준에서 분리를 반드시 수행하라는 것이다.

#### 결론

레이어링은 소프트웨어 시스템을 효율적으로 분해하고 관리하기 위한 중요한 기법이다. 이를 통해 복잡한 시스템을 보다 쉽게 이해하고, 대체 구현을 가능하게 하며, 의존성을 최소화하고, 표준화를 촉진할 수 있다. 엔터프라이즈 애플리케이션에서는 프레젠테이션, 도메인, 데이터 소스의 세 가지 주요 레이어를 구분하여 시스템을 설계하는 것이 일반적이다. 각 레이어의 역할과 책임을 명확히 정의하고, 가능한 한 의존성을 줄이는 것이 중요하다. 이러한 레이어링 기법을 잘 활용하면 복잡한 소프트웨어 시스템을 보다 효과적으로 설계하고 관리할 수 있다.
