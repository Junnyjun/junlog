# 운영체제 개요

운영체제는 컴퓨터 하드웨어를 관리하는 소프트웨어입니다. 응용 프로그램과 사용자 사이의 중개자 역할을 하며, 컴퓨터 자원을 효율적으로 할당하고 제어합니다. 운영체제는 자동차, 가전(IoT), 스마트폰, PC, 서버, 클라우드 등 거의 모든 컴퓨팅 환경에 존재하며, 환경마다 다르게 구현되지만 기본 개념은 유사합니다.

### 1.1 운영체제가 하는 일 (What Operating Systems Do)

컴퓨터 시스템은 크게 네 부분으로 구성됩니다 (Figure 1.1):

* **하드웨어** (CPU, 메모리, I/O 장치) → 기본 컴퓨팅 자원 제공
* **운영체제**
* **응용 프로그램** (워드프로세서, 스프레드시트, 컴파일러, 웹 브라우저 등)
* **사용자**

하드웨어는 기본 컴퓨팅 자원을 제공하고, 응용 프로그램은 이 자원을 이용해 사용자의 문제를 해결합니다. 운영체제는 하드웨어를 제어하고, 여러 응용 프로그램과 사용자 간에 자원 사용을 조정합니다.

컴퓨터 시스템을 하드웨어, 소프트웨어, 데이터로 볼 수도 있습니다. 운영체제는 이러한 자원을 올바르게 사용하는 수단을 제공합니다.

운영체제를 **정부**에 비유할 수 있습니다. 정부 자체는 직접 유용한 일을 하지 않지만, 사람들이 생산적인 활동을 할 수 있는 환경을 만듭니다.

운영체제의 역할을 이해하기 위해 **사용자 관점**과 **시스템 관점**에서 살펴보겠습니다.

#### 1.1.1 사용자의 관점 (User View)

사용자가 컴퓨터를 보는 방식은 사용하는 인터페이스에 따라 다릅니다.

많은 사용자는 노트북이나 PC(모니터, 키보드, 마우스) 앞에 앉아 있습니다. 이런 시스템은 한 사용자가 자원을 독점하도록 설계되었습니다. 목표는 사용자가 수행하는 작업(일 또는 놀이)을 최대화하는 것입니다. 이 경우 운영체제는 주로 **사용 편의성(ease of use)** 을 위해 설계되며, 성능과 보안에 어느 정도 주의를 기울이지만 **자원 이용률(resource utilization)** —하드웨어·소프트웨어 자원이 어떻게 공유되는지—에는 거의 신경 쓰지 않습니다.

최근 스마트폰과 태블릿 같은 모바일 컴퓨터가 널리 사용되고 있습니다. 대부분의 모바일 기기는 개별 사용자용 독립 장치이며, 셀룰러나 무선 기술로 네트워크에 연결됩니다. 이러한 기기는 데스크톱·노트북을 대체하며 이메일과 웹 브라우징에 주로 사용됩니다. 모바일 기기의 사용자 인터페이스는 주로 **터치스크린**이며, 사용자가 화면을 누르고 스와이프하여 상호작용합니다. 일부는 **음성 인식**(예: Apple의 Siri)도 지원합니다.

일부 컴퓨터는 사용자 관점이 거의 없습니다. 가정 기기나 자동차의 **임베디드 컴퓨터**는 숫자 키패드와 상태 표시 LED 정도만 있을 수 있으며, 사용자 개입 없이 동작하도록 설계됩니다.

#### 1.1.2 시스템 관점 (System View)

컴퓨터 입장에서 운영체제는 하드웨어와 가장 밀접하게 연관된 프로그램입니다.

이 관점에서 운영체제를 **자원 할당자(resource allocator)** 로 볼 수 있습니다. 컴퓨터 시스템에는 CPU 시간, 메모리 공간, 파일 저장 공간, I/O 장치 등 많은 자원이 있습니다. 여러 프로그램과 사용자가 (종종 상충되는) 자원 요청을 할 때, 운영체제는 컴퓨터 시스템을 효율적이고 공정하게 운영할 수 있도록 자원을 할당해야 합니다.

다른 관점에서는 운영체제를 **제어 프로그램(control program)** 으로 봅니다. 제어 프로그램은 사용자 프로그램의 실행을 관리하여 오류와 컴퓨터의 부적절한 사용을 방지합니다. 특히 I/O 장치의 동작과 제어에 중점을 둡니다.

#### 1.1.3 운영체제 정의 (Defining Operating Systems)

운영체제의 정의는 완벽하게 합의된 것이 없습니다. 컴퓨터의 다양성(토스터부터 우주선까지) 때문에 정의가 어렵습니다.

가장 일반적인 정의는 두 가지입니다:

* **좁은 의미**: 항상 실행 중인 **커널(kernel)** 만을 운영체제라고 함.
* **넓은 의미** (이 책에서 주로 사용): 커널 + 시스템 프로그램 + 일부 미들웨어(특히 모바일 OS에서 두드러짐).

모바일 OS(iOS, Android)는 커널뿐 아니라 미들웨어(데이터베이스, 멀티미디어, 그래픽 프레임워크 등)를 포함합니다.

결론적으로 운영체제는 **사용자 프로그램이 유용한 작업을 수행할 수 있는 환경을 제공**하는 모든 소프트웨어입니다.

### 1.2 컴퓨터 시스템 구성 (Computer-System Organization)

현대 범용 컴퓨터는 하나 이상의 CPU와 여러 장치 컨트롤러가 공통 버스(system bus)로 연결되어 있으며, 공유 메모리에 접근합니다 (Figure 1.2).

각 장치 컨트롤러는 특정 장치 유형(디스크 드라이브, 오디오 장치, 그래픽 디스플레이 등)을 담당합니다. 컨트롤러는 로컬 버퍼 저장소와 특수 목적 레지스터 세트를 유지합니다.

운영체제는 일반적으로 각 장치 컨트롤러마다 **디바이스 드라이버**를 가지고 있습니다. 이 드라이버는 장치 컨트롤러를 이해하고 운영체제의 나머지 부분에 장치에 대한 균일한 인터페이스를 제공합니다.

CPU와 장치 컨트롤러는 병렬로 실행되며 메모리 사이클을 놓고 경쟁합니다. 공유 메모리에 대한 질서 있는 접근을 보장하기 위해 메모리 컨트롤러가 접근을 동기화합니다.

#### 1.2.1 인터럽트 (Interrupts)

인터럽트는 현대 운영체제의 핵심 메커니즘입니다.

I/O 작업을 시작하려면 디바이스 드라이버가 장치 컨트롤러의 적절한 레지스터를 로드합니다. 컨트롤러는 이 레지스터 내용을 검사하여 행동(예: 키보드에서 문자 읽기)을 결정합니다. 데이터 전송이 완료되면 컨트롤러는 디바이스 드라이버에게 완료를 알립니다. 이는 **인터럽트**를 통해 이루어집니다.

**인터럽트의 기본 동작**

하드웨어는 시스템 버스를 통해 신호를 보내 언제든지 인터럽트를 발생시킬 수 있습니다. CPU가 인터럽트를 감지하면 현재 작업을 중단하고 고정된 위치로 실행을 전환합니다. 이 위치에는 인터럽트 서비스 루틴(ISR)의 시작 주소가 있습니다.

인터럽트 서비스 루틴이 실행된 후 CPU는 중단된 계산을 재개합니다 (Figure 1.3).

대부분의 컴퓨터는 **인터럽트 벡터**라는 포인터 테이블을 사용합니다. 이 테이블은 저메모리(처음 수백 위치)에 저장되며, 각 인터럽트 요청에 고유 번호와 함께 제공되어 해당 서비스 루틴의 주소를 가리킵니다.

인터럽트 핸들러는 변경할 상태를 저장하고, 인터럽트 원인을 파악한 후 처리하고, 상태를 복원한 뒤 return\_from\_interrupt 명령으로 복귀합니다.

현대 시스템은 다음과 같은 기능을 제공합니다:

* 중요한 처리 중 인터럽트 처리를 지연할 수 있는 능력
* 적절한 인터럽트 핸들러로 효율적 디스패치
* 다단계 인터럽트(우선순위 구분)

대부분의 CPU는 **nonmaskable interrupt**(NMI)와 **maskable interrupt** 두 줄을 가집니다. 마스커블 인터럽트는 중요한 명령 시퀀스 전에 꺼질 수 있습니다.

**인터럽트 체이닝**을 통해 여러 핸들러를 리스트로 연결하기도 합니다.

#### 1.2.2 저장장치 구조 (Storage Structure)

CPU는 메모리에서만 명령어를 로드할 수 있으므로, 프로그램은 실행 전에 **메인 메모리(RAM, DRAM)** 에 적재되어야 합니다.

RAM은 **휘발성**이므로 부트스트랩 프로그램은 **EEPROM**이나 **펌웨어** 같은 비휘발성 저장소에 보관됩니다.

대부분의 프로그램은 **2차 저장장치**(HDD, SSD, NVM)에 상주하며, 필요 시 메모리로 로드됩니다. 2차 저장장치는 대용량·비휘발성이지만 느립니다.

**저장장치 계층 구조**:

* 레지스터 → 캐시 → 메인 메모리 → 전자 디스크 → 자기 디스크 → 광 디스크 등

운영체제는 이 계층을 효율적으로 관리합니다.

#### 1.2.3 입출력 구조 (I/O Structure)

I/O도 인터럽트 기반으로 동작합니다. DMA(Direct Memory Access)를 사용하면 대용량 전송 시 CPU 개입을 최소화할 수 있습니다.

***

#### 1.3 컴퓨터 시스템 아키텍처 (Computer-System Architecture)

**단일 프로세서 시스템 (Single-Processor Systems)**

과거 대부분의 컴퓨터 시스템은 하나의 CPU(중앙처리장치)를 가졌습니다.\
이 CPU에는 하나의 **프로세서**(processor)가 포함되어 있으며, 이 프로세서는 명령어를 가져오고(fetch), 디코딩하고(decode), 실행(execute)하는 역할을 합니다.\
단일 프로세서 시스템은 여전히 소규모 임베디드 시스템(가전제품, 자동차 컨트롤러 등)에서 널리 사용되지만, 범용 컴퓨터에서는 거의 사라졌습니다.

**다중 프로세서 시스템 (Multiprocessor Systems)**

요즘 대부분의 범용 컴퓨터는 **다중 프로세서**(multiprocessor)를 탑재합니다.\
장점:

* **처리량 증가** (throughput increase): 여러 프로세서가 동시에 작업 → 더 많은 작업 처리
* **경제성** (economy of scale): 여러 CPU를 하나의 시스템에 넣으면 주변장치(메모리, I/O 등)를 공유 → 비용 절감
* **신뢰성 증가** (increased reliability): 한 CPU가 고장 나도 다른 CPU가 작업 계속 (graceful degradation)

다중 프로세서 시스템은 크게 두 가지로 나뉩니다:

1. **대칭형 다중 처리 (Symmetric Multiprocessing, SMP)**\
   모든 프로세서가 동등하며, 하나의 공유 메모리에 접근합니다.\
   각 프로세서는 자체 로컬 캐시를 가질 수 있지만, 메모리는 공유됩니다.\
   대부분의 현대 PC, 서버, 스마트폰이 SMP 방식입니다.
2. **비대칭형 다중 처리 (Asymmetric Multiprocessing)**\
   하나의 **마스터 프로세서**가 작업을 분배하고, 나머지 **슬레이브 프로세서**가 실행합니다.\
   오늘날 거의 사용되지 않습니다.

**클러스터드 시스템 (Clustered Systems)**

클러스터는 여러 시스템(노드)이 느슨하게 결합되어 하나의 시스템처럼 동작합니다.\
고가용성(high availability)과 높은 처리량을 제공합니다.

클러스터 유형:

* **고가용성 클러스터** (High-Availability Clusters): 한 노드가 실패하면 다른 노드가 작업을 이어받음 (failover)
* **병렬 처리 클러스터** (Parallel Clusters): 동시에 여러 노드가 동일한 애플리케이션 실행 (예: Oracle Real Application Clusters)\
  → 공유 디스크에 대한 접근 제어와 **분산 잠금 관리자(Distributed Lock Manager, DLM)** 필요

현대 클러스터는 **스토리지 영역 네트워크(SAN)** 를 통해 수천 개 노드를 지원하며, 노드 간 거리가 수 마일 떨어져도 동작 가능합니다 (Figure 1.11: 클러스터드 시스템의 일반 구조).

**기타 아키텍처**

* **NUMA (Non-Uniform Memory Access)**: 메모리가 여러 노드에 분산되어 있지만, 접근 시간이 위치에 따라 다름
* **GPU + CPU 하이브리드**: 그래픽 처리 장치(GPU)가 병렬 연산을 담당 (현대 시스템에서 매우 중요)

#### 1.4 운영체제 동작 (Operating-System Operations)

운영체제는 프로그램이 실행되는 환경을 제공합니다.\
부팅 과정부터 시작해서 인터럽트, 시스템 호출, 프로세스 관리 등 내부 동작을 설명합니다.

**부팅 과정 (Bootstrap & System Startup)**

컴퓨터 전원이 켜지거나 재부팅될 때 **부트스트랩 프로그램**(bootstrap program)이 먼저 실행됩니다.

* ROM/EEPROM/플래시 메모리에 저장된 간단한 펌웨어
* CPU 레지스터, 장치 컨트롤러, 메모리 초기화
* 운영체제 커널을 찾아 메모리에 로드

커널이 로드·실행되면 시스템 서비스를 제공합니다.\
일부 서비스는 **시스템 데몬**(system daemon) 형태로 부팅 시 메모리에 적재됩니다.

* Linux 예: **systemd**가 첫 번째 시스템 프로그램으로 여러 데몬 시작

부팅 완료 후 시스템은 **이벤트 대기** 상태에 들어갑니다.

**인터럽트와 트랩 (Interrupts and Traps)**

운영체제는 거의 항상 **인터럽트**에 의해 구동됩니다.

* **하드웨어 인터럽트**: 장치 컨트롤러가 신호 발생 (I/O 완료, 타이머 등)
* **트랩(Trap) 또는 예외(Exception)**: 소프트웨어가 생성하는 인터럽트
  * 오류: 0으로 나누기, 잘못된 메모리 접근 → 운영체제가 처리
  * **시스템 호출(System Call)**: 사용자 프로그램이 운영체제 서비스 요청 시 의도적으로 발생 (read(), write() 등)

**듀얼 모드와 멀티프로그래밍 (Dual Mode & Multiprogramming)**

운영체제는 사용자 프로그램이 하드웨어를 직접 조작하지 못하게 보호해야 합니다.\
→ **듀얼 모드(dual mode)** 운영: **사용자 모드(user mode)** 와 **커널 모드(kernel mode)**

* 사용자 모드: 제한된 명령어만 실행 가능
* 커널 모드: 모든 명령어 실행 가능 (privileged instructions)

사용자 프로그램이 특권 명령을 시도하면 **트랩** 발생 → 운영체제가 제어권 회수.

현대 시스템은 **멀티프로그래밍(multiprogramming)** 과 **멀티태스킹(multitasking)** 을 지원합니다.

* 여러 프로그램이 메모리에 동시에 적재
* CPU가 한 프로그램이 I/O 대기 시 다른 프로그램으로 전환
* **가상 메모리(virtual memory)**: 프로그램이 실제 메모리보다 큰 공간을 사용할 수 있게 함 (Chapter 9\~10 참조)

**파일 시스템과 I/O 관리**

멀티프로그래밍 시스템은 파일 시스템도 제공해야 합니다 (Chapter 13\~15).

***

#### 1.5 자원 관리 (Resource Management)

운영체제는 컴퓨터 시스템의 여러 자원을 효율적으로 관리합니다. 주요 자원 관리 영역은 다음과 같습니다.

* **프로세스 관리 (Process Management)**\
  프로세스는 실행 중인 프로그램입니다. 운영체제는 프로세스의 생성·삭제, 일시중지·재개, 동기화, 통신 등을 담당합니다.\
  CPU 스케줄링(어떤 프로세스가 CPU를 사용할지 결정)도 여기에 포함됩니다 (Chapter 3\~5 상세 설명).
* **메모리 관리 (Memory Management)**\
  메인 메모리는 제한적입니다. 운영체제는 메모리 할당·해제, 프로세스가 필요할 때 메모리 로드, 가상 메모리(디스크를 메모리처럼 사용)를 관리합니다.\
  각 프로세스가 독립된 메모리 공간을 가지도록 보호합니다 (Chapter 9\~10).
* **파일 시스템 관리 (File-System Management)**\
  파일은 데이터의 논리적 저장 단위입니다. 운영체제는 파일 생성·삭제·읽기·쓰기, 디렉터리 관리, 접근 권한 제어, 백업 등을 담당합니다 (Chapter 13\~15).
* **캐시 관리 (Cache Management)**\
  CPU와 메모리 사이 속도 차이를 줄이기 위해 캐시를 사용합니다. 운영체제는 캐시 일관성(cache coherence)을 유지합니다.
* **대용량 저장장치 관리 (Mass-Storage Management)**\
  디스크(HDD/SSD) 스케줄링, 공간 할당, RAID 구성 등을 관리합니다 (Chapter 11).
* **입출력 관리 (I/O Management)**\
  장치 드라이버를 통해 다양한 I/O 장치를 균일하게 제어합니다 (Chapter 12).

#### 1.6 보안과 보호 (Security and Protection)

운영체제는 시스템 자원을 보호해야 합니다.

* **보호 (Protection)**: 프로세스가 다른 프로세스나 운영체제의 자원을 부적절하게 접근하지 못하게 합니다.\
  메모리 보호, 파일 접근 제어, CPU 사용 시간 제한(타이머 인터럽트) 등.
* **보안 (Security)**: 외부 공격(바이러스, 해킹)으로부터 시스템을 보호합니다.\
  사용자 인증, 방화벽, 암호화, 침입 탐지 등이 포함됩니다.

듀얼 모드(커널 모드 vs 사용자 모드)와 시스템 호출이 보호의 핵심 메커니즘입니다.

#### 1.7 가상화 (Virtualization)

가상화는 하나의 물리적 컴퓨터 위에 여러 가상 머신(VM)을 생성하여 각 VM이 독립된 운영체제를 실행하게 합니다.

* **이점**: 서버 통합, 테스트 환경 구축, 클라우드 컴퓨팅(IaaS) 기반.
* **하이퍼바이저**(Hypervisor): 가상화를 담당하는 소프트웨어 (Type 1: 베어 메탈, Type 2: 호스트 OS 위).
* 현대 운영체제(Linux KVM, Windows Hyper-V, VMware 등)는 가상화를 지원합니다.

가상화는 자원 효율성을 극대화하며, 클라우드 시대의 핵심 기술입니다.

#### 1.8 분산 시스템 (Distributed Systems)

분산 시스템은 네트워크로 연결된 여러 독립 컴퓨터가 하나의 시스템처럼 동작합니다.

* **특징**: 자원 공유, 병렬 처리, 신뢰성 향상, 확장성.
* **예시**: 클라이언트-서버 모델, P2P, Hadoop 클러스터, 클라우드(Google, AWS 등).
* **도전 과제**: 네트워크 지연, 장애 처리, 데이터 일관성, 보안.

분산 시스템은 현대 컴퓨팅의 대부분을 차지합니다 (Chapter 16\~18에서 상세).

#### 1.9 커널 데이터 구조 (Kernel Data Structures)

운영체제 커널은 다양한 데이터 구조를 사용합니다.

* **리스트 (Lists)**: 프로세스 목록, 파일 열린 목록 등 (단일/이중 연결 리스트).
* **스택 (Stacks)**: 함수 호출 추적, 인터럽트 처리.
* **큐 (Queues)**: 프로세스 스케줄링 대기열, I/O 요청 큐.
* **트리 (Trees)**: 파일 시스템 디렉터리 구조, 메모리 관리.
* **해시 테이블 (Hash Tables)**: 빠른 검색 (페이지 테이블, 파일 시스템 inode 캐시).
* **비트맵 (Bitmaps)**: 디스크 블록 할당 상태 표시.

이 구조들은 효율성과 확장성을 위해 설계됩니다.

#### 1.10 컴퓨팅 환경 (Computing Environments)

운영체제는 다양한 환경에서 동작합니다.

* **전통적 컴퓨팅 (Traditional Computing)**: PC, 워크스테이션, 클라이언트-서버.
* **모바일 컴퓨팅 (Mobile Computing)**: 스마트폰, 태블릿 (Android, iOS) → 터치/음성 인터페이스, 배터리·네트워크 최적화.
* **클라우드 컴퓨팅 (Cloud Computing)**: SaaS, PaaS, IaaS → 가상화 + 분산 시스템.
* **실시간 임베디드 시스템 (Real-Time Embedded Systems)**: 자동차, 의료기기 → 실시간 응답 보장.
* **분산·클라우드 환경**: Hadoop, Spark 등 빅데이터 처리.

#### 1.11 자유 및 오픈소스 운영체제 (Free and Open-Source Operating Systems)

오픈소스 OS는 소스 코드를 공개·수정·배포할 수 있습니다.

* **Linux**: Linus Torvalds가 1991년 시작, 수천 명 기여자 → 서버, 모바일(Android 기반), 임베디드 등 가장 널리 사용.
* **BSD 계열**: FreeBSD, OpenBSD → 안정성·보안 강조.
* **기타**: Solaris (오픈소스화), Darwin (macOS 기반).

오픈소스는 빠른 발전, 커뮤니티 지원, 비용 절감이 장점입니다.
