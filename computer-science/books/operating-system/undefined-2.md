# 프로세스

#### 3.1 프로세스 개념 (Process Concept)

\*\*프로세스(Process)\*\*란 \*\*실행 중인 프로그램(program in execution)\*\*입니다.\
프로그램 자체는 디스크에 저장된 **수동적(passive) 엔티티** (실행 가능한 바이너리 파일)인 반면, 프로세스는 메모리에 적재되어 CPU에 의해 실제로 실행되는 **능동적(active) 엔티티**입니다.

**프로세스의 메모리 구성 (Process in Memory, Figure 3.1)**

프로세스가 메모리에 적재될 때 다음과 같은 구조를 가집니다:

* **텍스트 섹션 (Text section)**: 실행 가능한 프로그램 코드 (컴파일된 기계어 명령어)
* **데이터 섹션 (Data section)**: 전역 변수와 정적 변수 (초기화된 데이터 + BSS 영역)
* **힙 (Heap)**: 런타임에 동적으로 할당되는 메모리 영역 (C의 malloc(), C++의 new, Java의 new 등으로 크기가 증가)
* **스택 (Stack)**: 함수 호출 시 자동으로 관리되는 영역 (지역 변수, 함수 매개변수, 반환 주소 저장). 함수가 호출될 때마다 커지고, 반환되면 줄어듦

각 프로세스는 \*\*완전히 독립된 주소 공간(address space)\*\*을 가집니다.\
한 프로세스가 다른 프로세스의 메모리 영역을 직접 읽거나 쓸 수 없도록 \*\*메모리 보호(memory protection)\*\*가 적용됩니다.

**프로그램 vs 프로세스**

* **프로그램(program)**: 디스크에 저장된 수동적 존재 (executable file)
* **프로세스(process)**: 메모리에 로드되어 실행 중인 능동적 존재

하나의 프로그램이 여러 개의 프로세스로 동시에 실행될 수도 있습니다.\
예) 웹 브라우저를 여러 창으로 띄우면 각 창이 별도의 프로세스가 됩니다.

#### 3.2 프로세스 상태 (Process State)

프로세스는 실행되는 동안 여러 상태를 오갑니다 (Figure 3.2 – 프로세스 상태 다이어그램).

**주요 5가지 상태**:

1. **New (신규)**: 프로세스가 막 생성되었지만 아직 메모리에 적재되지 않은 상태
2. **Ready (준비)**: 프로세스가 메모리에 적재되어 있고, 언제든지 CPU를 할당받을 수 있는 상태
3. **Running (실행)**: CPU가 실제로 프로세스의 명령어를 실행하고 있는 상태
4. **Waiting (대기 / Blocked)**: 프로세스가 어떤 이벤트(I/O 완료, 신호 수신 등)를 기다리고 있는 상태
5. **Terminated (종료)**: 프로세스가 실행을 마치고 종료된 상태 (자원 회수 대기)

**상태 전이 과정**:

* New → Ready : 장기 스케줄러가 메모리에 적재
* Ready → Running : 단기 스케줄러(CPU 스케줄러)가 선택하여 dispatch
* Running → Ready : 타이머 인터럽트 또는 우선순위가 높은 프로세스에 의해 선점(preemption)
* Running → Waiting : I/O 요청, 이벤트 대기, 자식 프로세스 종료 대기 등
* Waiting → Ready : 기다리던 I/O가 완료되거나 이벤트가 발생
* Running → Terminated : exit() 시스템 호출 또는 치명적 오류 발생

#### 3.3 프로세스 제어 블록 (Process Control Block, PCB)

PCB(Process Control Block)는 **운영체제가 각 프로세스를 관리하기 위해 유지하는 핵심 데이터 구조**입니다.\
커널 메모리 영역에 저장되며, 프로세스마다 하나씩 존재합니다 (Figure 3.3).

**PCB에 저장되는 주요 정보**:

* **프로세스 상태 (Process state)**: New, Ready, Running, Waiting, Terminated 중 하나
* \*\*프로세스 ID (PID)\*\*와 **부모 프로세스 ID (PPID)**
* **프로그램 카운터 (Program Counter, PC)**: 다음에 실행할 명령어의 메모리 주소
* **CPU 레지스터 값**: 모든 범용 레지스터, 스택 포인터, 베이스/리미트 레지스터, 프로그램 상태 워드(PSW) 등
* **CPU 스케줄링 정보**: 프로세스 우선순위, 스케줄링 큐 포인터, CPU 사용 시간 등
* **메모리 관리 정보**: 페이지 테이블, 세그먼트 테이블, 베이스·리미트 레지스터 값
* **회계 정보 (Accounting)**: 사용한 CPU 시간, 시간 제한, 실행 시간 등
* **I/O 상태 정보**: 할당된 I/O 장치 목록, 열린 파일 목록, 파일 포인터 등

PCB는 **컨텍스트 스위칭(context switch)** 시 가장 중요한 역할을 합니다.\
CPU가 한 프로세스에서 다른 프로세스로 전환될 때, 현재 프로세스의 PCB에 모든 상태를 저장하고, 새 프로세스의 PCB에서 상태를 복원합니다.

#### 3.4 프로세스 스케줄링 (Process Scheduling)

운영체제는 프로세스가 CPU를 효율적으로 사용하도록 **스케줄링 큐**를 관리합니다 (Figure 3.5).

**주요 큐**:

* **Job Queue (작업 큐)**: 디스크에 있는 모든 프로세스
* **Ready Queue (준비 큐)**: 메모리에 적재되어 CPU를 기다리는 프로세스들 (링크드 리스트 형태)
* **Device Queue (장치 큐)**: 각 I/O 장치마다 별도로 존재하는 대기 큐

**스케줄러 종류**:

* **장기 스케줄러 (Long-term Scheduler / Job Scheduler)**: 디스크 → 메모리 적재 여부 결정 (멀티프로그래밍 정도 조절)
* **단기 스케줄러 (Short-term Scheduler / CPU Scheduler)**: 준비 큐에서 실행 상태로 보낼 프로세스 선택 (매우 자주 호출됨)
* **중기 스케줄러 (Medium-term Scheduler)**: 메모리 과부하 시 프로세스를 디스크로 스와핑 (swap out)

#### 3.5 프로세스 생성 (Process Creation)

부모 프로세스가 **자식 프로세스**를 생성할 수 있습니다.\
생성된 프로세스들은 트리 구조를 형성합니다 (Figure 3.6 – 프로세스 트리).

**UNIX/Linux 방식**:

* `fork()` 시스템 호출: 부모 프로세스의 거의 완전한 복사본 생성 (PID만 다름)
* `exec()` 계열 시스템 호출: 새 프로그램으로 메모리 내용 교체 (텍스트·데이터·힙 교체)

**Windows 방식**:

* `CreateProcess()`: 생성 + 프로그램 로드 + 실행을 한 번에 수행

자식 프로세스는 부모로부터 자원의 일부(메모리, 파일 등)를 상속받을 수 있습니다.

#### 3.6 프로세스 종료 (Process Termination)

프로세스는 다음 방법으로 종료됩니다:

* 정상 종료: `exit()` 시스템 호출 (마지막 명령어 실행 후)
* 비정상 종료: `abort()` 호출 또는 치명적 오류 (세그먼테이션 폴트, 0으로 나누기 등)
* 부모가 자식 종료 기다림: `wait()` 또는 `waitpid()`

부모가 종료되면 자식 프로세스의 처리:

* **Cascade termination**: 부모가 종료되면 모든 자식도 종료
* **Orphan process**: 부모가 먼저 종료되면 자식이 init 프로세스(또는 systemd)의 자식이 됨

#### 3.7 프로세스 간 통신 (Interprocess Communication, IPC)

프로세스는 \*\*독립 프로세스(independent process)\*\*와 \*\*협력 프로세스(cooperating process)\*\*로 나뉩니다.

협력 프로세스는 데이터를 공유하거나 작업을 분담합니다.

**IPC의 두 가지 기본 모델**:

1. **공유 메모리 (Shared Memory)**\
   프로세스들이 공통 메모리 영역을 공유하여 직접 읽고 씀.\
   가장 빠른 방법이지만, **동기화(synchronization)** 문제(경쟁 조건, race condition)가 발생할 수 있음.
2. **메시지 전달 (Message Passing)**\
   `send()`와 `receive()` 시스템 호출을 통해 메시지를 주고받음.
   * **직접 통신**: 프로세스 이름을 직접 지정
   * **간접 통신**: 메일박스(mailbox) 또는 포트를 통해 전달

**메시지 전달 구현 방식**:

* 블로킹(blocking / synchronous): send/receive가 완료될 때까지 대기
* 논블로킹(non-blocking / asynchronous): 즉시 반환

#### 3.8 IPC 시스템 예시

* **POSIX 공유 메모리**: `shmget()`, `shmat()`, `shmdt()`
* **POSIX 메시지 큐**: `mq_open()`, `mq_send()`, `mq_receive()`
* **파이프 (Pipe)**: 단방향 통신 (익명 파이프 vs 이름 있는 파이프)
* **소켓 (Socket)**: 네트워크를 포함한 통신

#### 3.9 클라이언트-서버 시스템에서의 통신 (Communication in Client-Server Systems)

* **소켓 (Sockets)**: TCP/IP 기반
* **원격 프로시저 호출 (RPC)**: 네트워크를 통해 함수 호출처럼 사용
* **파이프 (Pipes)**: 로컬 클라이언트-서버
