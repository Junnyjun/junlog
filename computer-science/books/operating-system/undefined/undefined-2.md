# 운영체제 동작

**인터럽트**\
외부 장치나 타이머 등에서 발생해 CPU에 “즉시 처리”를 요구하는 신호.\
비동기적으로 발생하며, 디바이스 컨트롤러와 CPU 사이에 빠른 응답을 가능케 한다.

**예외**\
CPU가 명령어 실행 중 **동기적 오류**(0으로 나누기, 잘못된 명령어 등)를 감지할 때 발생하는 이벤트.\
명령어 실행 흐름 내에서 처리되어야 한다.

**트랩(Trap)**\
응용 프로그램이 **시스템콜**을 요청하기 위해 의도적으로 발생시키는 소프트웨어 인터럽트.\
예: 파일 열기, 프로세스 생성 등 커널 서비스를 호출할 때 사용.

#### 처리 흐름

* **발생**: 디바이스 컨트롤러가 IRQ(Line)를 활성화하거나 CPU가 예외를 감지
* **포착**: CPU가 실행 중인 명령어 사이클 후 인터럽트 요청을 검사
* **상태 저장**: 현재 레지스터 상태와 프로그램 카운터를 커널 스택 또는 PCB에 저장
* **디스패치**: 인터럽트 벡터 테이블에서 해당 서비스 루틴 주소를 찾아 분기
* **서비스**: ISR(Interrupt Service Routine)이 I/O 처리, 오류 복구, 타이머 갱신 등을 수행
* **상태 복구**: 저장된 레지스터와 PC를 복원하고 원래 실행 흐름으로 복귀

#### 우선순위와 중첩

* **우선순위 레벨**을 사용해 중요도가 높은 인터럽트를 먼저 처리
* ISR 도중 더 높은 우선순위 이벤트가 들어오면 **중첩 인터럽트**로 즉시 전환 가능
* 낮은 우선순위 인터럽트는 **마스킹**해 크리티컬 섹션을 보호

***

### 시스템콜 인터페이스와 구현

#### 역할과 분류

시스템콜은 응용 프로그램이 커널의 특권 기능을 호출하는 공식 인터페이스로, 다음과 같이 분류된다.

* **프로세스 제어**: `fork()`, `exec()`, `exit()`, `wait()`
* **파일 조작**: `open()`, `read()`, `write()`, `close()`
* **디바이스 제어**: `ioctl()`
* **정보 조회**: `getpid()`, `time()`
* **메모리 관리**: `brk()`, `mmap()`, `munmap()`

#### 구현 메커니즘

* 응용 프로그램은 C 라이브러리의 래퍼를 통해 시스템콜을 요청
* 소프트웨어 인터럽트(트랩) 명령어(`int`, `syscall`, `svc`)로 커널 모드 전환
* 커널은 시스템콜 번호와 인자를 읽어 `sys_call_table`에서 핸들러를 호출
* 서비스 수행 후 결과를 유저 모드로 반환하고 권한을 복원

#### 성능 최적화

* 자주 쓰이는 호출은 링 전환 없이 사용자 공간에서 처리하는 **vdso** 사용
* 배치 I/O(`readv`/`writev`)로 시스템콜 횟수 감소
* 시스템콜 오버헤드를 고려해 설계된 **심플 인터페이스** 유지

***

### 모드 전환(User Mode ↔ Kernel Mode)

#### 권한 레벨과 보호 링

* CPU는 서로 다른 권한을 가진 보호 링(Ring 0\~3)을 지원
* **Ring 0**: 커널 모드(특권 명령 실행 가능)
* **Ring 3**: 유저 모드(제한된 명령만 실행)

#### 전환 메커니즘

* 트랩이나 인터럽트 발생 시 CPU가 자동으로 Ring 3에서 Ring 0으로 권한 상승
* 커널 스택으로 스택 포인터 자동 전환
* 복귀 시 `iret` 또는 `sysret` 명령으로 유저 모드 복원

#### 보안 및 안정성

* 커널 진입 경로 최소화로 공격 표면 축소
* 사용자 제공 포인터 검증으로 커널 메모리 보호
* 스택 가드, DEP(Data Execution Prevention) 등 추가 방어

***

### 프로세스·스레드 관리와의 연계

#### 컨텍스트 스위칭

* 프로세스 전환 시 CPU 레지스터, 메모리 맵, PCB 상태를 저장·복원
* 캐시·TLB 플러시 오버헤드가 있음

#### 스케줄링 포인트

* 타이머 인터럽트, 시스템콜 진입/복귀, I/O 완료, 프로세스 종료 등에서 컨텍스트 스위칭 발생
