# 가상 메모리

#### 가상 메모리란?

가상 메모리는 실제 물리 메모리(RAM)와 독립된 논리적 주소 공간을 사용하는 기술입니다. 이 기술을 통해 개발자는 실제 메모리 크기보다 훨씬 큰 프로그램을 작성할 수 있습니다. 운영체제는 가상 주소(virtual address)를 실제 물리 주소(physical address)로 변환하며, 이 과정에서 \*\*페이징(paging)\*\*과 세그먼테이션(segmentation) 기법이 사용됩니다.

**가상 메모리의 장점**

* 더 큰 프로그램 실행: 실제 물리 메모리 크기에 제약을 받지 않고, 프로그램의 크기가 논리적 주소 공간만큼 커질 수 있습니다.
* 프로세스 생성 속도 증가: 전체 프로그램을 메모리에 적재할 필요 없이 일부만 적재하므로, 새로운 프로세스를 더 빠르게 만들 수 있습니다.
* 메모리 효율성 증가: 사용되지 않는 코드를 메모리에서 제거하고, 여러 프로세스가 라이브러리 같은 공유 파일을 공유할 수 있어 메모리 활용도가 높아집니다.
* I/O 작업 감소: 프로그램 실행에 필요한 최소한의 부분만 디스크에서 메모리로 적재하므로 I/O 오버헤드가 줄어듭니다.

***

#### 요구 페이징 (Demand Paging)

요구 페이징은 가상 메모리를 구현하는 가장 일반적인 기술입니다. 프로그램이 실행을 시작할 때, 전체를 메모리에 적재하는 것이 아니라 \*\*실제로 필요한 페이지(page)\*\*들만 적재하는 방식입니다.

**요구 페이징의 동작 과정**

1. 시작: 프로세스가 실행되면, 초기에는 필요한 최소한의 페이지들만 메모리에 적재됩니다.
2. 페이지 오류(Page Fault): 프로세스가 아직 메모리에 없는 페이지를 참조하면, 하드웨어는 페이지 테이블에서 해당 페이지가 없다는 것을 감지하고, \*\*페이지 오류(page fault)\*\*라는 트랩(trap)을 발생시킵니다.
3. 페이지 오류 처리:
   * 운영체제는 트랩을 받아 해당 페이지가 디스크의 어디에 저장되어 있는지 찾습니다.
   * 메모리에 빈 프레임이 있는지 확인하고, 있다면 그곳에 페이지를 적재합니다.
   * 페이지 테이블의 해당 항목을 '유효'로 업데이트하고, 물리적 주소를 기록합니다.
   * 페이지 오류를 유발했던 명령어를 다시 시작합니다.

**순수 요구 페이징**

순수 요구 페이징(pure demand paging)은 프로그램이 시작될 때 아무 페이지도 메모리에 적재하지 않는 극단적인 형태의 요구 페이징입니다. 첫 번째 명령어부터 페이지 오류가 발생하며, 필요한 페이지들을 하나씩 적재합니다.

**유효-무효 비트 (Valid-Invalid Bit)**

페이지 테이블의 각 항목에는 유효-무효(valid-invalid) 비트가 있습니다.

* 유효(valid): 페이지가 유효하며, 물리 메모리에 존재함을 나타냅니다.
* 무효(invalid): 페이지가 유효하지 않거나, 물리 메모리에 없음을 나타냅니다. 이 비트는 페이지에 접근할 때마다 하드웨어에 의해 검사됩니다.
