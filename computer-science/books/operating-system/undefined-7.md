# 가상 메모리

메모리는 현대 컴퓨터 시스템의 작동에 있어 가장 중요한 부분입니다. 메모리는 각자 고유의 주소를 가진 바이트들의 커다란 배열로 구성됩니다. CPU는 프로그램 카운터(program counter)의 값에 따라 메모리로부터 명령어를 가져와 실행합니다. 이 명령어들은 추가적인 메모리 주소로부터 데이터를 불러오거나 저장하는 동작을 유발할 수 있습니다.

**요구 페이징**

요구 페이징의 기본 메커니즘을 설명합니다. 요구 페이징은 프로그램 실행에 필요한 페이지들만 메모리에 적재하는 기술입니다. 즉, 페이지가 실제로 요청(요구)될 때만 디스크에서 메모리로 읽어 들입니다.

유효-무효 비트

페이지 테이블의 각 항목에는 유효-무효(valid-invalid) 비트가 있습니다.

* `valid` 비트: 해당 페이지가 합법적이며, 현재 주소 공간 내에 있고 물리 메모리에 있다는 것을 나타냅니다.
* `invalid` 비트: 다음의 경우 중 하나임을 나타냅니다.
  * 페이지가 해당 프로세스의 논리적 주소 공간에 속하지 않습니다.
  * 페이지가 논리적 주소 공간에는 속하지만 현재 물리 메모리에 없습니다(디스크에 있습니다).

프로세스가 시작될 때, 유효-무효 비트는 모든 페이지에 대해 `invalid`로 설정됩니다.

페이지 오류

프로세스가 `invalid`로 설정된 페이지를 참조하면, \*\*페이지 오류(page fault)\*\*라는 트랩(trap)이 발생합니다. 운영체제는 이 트랩을 처리하여 필요한 페이지를 메모리에 로드합니다.

페이지 오류 처리 단계:

1. 하드웨어는 페이지 테이블에서 유효-무효 비트가 `invalid`임을 확인하고, 운영체제로 트랩을 발생시킵니다.
2. 운영체제는 해당 주소 참조가 유효한지 확인합니다. 만약 유효하지 않은 주소라면, 프로세스를 비정상적으로 종료시킵니다.
3. 주소가 유효하다면, 운영체제는 해당 페이지가 디스크에 있는 위치를 찾습니다.
4. 페이지를 적재할 \*\*빈 물리 메모리 프레임(free frame)\*\*을 찾습니다.
5. 디스크에서 페이지를 빈 프레임으로 읽어 들입니다. 이 과정은 시간이 오래 걸리기 때문에, 해당 스레드는 대기 상태로 전환되고 CPU는 다른 스레드에게 할당됩니다.
6. 디스크 읽기가 완료되면, 페이지 테이블의 유효-무효 비트를 `valid`로 변경하고 해당 프레임 번호를 기록합니다.
7. 페이지 오류를 일으켰던 명령어를 다시 시작합니다.

***

#### 요구 페이징의 성능

요구 페이징의 성능은 \*\*유효 접근 시간(Effective Access Time, EAT)\*\*으로 측정할 수 있습니다. EAT는 페이지 오류율에 크게 좌우됩니다.

EAT=(1−p)×ma+p×페이지 오류 시간

* $$p$$: 페이지 오류(page fault) 발생 확률입니다.
* $$ma$$: 메모리 접근 시간.
* 페이지 오류 서비스 시간: 페이지를 디스크에서 메모리로 가져와서 명령어를 다시 시작하기까지 걸리는 시간입니다.

페이지 오류가 발생하면 디스크 접근이 필요하므로, 페이지 오류 서비스 시간은 일반적인 메모리 접근 시간보다 훨씬 깁니다. 따라서 EAT를 낮추기 위해서는 페이지 오류 확률 $$p$$가 매우 낮아야 합니다.

***

#### 순수 요구 페이징

순수 요구 페이징은 프로그램이 시작될 때 어떤 페이지도 메모리에 미리 적재하지 않는 방식입니다. 모든 페이지는 페이지 오류를 통해서만 메모리에 적재됩니다.
