# 효율성과 성능

파일 시스템의 \*\*효율성(Efficiency)\*\*은 디스크 공간을 얼마나 효과적으로 사용하는가에 달려있으며, \*\*성능(Performance)\*\*은 파일 접근 및 데이터 전송 속도에 달려있습니다. 이 두 가지 측면을 최적화하기 위해 운영체제는 다양한 기법을 사용합니다.

**1. 효율성 (Efficiency) 고려사항**

파일 시스템의 효율성은 주로 디스크 공간 낭비를 최소화하는 데 초점을 맞춥니다.

* 디스크 할당 단위: 디스크 공간을 섹터가 아닌 클러스터 또는 블록 단위로 할당하여 관리의 효율을 높입니다.
  * 문제: 블록 크기가 커지면 \*\*내부 단편화(Internal Fragmentation)\*\*가 증가하여 공간 낭비가 심해집니다. 블록 크기가 작으면 메타데이터(FCB, 포인터 등)가 많아져 오버헤드가 커집니다.
* 파일 할당 방식: 연속 할당은 외부 단편화가 심하고, 연결 할당은 직접 접근이 느리며, 색인 할당은 작은 파일에 대한 오버헤드가 있습니다. 효율적인 파일 시스템은 이들을 결합한 \*\*결합된 방식(Unix i-node)\*\*을 사용하여 다양한 파일 크기에 최적화합니다.
* 디렉터리 구현: 파일 이름과 FCB 포인터만 저장하는 방식이 FCB 전체를 저장하는 방식보다 디렉터리 공간을 효율적으로 사용합니다.

**2. 성능 (Performance) 개선 기법**

파일 시스템 성능은 디스크 I/O 횟수를 최소화하고 데이터 전송 속도를 극대화하는 것을 목표로 합니다.

* 디스크 캐싱 (Disk Caching) / 블록 캐시:
  * 원리: 디스크 블록의 복사본을 \*\*주 메모리(RAM)\*\*의 \*\*버퍼 캐시(Buffer Cache)\*\*에 보관합니다.
  * 효과: CPU가 데이터를 요청했을 때 블록이 캐시에 있으면(Cache Hit) 디스크 접근 없이 데이터를 즉시 제공하여 I/O 시간을 크게 단축합니다.
  * 쓰기 정책: 성능을 높이기 위해 쓰기 작업을 즉시 디스크에 반영하지 않고 캐시에 모아두었다가 한 번에 쓰는 지연된 쓰기(Delayed Write) 정책이 사용됩니다. (단, 시스템 충돌 시 데이터 손실 위험이 있음)
* 페이지 캐시 (Page Cache) 통합:
  * 원리: 운영체제는 파일 데이터에 대한 캐싱을 가상 메모리 시스템의 페이지 캐시와 통합하여 관리할 수 있습니다.
  * 효과: 메모리 매핑 파일(Memory-Mapped Files)과 일반 파일 I/O가 동일한 캐시 메커니즘을 공유하므로, 캐시 일관성 유지가 용이하고 중복된 캐싱이 방지되어 효율이 높아집니다.
* 블록 미리 읽기 (Read-Ahead):
  * 원리: 순차적인 파일 접근이 예상될 때, 현재 요청된 블록뿐만 아니라 다음 몇 개의 블록을 미리 예측하여 메모리로 읽어 들입니다.
  * 효과: 데이터가 미리 캐시에 준비되어 있어 실제 요청 시 대기 시간이 줄어듭니다.
* 디스크 레이아웃 최적화:
  * 원리: 디스크의 파일 데이터 블록과 메타데이터(FCB, 디렉터리)를 물리적으로 가까운 위치에 배치하여 탐색 시간(Seek Time)을 줄입니다.
  * 그룹화: Unix의 FFS(Fast File System)는 디스크를 \*\*실린더 그룹(Cylinder Group)\*\*으로 나누어 관련 메타데이터와 데이터를 같은 그룹 내에 배치하는 전략을 사용했습니다.

**3. 파일 시스템 튜닝 (Tuning)**

특정 사용 패턴에 맞게 파일 시스템 설정을 조정하여 성능을 최적화할 수 있습니다.

* 볼륨 크기: 파일 시스템을 구성할 때 볼륨(파티션)의 크기를 결정하여 메타데이터 관리를 최적화합니다.
* 메타데이터 빈도: i-node 영역과 같은 메타데이터 구조를 디스크에 얼마나 자주, 어디에 배치할지 결정하여 접근 속도를 조정합니다.
