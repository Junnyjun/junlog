# 빈 공간 관리

빈 공간 관리(Free-Space Management)는 파일에 할당되지 않은 디스크 블록들을 추적하고 관리하는 기능입니다. 이 기능은 파일 시스템의 할당자가 새로운 파일에 디스크 공간을 할당하거나, 파일 삭제 후 회수된 공간을 재사용할 때 필수적입니다.

**1. 빈 공간 관리 기법의 종류**

사용 가능한 디스크 블록을 추적하는 주요 기법은 다음과 같습니다.

* 비트 벡터 (Bit Vector):
  * 원리: $$ $n$ $$개의 디스크 블록이 있다면, $$ $n$ $$개의 비트로 구성된 \*\*비트 벡터(Bit Map)\*\*를 사용합니다. $$ $i$ $$번째 비트가 $\text{1}$이면 $$ $i$ $$번째 블록은 할당됨을 의미하고, $\text{0}$이면 $$ $i$ $$번째 블록은 빈 공간임을 의미합니다.
  * 장점: 구현이 간단하고, 연속된 빈 공간을 찾는 작업(연속 할당 지원)이 비트 벡터에서 연속된 $\text{0}$을 찾는 것으로 매우 효율적입니다.
  * 단점: 대규모 디스크의 경우 비트 벡터 자체가 너무 커져 메모리를 많이 차지합니다. (예: 1TB 디스크에 4KB 블록이라면 비트맵 크기는 약 32MB가 필요함.)
* 연결 리스트 (Linked List):
  * 원리: 모든 빈 디스크 블록들을 포인터로 연결한 연결 리스트를 구성합니다. 각 빈 블록은 다음 빈 블록의 주소를 저장합니다.
  * 구현: 볼륨 제어 블록(Volume Control Block, VCB)에 첫 번째 빈 블록의 주소를 저장합니다.
  * 장점: 디스크 공간을 효율적으로 사용합니다 (추가적인 관리 공간이 필요 없음).
  * 단점: 연속된 빈 공간을 찾는 것이 어렵고(연속 할당에 불리), 순차적으로 포인터를 따라가야 하므로 빈 공간 탐색 속도가 느립니다.
* 그룹화 (Grouping):
  * 원리: 연결 리스트의 변형으로, 첫 번째 빈 블록에 다음 $$ $n$ $$개의 빈 블록 주소를 저장합니다. 이 $$ $n$ $$개의 주소 중 마지막 주소는 다음 그룹 블록의 주소를 가리킵니다.
  * 장점: 한 번의 디스크 I/O로 여러 빈 블록 주소를 얻을 수 있어 탐색 속도를 높입니다.
* 계수 (Counting):
  * 원리: 빈 공간이 연속되어 있는 경우, 시작 블록 주소와 연속된 빈 블록의 개수(count) 쌍으로 관리합니다.
  * 장점: 연속된 빈 공간이 많은 파일 시스템(초기 포맷 상태 등)에서 빈 공간 정보를 매우 작게 유지할 수 있습니다.
  * 단점: 빈 공간이 자주 할당/해제되어 단편화가 심해지면 계수 목록의 길이가 급격히 증가합니다.

**2. 빈 공간 관리 정보의 위치**

빈 공간 관리에 필요한 메타데이터(비트 벡터, 연결 리스트의 시작 주소 등)를 어디에 저장할지가 중요합니다.

* 디스크 저장: 모든 빈 공간 관리 정보는 시스템 종료 후에도 유지되어야 하므로, 디스크의 특정 블록(예: 볼륨 제어 블록 근처)에 저장됩니다.
* 메모리 캐싱: 성능 향상을 위해 빈 공간 정보의 일부(예: 비트 벡터의 일부, 빈 블록의 주소 목록)는 \*\*메모리(RAM)\*\*에 캐시됩니다.

**3. 지속성 및 일관성 문제**

빈 공간 목록을 업데이트할 때 시스템 충돌(Crash)이 발생하면 파일 시스템의 일관성이 깨질 수 있습니다.

* 문제: 운영체제가 블록 $$ $B$ $$를 파일에 할당하기 위해 빈 공간 목록에서 $$ $B$ $$를 제거했다고 가정합시다. 만약 이 변경 사항이 디스크에 반영되기 전에 시스템이 다운되면, 재부팅 후 $$ $B$ $$는 할당되지 않은 빈 공간으로 인식되어 다른 파일에 \*\*이중 할당(double allocation)\*\*될 수 있습니다.
* 해결: 이러한 일관성 문제를 해결하기 위해 저널링(Journaling) 기법이나 쓰기 시 복사(Copy-on-Write) 방식을 사용하여 메타데이터 변경을 안전하게 처리해야 합니다.

