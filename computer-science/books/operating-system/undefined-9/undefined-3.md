# 파일 할당

파일 할당은 디스크의 블록들을 파일에 할당하는 방법입니다. 이는 디스크 공간을 효율적으로 사용하고, 파일 데이터에 대한 접근 속도를 높이는 것이 목표입니다.

**1. 연속 할당 (Contiguous Allocation)**

연속 할당은 파일의 각 블록이 디스크에서 물리적으로 연속된 일련의 블록에 할당되는 방식입니다.

![contiguous file allocation 이미지](https://encrypted-tbn0.gstatic.com/licensed-image?q=tbn:ANd9GcTxWHZF_1vZP3JTSkNMXK52M4Z8-tC2Em_OROiojGCikvuqxteljzNHui2fIC5JhYFP4sGEJoVlLnAAZbYJwuU1vMHFG917zpMu1dVde_G1sjIi-Vg)Shutterstock탐색

* 구현: 파일 제어 블록(FCB)에는 \*\*시작 블록 주소(Start Block Address)\*\*와 \*\*할당된 블록 수(Length)\*\*만 저장하면 됩니다.
* 장점:
  * 순차 접근 속도: 순차적인 접근이 매우 빠릅니다.
  * 직접 접근 속도: $$ $i$ $$번째 블록의 물리적 주소를 $$ $\text{시작 주소} + i$ $$로 쉽게 계산할 수 있어 직접 접근(Random Access)이 매우 빠릅니다.
  * I/O 효율: 한 번의 디스크 연산으로 여러 블록을 전송할 수 있어 효율적입니다.
* 단점:
  * 외부 단편화 (External Fragmentation): 파일 삭제 후 남은 공간이 너무 작아 새로운 파일을 할당하지 못하는 외부 단편화 문제가 발생합니다.
  * 파일 크기 증가의 어려움: 파일을 확장하려면 할당된 공간 바로 다음에 연속된 공간이 비어 있어야 합니다. 그렇지 않으면 전체 파일을 복사해야 합니다.

***

**2. 연결 할당 (Linked Allocation)**

연결 할당은 파일의 각 블록이 디스크의 어느 곳에든 분산되어 저장될 수 있으며, 각 블록에는 다음 블록의 주소를 가리키는 포인터가 포함됩니다.

* 구현: FCB에는 첫 번째 블록의 주소와 마지막 블록의 주소만 저장합니다.
* 장점:
  * 단편화 문제 해결: 외부 단편화가 발생하지 않습니다. 사용 가능한 모든 디스크 블록을 파일 할당에 사용할 수 있습니다.
  * 파일 크기 증가 용이: 파일은 빈 디스크 블록만 있다면 쉽게 확장될 수 있습니다.
* 단점:
  * 직접 접근 불가능: $$ $i$ $$번째 블록을 찾으려면 첫 블록부터 $$ $i$ $$개의 포인터를 순차적으로 따라가야 하므로 직접 접근(Random Access)이 매우 느립니다.
  * 공간 낭비: 각 블록의 작은 부분(보통 4바이트)이 다음 블록을 가리키는 포인터로 사용되어 내부 단편화를 유발합니다.
  * 신뢰성 문제: 블록 중 하나의 포인터가 손상되면 그 이후의 모든 블록에 접근할 수 없게 됩니다.

**파일 할당 테이블 (File-Allocation Table, FAT)**

연결 할당의 단점을 보완하기 위해 FAT 방식이 사용됩니다.

* 원리: 각 블록 내에 다음 블록의 포인터를 저장하는 대신, 모든 포인터들을 디스크의 \*\*특정 영역(FAT)\*\*에 모아서 저장합니다.
* 장점: 데이터 블록 전체를 파일 데이터 저장에 사용할 수 있어 공간 낭비가 줄어듭니다.
* 단점: $$ $i$ $$번째 블록에 접근하려면 여전히 FAT 테이블을 순차적으로 탐색해야 합니다. (FAT 테이블은 자주 캐시되므로 실제 성능 저하는 완화됩니다.)

***

**3. 색인 할당 (Indexed Allocation)**

색인 할당은 파일의 모든 디스크 블록 주소를 모아놓은 \*\*색인 블록(Index Block)\*\*을 사용하는 방식입니다. 각 파일은 전용 색인 블록을 가집니다.

* 구현: FCB에는 색인 블록의 주소만 저장합니다. 색인 블록에는 파일의 모든 데이터 블록 주소가 순서대로 저장됩니다.
* 장점:
  * 단편화 문제 해결: 연결 할당과 마찬가지로 외부 단편화가 발생하지 않습니다.
  * 직접 접근 가능: $$ $i$ $$번째 블록을 찾으려면 FCB에서 색인 블록을 찾아 $\text{색인 블록의 } i \text{번째 항목}$을 참조하면 되므로 직접 접근이 빠릅니다.
* 단점:
  * 오버헤드: 작은 파일이라도 적어도 두 번의 디스크 I/O (색인 블록 읽기 + 데이터 블록 읽기)가 필요합니다.
  * 색인 블록 크기 제한: 파일 크기가 매우 커지면 하나의 색인 블록으로는 모든 주소를 담을 수 없게 됩니다.

**대용량 파일 처리를 위한 색인 할당 (Handling Large Files)**

파일 크기 제한 문제를 해결하기 위해 다양한 색인 할당 구조가 사용됩니다.

* 연결된 색인 블록 (Linked Scheme): 파일이 커져 하나의 색인 블록이 가득 차면, 그 색인 블록의 마지막 엔트리가 다른 색인 블록을 가리키도록 연결합니다.
* 다단계 색인 (Multilevel Index):
  * 1단계: FCB가 첫 번째 색인 블록을 가리킵니다.
  * 2단계: 첫 번째 색인 블록 내의 엔트리가 데이터 블록 대신 두 번째 레벨의 색인 블록을 가리킵니다.
  * 이 구조는 파일 크기에 대한 이론적 한계를 크게 확장할 수 있으나, 데이터에 접근하기 위해 여러 레벨의 색인 블록을 거쳐야 하므로 I/O 횟수가 증가합니다.
* 결합된 기법 (Combined Scheme): Unix의 inode 구조처럼, 작거나 중간 크기의 파일에는 직접적인 포인터(Direct Pointer)를 사용하고, 큰 파일에는 단일 간접, 이중 간접, 삼중 간접 포인터(Indirect Pointer)를 결합하여 사용합니다.
