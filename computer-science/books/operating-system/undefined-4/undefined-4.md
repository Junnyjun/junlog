# 모니터

세마포는 강력한 동기화 도구이지만, 잘못 사용하면 복잡하고 오류가 발생하기 쉽습니다. 특히 `wait()`과 `signal()` 연산이 올바른 순서로 호출되지 않으면 데드락이나 상호 배제 위반과 같은 문제가 발생할 수 있습니다. 이러한 문제를 해결하고 동기화를 더 쉽게 관리하기 위해, 많은 프로그래밍 언어와 운영체제는 \*\*모니터(Monitors)\*\*라는 고수준의 동기화 구조를 제공합니다.

**기본 개념**

모니터는 프로그래밍 언어 수준에서 제공되는 추상화 개념으로, 동시 프로세스 간의 동기화를 처리하기 위한 메커니즘을 제공합니다. 모니터는 다음과 같은 요소를 포함하는 추상 데이터 타입(ADT)입니다.

1. 공유 데이터: 공유 자원을 나타내는 변수.
2. 프로시저(메서드): 공유 데이터에 대한 연산을 수행하는 함수.
3. 초기화 코드: 모니터의 공유 데이터를 초기화하는 코드.

모니터의 핵심 특징은 \*\*상호 배제(mutual exclusion)\*\*가 자동으로 보장된다는 것입니다. 즉, 주어진 시간에 오직 하나의 프로세스 또는 스레드만이 모니터 내부의 프로시저(메서드)를 활성화할 수 있습니다. 만약 다른 프로세스가 모니터 프로시저를 호출하려 하면, 현재 모니터가 사용 중이므로 대기 큐에 들어가게 됩니다.

**조건 변수 (Condition Variables)**

모니터는 상호 배제를 제공하지만, 프로세스가 어떤 조건이 만족될 때까지 기다려야 하는 상황(예: 버퍼가 가득 찼거나 비어 있는 경우)을 직접적으로 처리하지는 않습니다. 이를 위해 모니터는 \*\*조건 변수(condition variables)\*\*라는 특별한 동기화 메커니즘을 사용합니다.

조건 변수는 `x.wait()`과 `x.signal()`이라는 두 가지 연산을 통해서만 접근할 수 있습니다.

* `x.wait()`: 이 연산을 호출한 프로세스는 특정 조건이 만족될 때까지 일시 중단됩니다. 프로세스는 조건 변수 `x`와 관련된 대기 큐에 배치되고, 모니터 락을 해제하여 다른 프로세스가 모니터에 진입할 수 있도록 합니다.
* `x.signal()`: 이 연산은 `x`에 대해 대기 중인 프로세스가 없을 경우 아무런 효과가 없습니다. 대기 중인 프로세스가 있다면, `x.signal()`을 호출한 프로세스가 모니터를 떠나거나 다른 조건에서 대기하는 동안 대기 중인 프로세스 중 하나를 재개(resume)시킵니다.

signal() 연산의 의미:

x.signal()이 호출될 때 대기 중인 여러 프로세스 중에서 어떤 프로세스를 재개할지는 구현에 따라 다릅니다. 일반적으로 가장 오랫동안 대기한 프로세스를 재개합니다(FIFO). 중요한 점은 signal() 연산이 호출될 때 대기 중인 프로세스가 재개될지 여부를 결정하는 두 가지 구현 전략이 있다는 것입니다.

1. 시그널 및 대기 (Signal and Wait): `signal()`을 호출한 프로세스는 모니터 락을 해제하고 대기합니다. 즉시 실행될 수 있는 대기 중인 프로세스는 모니터를 획득하고 실행을 시작합니다.
2. 시그널 및 재개 (Signal and Continue): `signal()`을 호출한 프로세스가 실행을 계속합니다. 재개된 프로세스는 나중에 `signal()`을 호출한 프로세스가 모니터를 떠날 때까지 모니터 락을 다시 획득하고 실행될 준비가 될 때까지 기다려야 합니다.

대부분의 시스템은 시그널 및 대기 접근 방식을 사용합니다. 이는 설계 및 분석이 더 쉽기 때문입니다.

**모니터의 특징**

모니터는 임계 구역 문제에 대한 우아하고 효과적인 해결책을 제공합니다. 컴파일러가 모니터의 상호 배제 규칙을 자동으로 적용하므로 프로그래머는 락을 명시적으로 획득하거나 해제하는 데 신경 쓸 필요가 없습니다. 이는 동기화 코드를 더 간결하고 오류 발생 가능성이 적게 만듭니다.

모니터는 자바(Java), C#(C Sharp)와 같은 최신 프로그래밍 언어에서 `synchronized` 키워드나 락 메커니즘의 형태로 지원됩니다. 이러한 언어는 객체를 모니터로 사용하여 공유 데이터에 대한 동기화된 접근을 허용합니다.
