# 스레드와 동시성

#### 스레드란?

* \*\*스레드(thread)\*\*는 **CPU 사용의 기본 단위**이며, 다음 구성 요소로 이루어진다:
  * 고유 식별자 (Thread ID)
  * 프로그램 카운터 (PC, Program Counter)
  * 레지스터 집합
  * 스택
* 같은 프로세스 내의 다른 스레드들과 다음 자원을 공유한다:
  * 코드 섹션
  * 데이터 섹션
  * 운영체제 자원 (열린 파일, 신호 등)

> 전통적인 프로세스는 하나의 스레드만 가지며, **단일 실행 흐름**만 갖는다.\
> 멀티스레드를 지원하는 프로세스는 **동시에 여러 작업을 수행할 수 있다.**

> **\[도식 설명]**
>
> * 싱글스레드 프로세스는 코드/데이터/파일은 하나이고 실행 흐름도 하나
> * 멀티스레드 프로세스는 코드/데이터/파일은 공유하되, 각각의 스레드가 독립적인 PC, 레지스터, 스택을 갖고 있음

***

#### 도입 배경

**현대의 대부분의 애플리케이션은 멀티스레드 방식으로 구현된다.**\
각 스레드는 독립적인 작업을 수행하며, 전체 애플리케이션은 하나의 프로세스로 존재한다.

**예시**

* 이미지 썸네일 생성기\
  → 각 이미지별로 별도의 스레드에서 썸네일을 생성
* 웹 브라우저\
  → 한 스레드는 화면을 렌더링, 다른 스레드는 네트워크 통신
* 워드 프로세서\
  → 한 스레드는 그래픽 출력, 다른 스레드는 키 입력 처리, 또 다른 스레드는 맞춤법 검사

***

#### 멀티코어 환경 활용

멀티스레딩은 **멀티코어 시스템에서 병렬 처리 능력을 극대화**할 수 있다.\
→ 서로 독립적인 연산을 병렬로 실행 가능

**예: 웹서버**

* 수천 명의 클라이언트가 동시에 요청할 수 있는 환경
* 단일 스레드 프로세스 방식이면 **하나의 요청만 처리** 가능
* 과거 방식:
  * 요청이 들어올 때마다 새로운 프로세스를 생성하여 처리
  * 그러나 이는 **자원과 시간이 많이 소모**

→ 개선 방안:\
**멀티스레드 웹서버 구조**

* 메인 스레드는 클라이언트 요청을 대기
* 요청이 들어오면 **새로운 스레드**를 생성하여 요청 처리
* 메인 스레드는 대기 상태로 복귀하여 다음 요청 수신 준비

> **\[도식 설명]**
>
> 1. 클라이언트 요청 수신
> 2. 새로운 스레드를 생성하여 처리
> 3. 메인 스레드는 다시 대기

***

#### 운영체제 커널도 멀티스레드

* 리눅스 커널은 부팅 시 다수의 **커널 스레드**를 생성
* 각 커널 스레드는 디바이스 관리, 메모리 관리, 인터럽트 처리 등을 수행
* 예: `ps -ef` 명령으로 확인 시 PID=2인 `kthreadd`는 모든 커널 스레드의 부모

***

#### 멀티스레딩 활용 사례

* 정렬, 트리 탐색, 그래프 처리 등 기본 알고리즘
* 데이터 마이닝, 그래픽스, 인공지능처럼 **고성능 연산이 필요한 분야**에서 병렬 스레드를 활용하여 처리 속도 향상

***

#### 멀티스레딩의 이점 (4가지)

1. **응답성 (Responsiveness)**
   * 일부 작업이 차단되더라도 전체 애플리케이션은 계속 동작 가능
   * 예: 버튼 클릭 후 장시간 작업을 별도 스레드에서 수행 → UI는 계속 응답
2. **자원 공유 (Resource Sharing)**
   * 별도 프로세스 간에는 메모리/자원 공유가 복잡
   * 스레드는 기본적으로 자원을 공유하므로, **코드와 데이터 공유가 자연스럽고 효율적**
3. **경제성 (Economy)**
   * 프로세스를 만들기 위해 메모리/자원 할당이 필요하지만
   * 스레드는 동일 프로세스의 자원을 사용하므로 **생성 비용, 문맥 전환 비용 모두 낮음**
4. **확장성 (Scalability)**
   * 멀티프로세서 환경에서 각각의 스레드를 병렬 실행 가능
   * 하나의 프로세스만 사용 가능했던 싱글스레드 모델에 비해 병렬성 활용 극대화 가능
