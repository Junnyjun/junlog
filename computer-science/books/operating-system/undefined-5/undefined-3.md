# 대안적인 접근 방식

멀티코어 시스템이 증가하면서, 기존의 동기화 도구로는 해결하기 어려운 문제들이 발생하고 있습니다. 이로 인해 새로운 동기화 접근 방식들이 등장했습니다.

***

#### 트랜잭션 메모리 (Transactional Memory)

트랜잭션 메모리는 데이터베이스 이론에서 유래한 개념으로, 일련의 메모리 읽기-쓰기 연산을 \*\*원자적(atomic)\*\*으로 처리합니다.

* 동작 방식: 코드 블록을 `atomic { S }`와 같이 지정하면, 시스템이 해당 블록의 원자성을 보장합니다. 개발자는 락을 직접 관리하지 않아도 되므로 교착 상태와 같은 문제를 피할 수 있습니다.
* 구현 유형:
  * 소프트웨어 트랜잭션 메모리(STM): 컴파일러가 트랜잭션 블록 내에 코드를 삽입하여 구현합니다.
  *   하드웨어 트랜잭션 메모리(HTM): 하드웨어 캐시 계층을 활용하여 충돌을 관리하며, 오버헤드가 더 적습니다.

      이 방식은 기존 락 방식보다 높은 동시성과 확장성을 제공합니다.

***

#### OpenMP

OpenMP는 C, C++, FORTRAN 언어를 위한 컴파일러 지시어(directives) 및 API 세트입니다. 공유 메모리 환경에서 병렬 프로그래밍을 지원합니다.

* 동작 방식: `#pragma omp critical` 지시어를 사용해 특정 코드 영역을 \*\*임계 구역(critical section)\*\*으로 지정할 수 있습니다. OpenMP 런타임 라이브러리가 이 구역에 한 번에 하나의 스레드만 접근하도록 보장합니다.
* 장점: 표준 뮤텍스 락보다 사용하기 쉽지만, 개발자는 여전히 잠재적인 경쟁 조건을 파악하고 지시어를 적절히 사용해야 합니다.

***

#### 함수형 프로그래밍 언어 (Functional Programming Languages)

기존의 명령형(imperative) 언어와 달리, 함수형 프로그래밍 언어는 상태(state)를 관리하지 않습니다.

* 핵심 원칙: 변수가 한 번 정의되고 값이 할당되면, 그 값은 변경되지 않습니다(불변성).
* 장점: 상태의 불변성 덕분에 \*\*경쟁 조건(race condition)\*\*이나 교착 상태(deadlock) 같은 동시성 문제가 근본적으로 존재하지 않습니다. Erlang이나 Scala 같은 언어가 대표적인 예시입니다.
