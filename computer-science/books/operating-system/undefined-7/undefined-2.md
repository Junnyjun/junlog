# 페이지 테이블의 구조

대부분의 현대 컴퓨터 시스템은 매우 큰 논리적 주소 공간(232\~264 비트)을 지원하기 때문에, 페이지 테이블 자체의 크기가 매우 커질 수 있습니다. 이러한 문제를 해결하기 위해 페이지 테이블을 더 작은 조각으로 나누는 다양한 방법이 있습니다.

***

계층적 페이징 (Hierarchical Paging)

페이지 테이블이 너무 커지면, 페이지 테이블 자체를 페이징하는

2단계 페이징(two-level paging) 알고리즘을 사용할 수 있습니다. 예를 들어, 32비트 논리적 주소 공간과 4KB 페이지 크기를 가정할 때, 논리적 주소는 10비트의 페이지 번호, 10비트의 페이지 오프셋, 그리고 12비트의 오프셋으로 나뉩니다. 주소 변환은 바깥쪽 페이지 테이블부터 시작하여 안쪽으로 진행되므로, 이 방식을 \*\*전방 매핑 페이지 테이블(forward-mapped page table)\*\*이라고도 합니다.

하지만 64비트 논리적 주소 공간의 경우, 2단계 페이징만으로는 충분하지 않습니다. 바깥쪽 페이지 테이블의 크기가 너무 커지기 때문에,

3단계 또는 4단계 페이징과 같이 더 많은 계층을 사용해야 합니다.

***

해시 페이지 테이블 (Hashed Page Tables)

32비트보다 큰 주소 공간을 처리하기 위해 \*\*해시 페이지 테이블(hashed page table)\*\*을 사용할 수 있습니다. 가상 페이지 번호를 해시 함수에 넣어 해시 테이블의 인덱스를 얻는 방식입니다. 각 항목은 충돌을 처리하기 위해 연결 리스트를 포함합니다.

* 동작 방식: 가상 페이지 번호를 해시 테이블에 해시하면, 해시 테이블의 각 항목은 가상 페이지 번호, 페이지 프레임 값, 그리고 다음 항목에 대한 포인터로 구성된 연결 리스트를 가리킵니다. 해시된 위치에서 연결 리스트를 탐색하여 일치하는 가상 페이지 번호를 찾고, 해당 페이지 프레임을 사용하여 물리적 주소를 생성합니다.

이 방식의 변형으로 \*\*클러스터형 페이지 테이블(clustered page tables)\*\*이 있으며, 이는 하나의 해시 테이블 항목이 여러 페이지를 참조합니다. 이는 메모리 참조가 불연속적이고 흩어져 있는 \*\*희소 주소 공간(sparse address spaces)\*\*에 특히 유용합니다.

***

역 페이지 테이블 (Inverted Page Tables)

\*\*역 페이지 테이블(inverted page table)\*\*은 시스템의 실제 물리적 페이지(프레임) 수만큼만 항목을 가집니다. 각 항목은 해당 물리적 메모리 위치에 저장된 페이지의 가상 주소와 그 페이지를 소유한 프로세스에 대한 정보를 포함합니다.

* 장점: 페이지 테이블을 저장하는 데 필요한 메모리 양을 줄일 수 있습니다.
* 단점: 페이지 참조가 발생했을 때 테이블을 검색하는 데 시간이 오래 걸릴 수 있습니다. 이 문제를 해결하기 위해 해시 테이블이 사용됩니다.

***

Oracle SPARC Solaris

64비트 시스템에서 가상 메모리를 효율적으로 관리하기 위해 Solaris는 해시 페이지 테이블을 사용합니다. 주소 변환 속도를 높이기 위해 TLB(translation look-aside buffer)가 사용됩니다. TLB 미스가 발생하면 하드웨어가 TSB(translation storage buffer)를 검색하고, 여기서도 찾지 못하면 커널이 해시 테이블을 검색합니다. 커널은 해당 항목을 TSB에 생성하고, 하드웨어는 이를 TLB에 로드하여 주소 변환을 완료합니다.
