# 페이지 교체 알고리즘

요구 페이징(demand paging) 환경에서 메모리에 빈 프레임이 없을 때, 페이지 교체 알고리즘을 사용하여 메모리에서 희생자(victim) 페이지를 선택해야 합니다.

**기본 원리 (Basic Goal)**

페이지 교체의 기본 목표는 페이지 부재율(page-fault rate)을 최소화하는 것입니다.

페이지 교체 과정:

1. 운영체제는 원하는 페이지가 디스크에 있는 위치를 결정합니다.
2. 빈 프레임을 찾습니다.
3. 빈 프레임이 없다면, 페이지 교체 알고리즘을 사용하여 희생자 페이지를 선택합니다.
4. 희생자 페이지를 디스크로 스왑 아웃(페이지 아웃)합니다. 이때, 페이지 테이블을 업데이트하고, \*\*수정 비트(modify bit)\*\*를 확인하여, 페이지가 수정되지 않았다면 디스크에 쓸 필요 없이 그냥 덮어쓸 수 있습니다.
5. 원하는 페이지를 새로 확보된 프레임에 읽어 들이고(페이지 인), 페이지 테이블을 업데이트합니다.
6. 페이지 오류를 일으킨 명령어를 다시 시작합니다.

**프레임 할당 (Frame Allocation)**

운영체제는 각 프로세스에 할당할 메모리 프레임의 수를 결정해야 합니다.

* 최소 프레임 수: 각 프로세스는 명령어 실행에 필요한 최소한의 페이지를 가져야 합니다. 이 최소 수는 아키텍처에 따라 다르며, 프로세스가 이보다 적은 프레임을 가질 경우 문맥 교환을 하더라도 실행할 수 없습니다.
* 최대 프레임 수: 물리 메모리의 총 프레임 수입니다.

프레임 할당 방식:

1. 고정 할당(Fixed Allocation):
   * 균등 할당(Equal allocation): 모든 프로세스에 동일한 수의 프레임을 할당합니다.
   * 비례 할당(Proportional allocation): 각 프로세스의 크기에 비례하여 프레임을 할당합니다.
2. 우선순위 할당(Priority Allocation): 우선순위가 높은 프로세스는 더 많은 프레임을 할당받습니다.

**전역 대 지역 교체 (Global Versus Local Replacement)**

페이지 교체 방식은 희생자 프레임을 선택하는 범위에 따라 나뉩니다.

* 지역 교체(Local Replacement): 프로세스가 자신이 할당받은 프레임 내에서만 희생자 페이지를 선택합니다. 이는 한 프로세스의 페이지 부재율이 다른 프로세스의 동작에 영향을 받지 않도록 합니다.
* 전역 교체(Global Replacement): 프로세스가 다른 프로세스에게 할당된 프레임을 포함하여 모든 프레임 중에서 희생자 페이지를 선택할 수 있습니다.
  * 장점: 시스템 전체의 스루풋(throughput)이 높아지고 성능이 향상될 수 있습니다.
  * 단점: 한 프로세스의 동작이 다른 프로세스의 성능에 영향을 미쳐 예측 불가능성을 증가시킵니다. 대부분의 운영체제는 전역 교체를 사용합니다.

**페이지 교체 알고리즘의 종류**

1. 최적 알고리즘 (Optimal Algorithm, OPT):
   * 원리: 앞으로 가장 오랫동안 사용되지 않을 페이지를 교체합니다.
   * 실현 가능성: 미래를 예측해야 하므로 실현 불가능합니다. 그러나 다른 알고리즘의 성능 평가를 위한 최소 페이지 부재율 기준으로 사용됩니다.
2. FIFO (First-In, First-Out) 알고리즘:
   * 원리: 가장 오래 전에 메모리에 들어온 페이지를 교체합니다. 페이지가 메모리에 로드된 시간을 기준으로 교체합니다.
   * 단점: 가장 오래된 페이지가 가장 많이 사용되는 페이지일 수도 있습니다.
   * 벨라디의 이상(Belady's Anomaly): 프레임의 수를 늘려도 페이지 부재율이 감소하지 않고 오히려 증가하는 현상이 발생할 수 있습니다.
3. LRU (Least Recently Used) 알고리즘:
   * 원리: 가장 오랫동안 사용되지 않은 페이지를 교체합니다. 과거가 미래를 예측하는 좋은 지표가 된다는 가정 하에 OPT의 실용적인 근사치로 간주됩니다.
   * 구현 방법:
     * 카운터: 각 페이지 항목에 시간 카운터를 추가하여, 매번 참조될 때마다 카운터 값을 기록하고 가장 작은 값의 페이지를 교체합니다.
     * 스택: 페이지 참조 시 해당 페이지를 스택의 맨 위로 이동시키고, 스택의 맨 아래에 있는 페이지(가장 오랫동안 사용되지 않은 페이지)를 교체합니다.
4. LRU 근사 알고리즘 (LRU Approximation Algorithms): LRU의 구현 비용이 비싸므로, 하드웨어 지원을 통해 효율적으로 구현할 수 있는 근사 알고리즘이 사용됩니다.
   * 참조 비트 알고리즘 (Additional-Reference-Bits Algorithm): 각 페이지에 \*\*참조 비트(reference bit)\*\*를 두고, 주기적으로 시프트 레지스터에 기록하여 페이지 사용 기록을 추적합니다.
   * 이차 기회 알고리즘 (Second-Chance Algorithm): FIFO 알고리즘에 참조 비트를 추가합니다. 가장 오래된 페이지의 참조 비트가 1이면, 그 페이지에 두 번째 기회를 주고 참조 비트를 0으로 바꾼 뒤 다음 페이지를 검사합니다.
   * 개선된 이차 기회 알고리즘 (Enhanced Second-Chance Algorithm): 참조 비트와 \*\*수정 비트(modify bit)\*\*를 결합하여 네 가지 클래스(0,0: 최근에 사용되지 않았고 수정되지 않음 \~ 1,1: 최근에 사용되었고 수정됨)로 분류하고, 가장 낮은 클래스(0,0)를 우선적으로 교체합니다.
5. 계수 기반 알고리즘 (Counting-Based Algorithms):
   * LFU (Least Frequently Used): 참조 횟수가 가장 적은 페이지를 교체합니다.
   * MFU (Most Frequently Used): 참조 횟수가 가장 많은 페이지를 교체합니다. 이는 참조 횟수가 적은 페이지가 메모리에 들어온 지 얼마 되지 않았을 것이라는 가정에 기반합니다.

**페이지 버퍼링 (Page Buffering)**

운영체제는 페이지 교체의 성능을 향상시키기 위해 페이지 버퍼링을 사용합니다.

* 자유 프레임 리스트: 교체된 프레임들을 디스크로 쓰기 전에 \*\*자유 프레임 리스트(free-frame list)\*\*에 보관하여, 페이지 오류 발생 시 디스크 접근 없이 빠르게 재사용할 수 있습니다.
* 수정된 페이지 리스트: 수정된 페이지(dirty page)들은 디스크로 쓰기 위해 별도의 수정된 페이지 리스트에 보관됩니다. 이는 I/O를 배치 처리(batching)하여 효율성을 높입니다.
