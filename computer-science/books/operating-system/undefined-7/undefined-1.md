# 페이징

#### 9.3 페이징 (Paging)

페이징은 프로세스의 물리적 주소 공간이 연속적일 필요가 없는 메모리 관리 기법입니다. 페이징은 연속 메모리 할당의 문제점인 외부 단편화와 압축 필요성을 해결합니다.

**기본 방법 (Basic Method)**

페이징을 구현하는 기본적인 방법은 물리 메모리를 \*\*프레임(frames)\*\*이라고 하는 고정된 크기의 블록으로 나누고, 논리적 메모리를 동일한 크기의 \*\*페이지(pages)\*\*로 나누는 것입니다. 프로세스가 실행될 때, 해당 페이지들은 보조 저장 장치(secondary storage)에서 사용 가능한 메모리 프레임으로 로드됩니다.

CPU가 생성하는 모든 주소는 \*\*페이지 번호(p)\*\*와 \*\*페이지 오프셋(d)\*\*의 두 부분으로 나뉩니다. 페이지 번호는 페이지 테이블의 인덱스로 사용되며, 페이지 테이블은 물리 메모리의 각 프레임에 대한 기본 주소를 포함합니다. 페이지 오프셋은 해당 프레임 내의 특정 위치입니다.

* 논리적 주소 변환 과정:
  1. CPU는 논리적 주소에서 페이지 번호(p)를 추출합니다.
  2. 페이지 번호(p)를 페이지 테이블의 인덱스로 사용하여, 해당하는 프레임 번호(f)를 얻습니다.
  3. 논리적 주소의 페이지 번호(p)를 프레임 번호(f)로 교체합니다.
  4. 오프셋(d)은 그대로 유지되어, 프레임 번호와 오프셋이 결합된 최종적인 물리적 주소가 생성됩니다.

페이지 크기는 하드웨어에 의해 결정되며, 일반적으로 2의 거듭제곱으로, 4KB에서 1GB까지 다양합니다.

**하드웨어 지원 (Hardware Support)**

페이지 테이블이 메인 메모리에 저장될 경우, 메모리 접근 시간이 느려질 수 있습니다. 이 문제를 해결하기 위해, \*\*TLB (translation look-aside buffer)\*\*라고 하는 특별한 하드웨어 캐시가 사용됩니다. TLB는 자주 사용되는 페이지 테이블 항목들을 저장하는 작고 빠른 연관 메모리입니다.

* TLB 작동 방식:
  1. CPU가 논리적 주소를 생성하면, MMU는 먼저 TLB에서 해당 페이지 번호를 찾습니다.
  2. 페이지 번호가 TLB에 있으면 (TLB hit), 프레임 번호가 즉시 사용되어 메모리에 접근합니다.
  3. 페이지 번호가 TLB에 없으면 (TLB miss), 페이지 테이블에 접근하여 프레임 번호를 얻고, 이를 사용하여 메모리에 접근합니다. 이후 TLB에 이 항목을 추가합니다.

**보호 (Protection)**

페이징 환경에서 메모리 보호는 각 페이지와 연관된 보호 비트(protection bit)를 통해 이루어집니다. 일반적으로 이 비트들은 페이지 테이블에 저장되며, 페이지를 읽기-쓰기(read-write) 또는 읽기 전용(read-only)으로 정의합니다. 메모리에 대한 모든 접근은 페이지 테이블을 거치므로, 물리적 주소를 계산하는 동시에 보호 비트를 확인하여 권한 위반을 방지할 수 있습니다.

페이지 테이블의 각 항목에는 유효-무효(valid-invalid) 비트가 추가로 붙습니다. 이 비트가 `valid`로 설정되면 해당 페이지가 프로세스의 논리적 주소 공간에 있고 유효하다는 것을 의미하며, `invalid`로 설정되면 페이지가 논리적 주소 공간에 없거나 물리 메모리에 없음을 나타냅니다.

**페이지 공유 (Shared Pages)**

페이징의 또 다른 장점은 여러 프로세스가 공통 코드를 공유할 수 있다는 것입니다. 재진입 가능 코드(reentrant code)는 실행 중에 변경되지 않는 코드로, 여러 프로세스가 동시에 실행할 수 있습니다. 운영체제는 재진입 가능 코드의 한 사본만 물리 메모리에 보관하고, 각 사용자 프로세스의 페이지 테이블은 동일한 물리적 메모리 프레임을 가리키도록 매핑합니다. 이를 통해 메모리 사용량을 크게 절약할 수 있습니다. 동적 연결 라이브러리(dynamically linked libraries, DLLs)는 일반적으로 공유 페이지를 사용하여 구현됩니다.
