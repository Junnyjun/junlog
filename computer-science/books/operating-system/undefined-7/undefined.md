# 연속 메모리 할당

메인 메모리는 운영체제와 다양한 사용자 프로세스를 수용해야 하므로, 메모리를 가장 효율적인 방식으로 할당해야 합니다. 연속 메모리 할당(contiguous memory allocation)은 각 프로세스가 다른 프로세스를 담는 구획에 인접한 하나의 메모리 구획에 포함되도록 요구하는 초기 방식 중 하나입니다.

***

**메모리 보호 (Memory Protection)**

프로세스가 자신이 소유하지 않은 메모리에 접근하는 것을 막기 위해, \*\*재배치 레지스터(relocation register)\*\*와 \*\*한계 레지스터(limit register)\*\*를 결합하여 사용합니다.

* 재배치 레지스터: 가장 작은 물리적 주소 값을 가집니다.
* 한계 레지스터: 논리적 주소의 범위를 가집니다.

CPU 스케줄러가 프로세스를 실행하도록 선택하면, 디스패처는 문맥 교환(context switch)의 일부로 이 두 레지스터에 올바른 값을 로드합니다. CPU에 의해 생성된 모든 주소는 이 레지스터들과 비교되므로, 실행 중인 프로세스가 운영체제나 다른 사용자의 프로그램과 데이터를 수정하는 것을 막을 수 있습니다.

***

**메모리 할당 (Memory Allocation)**

메모리 할당의 가장 간단한 방법 중 하나는 메모리를 크기가 다양한 파티션으로 나누고 각 파티션에 하나의 프로세스를 할당하는 것입니다. 이러한 가변 파티션(variable partition) 방식에서 운영체제는 사용 가능한 메모리 공간(홀, hole)의 목록을 관리합니다.

프로세스가 도착하여 메모리를 필요로 할 때, 시스템은 프로세스가 들어갈 만큼 충분히 큰 홀을 찾습니다. 만약 홀이 너무 크면 두 부분으로 나뉘는데, 한 부분은 프로세스에 할당되고 다른 부분은 홀의 목록으로 반환됩니다. 프로세스가 종료되면 자신이 점유했던 메모리를 해제하고, 이 공간은 인접한 홀들과 병합되어 더 큰 홀을 형성할 수 있습니다.

동적 저장장치 할당 문제(dynamic storage-allocation problem)를 해결하기 위해 일반적으로 세 가지 전략이 사용됩니다.

* 최초 적합(First fit): 메모리 목록의 처음부터 탐색하여, 크기가 충분한 첫 번째 홀을 할당합니다.
* 최적 적합(Best fit): 모든 홀을 탐색하여, 크기가 충분한 홀 중 가장 작은 것을 할당합니다.
* 최악 적합(Worst fit): 모든 홀을 탐색하여, 가장 큰 홀을 할당합니다.

시뮬레이션 결과에 따르면, 최초 적합과 최적 적합은 성능 면에서 최악 적합보다 우수합니다.

***

**단편화 (Fragmentation)**

최초 적합과 최적 적합 할당 전략은 모두 외부 단편화(external fragmentation) 문제가 발생할 수 있습니다. 외부 단편화는 사용 가능한 총 메모리 공간은 충분하지만, 그 공간이 프로세스에 할당될 만큼 충분히 크고 연속적인 홀로 존재하지 않을 때 발생합니다.

메모리 단편화는 \*\*내부 단편화(internal fragmentation)\*\*로도 발생할 수 있습니다. 이는 할당된 메모리가 요청된 메모리보다 약간 더 클 때 발생하며, 사용되지 않는 메모리가 파티션 내부에 남게 되는 것입니다.

외부 단편화 문제에 대한 한 가지 해결책은 \*\*압축(compaction)\*\*입니다. 메모리 내용을 재배치하여 모든 자유 메모리를 하나의 큰 연속적인 블록으로 만드는 것입니다. 그러나 압축은 동적 재배치(dynamic relocation)가 가능한 경우에만 가능하며, 비용이 많이 들 수 있습니다.

또 다른 해결책은 프로세스의 논리적 주소 공간을 비연속적으로 허용하는 것입니다. 이것이 페이징(paging) 방식이며, 다음 섹션에서 더 자세히 다룹니다.
