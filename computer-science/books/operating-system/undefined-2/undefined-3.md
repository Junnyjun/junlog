# 프로세스 통신

#### 독립 프로세스 vs 협력 프로세스

운영체제에서 동시에 실행되는 프로세스는\
**독립 프로세스(independent process)** 혹은\
\*\*협력 프로세스(cooperating process)\*\*일 수 있다.

* **독립 프로세스**: 시스템 내 다른 프로세스와 **데이터를 공유하지 않음**
* **협력 프로세스**: 다른 프로세스에 영향을 주거나, 영향을 받을 수 있음

데이터를 공유하는 모든 프로세스는 **협력 프로세스**다.

***

#### 협력 프로세스를 지원하는 이유

1. **정보 공유 (Information sharing)**
   * 여러 애플리케이션이 동일 데이터를 사용하고자 할 수 있음
   * 예: 복사-붙여넣기
2. **계산 속도 향상 (Computation speedup)**
   * 작업을 병렬로 수행하려면 서브태스크로 나눠야 함
   * 전제 조건: 멀티코어 환경
3. **모듈화 (Modularity)**
   * 기능을 나누어 프로세스 또는 스레드로 분리함 (2장에서 다룸)

***

#### IPC: Interprocess Communication

협력 프로세스는 **데이터 교환을 위한 IPC 메커니즘**이 필요하다.\
IPC에는 두 가지 기본 모델이 있다:

1. **공유 메모리(shared memory)**
   * 프로세스 간에 공유되는 메모리 영역을 생성
   * 해당 영역에 읽기/쓰기 방식으로 정보 교환
2. **메시지 전달(message passing)**
   * 메시지를 통해 데이터 송수신
   * 직접 메모리 접근은 없음

***

#### Chrome 브라우저의 멀티프로세스 구조 예시

* Chrome은 **웹 앱의 오류로 전체 브라우저가 죽는 현상**을 방지하기 위해\
  멀티프로세스 구조를 채택
* 세 종류의 프로세스 존재:
  1. **Browser process**: UI, 디스크/네트워크 I/O 관리 (1개만 존재)
  2. **Renderer process**: 각 탭마다 생성, HTML/JS 처리
  3. **Plugin process**: Flash, QuickTime 등 플러그인별 생성
* 장점:
  * 탭별로 분리되어 있어 **하나의 탭 오류가 전체 브라우저에 영향 없음**
  * Renderer는 샌드박스에서 실행 → 보안성 향상

***

#### 모델 비교

| 모델     | 특징                         |
| ------ | -------------------------- |
| 공유 메모리 | 속도 빠름, 시스템 콜 적음, 메모리 직접 접근 |
| 메시지 전달 | 구현 단순, 커널 개입 많음, 분산 환경 적합  |

* 메시지 전달은 소량 데이터, 분산 시스템에서 유리
* 공유 메모리는 고속 전송에 유리하나, 동기화 이슈 존재

***

#### 공유 메모리 기반 IPC

공유 메모리 사용을 위한 조건:

* 한 프로세스가 공유 메모리 영역을 생성
* 다른 프로세스는 해당 영역을 주소 공간에 연결
* 프로세스 간 합의 하에, **메모리 접근 제한을 해제**함

운영체제는 어떤 위치, 어떤 포맷으로 데이터를 저장할지는 관여하지 않음\
→ 프로세스가 스스로 관리해야 하며, **동기화도 직접 책임져야 함**

***

#### Producer–Consumer 문제

* **Producer**: 데이터를 생성
* **Consumer**: 데이터를 소비
* 공유 버퍼를 통해 데이터를 전달

**예시:**

* 컴파일러 → 어셈블러 → 링커
* 웹 서버 → 클라이언트 웹 브라우저

**공유 버퍼 형태**

* **Unbounded buffer**: 제한 없음
* **Bounded buffer**: 고정 크기 → 꽉 차면 producer 대기, 비면 consumer 대기

**Bounded buffer 예시**

```c
#define BUFFER_SIZE 10
item buffer[BUFFER_SIZE];
int in = 0, out = 0;
```

* 버퍼는 원형 배열
* `in`은 다음 쓸 위치, `out`은 다음 읽을 위치
* `in == out`: 버퍼 비어있음
* `(in + 1) % BUFFER_SIZE == out`: 버퍼 가득 참

***

#### Producer 코드 (공유 메모리 사용)

```c
item next_produced;
while (true) {
  // 항목 생성
  while ((in + 1) % BUFFER_SIZE == out);  // 대기
  buffer[in] = next_produced;
  in = (in + 1) % BUFFER_SIZE;
}
```

#### Consumer 코드 (공유 메모리 사용)

```c
item next_consumed;
while (true) {
  while (in == out);  // 대기
  next_consumed = buffer[out];
  out = (out + 1) % BUFFER_SIZE;
  // 항목 소비
}
```

***

#### 메시지 전달 기반 IPC

메시지 전달은 **주소 공간 공유 없이 통신과 동기화 수행**\
→ 분산 시스템에서 특히 유용

**기본 연산**

* `send(message)`
* `receive(message)`

**메시지 크기**

* 고정 크기: 구현 단순, 프로그래밍 복잡
* 가변 크기: 구현 복잡, 프로그래밍 단순

***

#### 통신 연결 설정

1. **직접 통신 (Direct communication)**
   * `send(P, msg)`, `receive(Q, msg)`
   * 양 프로세스는 서로 이름을 알아야 함
   * 통신 링크는 **1:1**, 쌍방향 또는 단방향
2. **간접 통신 (Indirect communication)**
   * 메시지는 \*\*메일박스(mailbox)\*\*에 저장
   * `send(mailbox, msg)`, `receive(mailbox, msg)`
   * 하나의 메일박스를 여러 프로세스가 공유 가능

**동시 수신 문제**

* P1 → 메일박스 A로 전송
* P2, P3가 A로부터 `receive()` 호출 시\
  → 시스템이 라운드 로빈 등 방식으로 결정

***

#### 메일박스 소유권

1. **프로세스 소유**
   * 해당 프로세스만 수신 가능
   * 종료 시 메일박스도 제거됨
2. **운영체제 소유**
   * 독립적 존재
   * 생성, 삭제, 권한 이전 가능

***

#### 동기화 방식

| 방식                  | 설명                   |
| ------------------- | -------------------- |
| Blocking send       | 송신자는 메시지가 수신될 때까지 대기 |
| Nonblocking send    | 송신자는 송신 후 바로 계속      |
| Blocking receive    | 수신자는 메시지 도착 전까지 대기   |
| Nonblocking receive | 도착한 메시지 없으면 null 반환  |

* 양쪽이 블로킹이면 **rendezvous (동시 만남)** 발생
* 이 경우 producer–consumer 문제 해결이 쉬움

***

#### 메시지 버퍼링

메시지는 임시 큐에 저장됨\
→ 큐의 크기에 따라 다음 세 가지 형태 존재:

1. **0 용량 (Zero capacity)**
   * 큐 없음, 송신자는 수신자가 받을 때까지 대기
2. **유한 용량 (Bounded capacity)**
   * 크기 n, 꽉 차면 송신자는 대기
3. **무한 용량 (Unbounded capacity)**
   * 이론적으로 무제한
   * 송신자는 절대 대기하지 않음
