# 운영체제 구조

이 장에서는 운영체제가 사용자와 응용 프로그램에게 제공하는 **서비스의 종류**, **사용자와의 인터페이스 방식**, **시스템 호출**의 역할과 구현, **시스템 프로그램**, **링커와 로더**, **운영체제 설계 원칙**, **다양한 운영체제 구조**, **부팅 과정**, **디버깅 방법** 등을 매우 자세히 다룹니다.

**Chapter Objectives** (원문 그대로)

* 운영체제가 제공하는 다양한 서비스를 식별한다.
* 시스템 호출을 통해 운영체제 서비스를 어떻게 요청하고 제공하는지 설명한다.
* 모놀리식, 계층형, 마이크로커널, 모듈형, 하이브리드 구조를 비교한다.
* 운영체제 부팅 과정과 디버깅 도구를 설명한다.

### 2.1 운영체제 서비스 (Operating-System Services)

운영체제는 사용자와 프로그램이 컴퓨터를 편리하고 효율적으로 사용할 수 있도록 많은 서비스를 제공합니다. 이 서비스들은 크게 **사용자에게 직접 도움이 되는 서비스**와 **시스템 자체의 효율적 운영을 위한 서비스**로 나눌 수 있습니다.

#### 사용자에게 직접 도움이 되는 서비스

1. **사용자 인터페이스 (User Interface)**\
   거의 모든 운영체제는 사용자와 상호작용할 수 있는 인터페이스를 제공합니다.
   * **명령줄 인터페이스 (Command-Line Interface, CLI)**: 사용자가 텍스트 명령어를 직접 입력하는 방식. UNIX/Linux의 shell (bash, zsh, csh 등), Windows의 cmd.exe와 PowerShell이 대표적입니다.
   * **그래픽 사용자 인터페이스 (Graphical User Interface, GUI)**: 마우스 클릭, 아이콘, 창, 메뉴, 드래그 등을 사용하는 시각적 인터페이스. Microsoft Windows, Apple macOS, Linux의 GNOME, KDE 등이 이에 속합니다.
   * **터치스크린 인터페이스**: 스마트폰과 태블릿에서 주로 사용되며, 스와이프, 핀치, 멀티터치 제스처를 중심으로 합니다 (Android, iOS).
   * **음성 기반 인터페이스**: 최근 급증하고 있는 형태로, Apple의 Siri, Google Assistant, Amazon Alexa 등이 대표적입니다.
2. **프로그램 실행 (Program Execution)**\
   운영체제는 사용자가 디스크에 저장된 프로그램을 실행할 수 있도록 합니다. 프로그램을 메모리에 적재하고, CPU를 할당하며, 프로그램이 정상적으로 종료되거나 오류로 종료될 때까지 자원을 관리하고, 종료 시 모든 자원을 회수합니다.
3. **입출력 연산 (I/O Operations)**\
   프로그램은 파일, 네트워크, 프린터, 키보드, 마우스, 디스플레이 등 다양한 I/O 장치를 사용해야 합니다.\
   운영체제는 사용자 프로그램이 직접 하드웨어 장치에 접근하지 못하게 하고, 대신 **디바이스 드라이버**와 시스템 호출을 통해 안전하고 일관된 방식으로 I/O 작업을 수행하도록 합니다.
4. **파일 시스템 조작 (File-System Manipulation)**\
   파일과 디렉터리의 생성, 삭제, 읽기, 쓰기, 이름 변경, 검색, 이동, 파일 속성(권한, 소유자, 크기, 생성일시 등) 조회와 변경, 디렉터리 탐색, 백업 등 파일 시스템 관련 모든 작업을 지원합니다. 운영체제는 파일 시스템의 일관성과 보호를 책임집니다.
5. **통신 (Communication)**\
   동일 컴퓨터 내 프로세스 간 통신(공유 메모리 또는 메시지 전달)과 다른 컴퓨터 간 통신(네트워크 소켓, 클라이언트-서버 모델, P2P 등)을 지원합니다.
6. **오류 탐지 (Error Detection)**\
   CPU, 메모리, I/O 장치에서 발생하는 하드웨어 오류와 소프트웨어 오류(0으로 나누기, 잘못된 메모리 접근, 파일 접근 권한 위반 등)를 지속적으로 감지하고, 사용자나 다른 프로그램에 알리거나 자동 복구를 시도합니다.

#### 시스템 효율적 운영을 위한 서비스

7. **자원 할당 (Resource Allocation)**\
   다중 사용자·다중 작업 환경에서 CPU 시간, 메모리 공간, 파일 저장 공간, I/O 장치 등을 여러 프로세스에 효율적이고 공정하게 분배합니다. 일부 자원은 특수 할당 알고리즘이 필요합니다.
8. **회계 (Accounting)**\
   사용자별·프로세스별로 CPU 시간, 메모리 사용량, I/O 사용량 등을 추적하여 과금, 성능 분석, 보안 감사에 활용합니다.
9. **보호와 보안 (Protection and Security)**\
   프로세스가 다른 프로세스의 메모리, 파일, CPU 시간을 침범하지 못하게 보호하고, 외부 공격(바이러스, 웜, 해킹, DDoS 등)으로부터 시스템을 지킵니다. 사용자 인증, 접근 제어 목록(ACL), 암호화, 방화벽, 침입 탐지 시스템 등이 포함됩니다.

### 2.2 사용자와 운영체제 인터페이스 (User and Operating-System Interface)

운영체제와 사용자가 상호작용하는 주요 방식은 다음과 같습니다.

1. **명령 인터프리터 (Command Interpreter)**\
   사용자가 입력한 명령어를 해석하여 실행하거나 해당 프로그램을 호출합니다. UNIX/Linux에서는 shell(bash가 가장 일반적), Windows에서는 cmd.exe 또는 PowerShell이 이 역할을 합니다.
2. **그래픽 사용자 인터페이스 (GUI)**\
   아이콘 클릭, 드래그, 메뉴 선택 등 시각적·직관적 방식으로, Windows, macOS, Linux GNOME/KDE 등이 대표적입니다.
3. **터치 인터페이스 및 기타**\
   모바일 기기에서는 터치스크린 기반 인터페이스가 주를 이루며, 음성 명령도 보조적으로 사용됩니다.

### 2.3 시스템 호출 (System Calls)

\*\*시스템 호출(System Call)\*\*은 사용자 프로그램이 운영체제 서비스를 요청하는 **프로그래밍 인터페이스**입니다. 사용자 프로그램은 직접 하드웨어에 접근할 수 없으며, 반드시 시스템 호출을 통해 커널에 요청해야 합니다.

#### 주요 시스템 호출 카테고리와 예시 (POSIX 기준)

* **프로세스 제어**: fork(), exec(), wait(), exit(), kill(), getpid() 등
* **파일 관리**: open(), read(), write(), close(), lseek(), unlink(), mkdir(), chmod() 등
* **장치 관리**: ioctl(), read(), write() (장치도 파일처럼 취급)
* **정보 유지**: time(), getrusage(), alarm() 등
* **통신**: pipe(), shmget(), msgsnd(), socket(), bind(), connect(), send(), recv() 등
* **보호**: umask(), chown() 등

#### 시스템 호출 실행 과정

1. 사용자 프로그램이 시스템 호출 함수(예: read())를 호출합니다.
2. 라이브러리 래퍼가 \*\*트랩(software interrupt)\*\*을 발생시켜 CPU를 **사용자 모드 → 커널 모드**로 전환합니다.
3. 매개변수는 레지스터, 스택, 또는 메모리 테이블을 통해 전달됩니다 (Linux는 syscall 번호 + 인자 테이블 사용).
4. 커널이 요청을 처리한 후 결과를 반환하고 사용자 모드로 복귀합니다.

#### API와 시스템 호출의 관계

대부분의 프로그래머는 직접 시스템 호출을 사용하지 않고 **API**를 사용합니다.

* POSIX API (Unix/Linux/macOS 호환)
* Win32/Win64 API (Windows)
* Java API (JVM이 내부적으로 시스템 호출 사용)

API는 시스템 호출을 더 안전하고 이식성 있게 감싸주는 래퍼입니다.

### 2.4 시스템 프로그램 (System Programs)

시스템 프로그램(유틸리티)은 시스템 호출을 이용해 사용자에게 더 높은 수준의 서비스를 제공합니다.

주요 카테고리:

* 파일 관리 프로그램 (파일 생성·삭제·복사·이름 변경·목록 보기: ls, cp, mv, rm, mkdir 등)
* 상태 정보 프로그램 (날짜·시간, 메모리·디스크 사용량, 프로세스 목록: date, top, free, df, ps 등)
* 파일 수정 프로그램 (텍스트 에디터: vi, nano, emacs 등)
* 프로그래밍 언어 지원 프로그램 (컴파일러 gcc, 디버거 gdb 등)
* 프로그램 로드 및 실행 프로그램
* 통신 프로그램 (웹 브라우저, 메일 클라이언트, ssh 등)

### 2.5 링커와 로더 (Linkers and Loaders)

프로그램이 실행되기까지의 과정:

* **컴파일**: 소스 코드 → 오브젝트 파일 (.o)
* **링킹 (Linker)**: 여러 오브젝트 파일과 라이브러리를 연결하여 실행 파일 생성
  * 정적 링킹: 라이브러리 코드가 실행 파일에 포함
  * 동적 링킹: 공유 라이브러리(.so, .dll)를 실행 시 로드 (메모리 절약)
* **로딩 (Loader)**: 실행 파일을 메모리에 적재하고 프로그램 카운터를 설정하여 실행 시작

### 2.6 왜 응용 프로그램이 운영체제별로 다른가? (Why Applications Are Operating-System Specific)

각 운영체제의 시스템 호출 인터페이스, ABI, 라이브러리, 파일 형식, 드라이버가 다르기 때문입니다.\
해결책으로 Java, .NET, Flutter 등의 크로스 플랫폼 도구가 사용됩니다.

### 2.7 운영체제 설계와 구현 (Operating-System Design and Implementation)

**설계 목표**:

* 사용자 관점: 편리함, 학습 용이성, 신뢰성, 안전성, 빠른 응답
* 시스템 관점: 구현·유지보수 용이성, 유연성, 오류 최소화, 효율성

**메커니즘 vs 정책**:

* 메커니즘: 어떻게 할 것인가 (타이머, 메모리 보호)
* 정책: 무엇을 할 것인가 (스케줄링 알고리즘 선택)\
  정책은 자주 바뀔 수 있으므로 메커니즘과 분리하여 설계하는 것이 좋습니다.

### 2.8 운영체제 구조 (Operating-System Structure)

운영체제 구조는 성능, 유지보수성, 확장성의 trade-off를 결정합니다.

1. **단순 구조 (Simple Structure)**\
   MS-DOS처럼 사용자 프로그램과 드라이버, 커널이 거의 섞여 있음. 작고 빠르지만 유지보수 어려움.
2. **유닉스 구조**\
   사용자 → shell → 시스템 유틸리티 → 시스템 호출 → 커널 (파일 시스템, 프로세스 제어, 메모리 관리 등)
3. **계층형 구조 (Layered Approach)**\
   하드웨어(0층)부터 사용자 인터페이스(N층)까지 계층으로 나눔. 모듈화·디버깅 용이하지만 오버헤드 발생.
4. **마이크로커널 (Microkernel)**\
   Mach, QNX 등. 커널에 최소 기능만 넣고 나머지는 사용자 공간 프로세스로 실행. 안정성·확장성 높지만 성능 오버헤드 있음.
5. **모듈형 구조 (Modular)**\
   Linux, Solaris. 핵심만 정적 커널에, 나머지는 동적 로드 가능한 커널 모듈(LKM)로 구현. 유연성 최고.
6. **하이브리드 구조 (Hybrid)**\
   Windows NT 계열, macOS (XNU). 마이크로커널의 모듈성과 모놀리식의 성능을 결합.

### 2.9 운영체제 빌드와 부팅 (Building and Booting an Operating System)

* 커널 컴파일 → 이미지 생성
* **부팅 과정** (Linux 예시):
  1. 전원 ON → BIOS/UEFI 실행
  2. 부트로더(GRUB2) → 커널 이미지 로드
  3. 커널 초기화 (메모리, 인터럽트, 장치 드라이버)
  4. 첫 사용자 프로세스(systemd 또는 init) 실행 → 데몬 시작

### 2.10 운영체제 디버깅 (Operating-System Debugging)

* 로그 파일 분석 (/var/log)
* 성능 모니터링 (top, htop, perf, Windows Performance Monitor)
* 시스템 호출 추적 (strace, dtrace, SystemTap)
* 커널 디버거 (kgdb, WinDbg)
* BCC/eBPF 기반 도구
