# 운영체제 구조

이 장에서는 운영체제가 사용자와 프로그램에 제공하는 **서비스**의 종류, 사용자와 운영체제 간 **인터페이스** 방식, **시스템 호출**의 역할과 구현 방식, **시스템 프로그램**의 기능, 운영체제 **설계·구현** 원칙, 다양한 **운영체제 구조** (단순·유닉스·계층·마이크로커널·모듈형·하이브리드), **링커·로더**, **부팅 과정**, **디버깅 도구** 등을 다룹니다.

**Chapter Objectives** (원문 그대로)

* 운영체제가 제공하는 서비스 식별
* 시스템 호출을 통해 운영체제 서비스를 어떻게 제공하는지 설명
* 모놀리식, 계층형, 마이크로커널, 모듈형, 하이브리드 구조 비교
* 운영체제 성능 모니터링 도구 적용
* Linux 커널 모듈 설계 및 구현 예시

### 2.1 운영체제 서비스 (Operating-System Services)

운영체제는 프로그램 실행 환경을 제공하며, 프로그램과 사용자에게 다양한 서비스를 제공합니다. 서비스는 크게 **사용자에게 도움이 되는 서비스**와 **시스템 효율적 운영을 위한 서비스**로 나뉩니다.

#### 사용자에게 직접 도움이 되는 서비스

1. **사용자 인터페이스 (User Interface, UI)**\
   거의 모든 운영체제는 사용자 인터페이스를 제공합니다.
   * **명령줄 인터페이스 (Command-Line Interface, CLI)**: 텍스트 명령어를 입력받아 처리. UNIX/Linux의 shell (sh, bash, csh, zsh), Windows의 cmd.exe, PowerShell.
   * **그래픽 사용자 인터페이스 (Graphical User Interface, GUI)**: 마우스·아이콘·창·메뉴 기반. Microsoft Windows, macOS, Linux 데스크톱(GNOME, KDE 등).
   * **터치스크린 인터페이스**: 모바일 OS (Android, iOS)에서 스와이프·핀치·멀티터치 제스처 중심.
   * **음성 인식 인터페이스**: Siri (Apple), Google Assistant, Alexa 등 최근 증가.
2. **프로그램 실행 (Program Execution)**\
   운영체제는 디스크에 저장된 프로그램을 메모리에 로드하고, CPU를 할당하여 실행합니다. 프로그램이 정상 종료되거나 오류로 비정상 종료될 때까지 자원을 관리하고, 종료 시 모든 할당된 자원을 회수합니다.
3. **입출력 연산 (I/O Operations)**\
   프로그램은 파일·네트워크·프린터·키보드·디스플레이 등 다양한 I/O 장치를 사용해야 합니다.\
   운영체제는 사용자 프로그램이 직접 하드웨어에 접근하지 못하게 막고, **디바이스 드라이버**와 시스템 호출을 통해 안전하게 I/O를 수행하도록 합니다.
4. **파일 시스템 조작 (File-System Manipulation)**\
   파일과 디렉터리의 생성·삭제·읽기·쓰기·이름 변경·검색·이동, 파일 속성(크기, 생성일시, 권한, 소유자) 조회·변경, 디렉터리 탐색, 백업 등.\
   파일 시스템은 특히 중요하며, 운영체제는 파일의 일관성과 보호를 책임집니다.
5. **통신 (Communication)**
   * 동일 컴퓨터 내 프로세스 간 통신: 공유 메모리(shared memory) 또는 메시지 전달(message passing).
   * 다른 컴퓨터 간 통신: 네트워크를 통한 클라이언트-서버, P2P 등 (패킷 이동은 운영체제가 담당).
6. **오류 탐지 (Error Detection)**\
   CPU·메모리·I/O 장치의 하드웨어 오류, 사용자 프로그램의 소프트웨어 오류(0으로 나누기, 잘못된 메모리 접근 등)를 지속적으로 감지합니다.\
   오류 발생 시 사용자에게 알리거나 자동 복구, 또는 시스템 종료 등의 적절한 조치를 취합니다.

#### 시스템 효율적 운영을 위한 서비스

7. **자원 할당 (Resource Allocation)**\
   다중 사용자·다중 작업 환경에서 CPU 시간, 메모리 공간, 파일 저장 공간, I/O 장치 등을 여러 프로세스에 효율적·공정하게 분배합니다.\
   일부 자원(CPU 사이클, 메모리)은 특수 할당 코드가 필요합니다.
8. **회계 (Accounting)**\
   사용자별·프로세스별 자원 사용량(CPU 시간, 메모리, I/O 등)을 추적합니다. 과금 청구, 성능 분석, 보안 감사에 사용.
9. **보호와 보안 (Protection and Security)**
   * **보호**: 프로세스가 다른 프로세스의 메모리·파일·CPU 시간을 침범하지 못하게 함.
   * **보안**: 외부 공격(바이러스, 웜, 해킹)으로부터 시스템 보호. 사용자 인증, 접근 제어(ACL), 암호화, 방화벽, 침입 탐지 등.

### 2.2 사용자와 운영체제 인터페이스 (User and Operating-System Interface)

운영체제와 사용자가 상호작용하는 주요 방식은 세 가지입니다.

1. **명령 인터프리터 (Command Interpreter)**\
   사용자가 입력한 명령어를 해석하여 해당 프로그램을 실행하거나 시스템 호출을 호출합니다.\
   UNIX/Linux: shell (bash가 가장 일반적), Windows: cmd.exe 또는 PowerShell.
2. **그래픽 사용자 인터페이스 (GUI)**\
   아이콘 클릭, 드래그, 메뉴 선택 등 시각적·직관적 방식.\
   Windows, macOS, Linux GNOME/KDE 등.
3. **터치 및 기타 인터페이스**\
   모바일 기기 중심. 터치스크린 제스처 + 음성 명령(Siri 등).

### 2.3 시스템 호출 (System Calls)

시스템 호출은 **운영체제 서비스에 대한 프로그래밍 인터페이스**로, 사용자 프로그램이 커널 서비스를 요청하는 유일한 합법적 방법입니다.

#### 시스템 호출 카테고리 예시 (POSIX 기반)

* **프로세스 제어**: fork(), exec(), wait(), exit(), kill(), getpid() 등
* **파일 관리**: open(), read(), write(), close(), lseek(), unlink(), mkdir(), chmod() 등
* **장치 관리**: ioctl(), read(), write() (장치도 파일처럼 취급)
* **정보 유지**: time(), getrusage(), alarm() 등
* **통신**: pipe(), shmget(), msgsnd(), socket(), bind(), connect(), send(), recv() 등
* **보호**: umask(), chown() 등

#### 시스템 호출 구현 과정

1. 사용자 프로그램이 시스템 호출 함수 호출 (예: read())
2. 라이브러리 래퍼가 **트랩**(software interrupt) 발생 → CPU가 **사용자 모드 → 커널 모드** 전환
3. 매개변수 전달: 레지스터, 스택, 또는 메모리 테이블 (Linux는 syscall 번호 + 인자 테이블)
4. 커널이 요청 처리 후 결과 반환 → 사용자 모드 복귀

#### API와의 관계

대부분의 프로그래머는 직접 시스템 호출을 사용하지 않고 **API**를 씁니다.

* **POSIX API**: UNIX/Linux/macOS 호환 (open(), read() 등)
* **Win32/Win64 API**: Windows 전용
* **Java API**: JVM이 내부적으로 시스템 호출 사용

API는 시스템 호출을 더 안전하고 이식성 있게 감싸줍니다.

### 2.4 시스템 프로그램 (System Programs)

시스템 프로그램(유틸리티)은 시스템 호출을 이용해 사용자에게 더 높은 수준의 서비스를 제공합니다.

주요 유형:

* **파일 관리**: 파일 생성·삭제·복사·이름 변경·목록 보기 (ls, cp, mv, rm, mkdir 등)
* **상태 정보**: 시스템 시간·날짜, 메모리·디스크 사용량, 프로세스 목록 (date, top, free, df, ps 등)
* **파일 수정**: 텍스트 에디터 (vi, nano, emacs, notepad)
* **프로그래밍 언어 지원**: 컴파일러(gcc), 어셈블러, 디버거(gdb)
* **프로그램 로드·실행**: 로더, 인터프리터
* **통신**: 웹 브라우저, 메일 클라이언트, ssh, ftp 등

### 2.5 링커와 로더 (Linkers and Loaders)

프로그램 실행 과정:

* **컴파일**: 소스 → 오브젝트 파일 (.o)
* **링킹 (Linker)**: 여러 오브젝트 파일 + 라이브러리 연결 → 실행 파일 생성
  * **정적 링킹**: 라이브러리 코드 실행 파일에 포함
  * **동적 링킹**: 공유 라이브러리(.so, .dll) 실행 시 로드 → 메모리 절약
* **로딩 (Loader)**: 실행 파일을 메모리에 적재하고 프로그램 카운터 설정 → 실행 시작

### 2.6 왜 응용 프로그램이 운영체제별로 다른가? (Why Applications Are Operating-System Specific)

* 시스템 호출 인터페이스와 ABI(Application Binary Interface)가 다름
* 라이브러리·파일 형식·드라이버 차이
* 해결책: 크로스 플랫폼 도구 (Java, .NET, Flutter, Electron 등)

### 2.7 운영체제 설계와 구현 (Operating-System Design and Implementation)

#### 설계 목표

* **사용자 관점**: 편리함, 학습 용이성, 신뢰성, 안전성, 속도
* **시스템 관점**: 구현·유지보수 용이성, 유연성, 오류 최소화, 효율성

#### 메커니즘 vs 정책

* **메커니즘**: 어떻게 할 것인가 (타이머, 메모리 보호 기법)
* **정책**: 무엇을 할 것인가 (스케줄링 알고리즘 선택, 페이지 교체 정책)\
  → 정책은 자주 바뀔 수 있으므로 메커니즘과 분리 설계가 바람직

### 2.8 운영체제 구조 (Operating System Structure)

대표 구조 비교 (원문 핵심)

1. **단순 구조 (Simple Structure)**\
   MS-DOS: 사용자 프로그램·드라이버·커널이 섞여 있음 → 작고 빠르지만 유지보수 어려움.
2. **유닉스 구조 (UNIX – Layered + 모듈)**\
   사용자 → shell → 유틸리티 → 시스템 호출 → 커널 (파일 시스템, 프로세스 제어, 메모리 관리 등)\
   원래 UNIX는 하드웨어 제한으로 제한적 구조.
3. **계층형 구조 (Layered Approach)**\
   하드웨어(0층) → 기본 인터페이스 → 프로세스 관리 → 메모리 관리 → … → 사용자 인터페이스(N층)\
   장점: 모듈화, 디버깅·검증 용이\
   단점: 층 간 호출 오버헤드
4. **마이크로커널 (Microkernel)**\
   Mach, QNX, Minix 3\
   커널에 최소 기능(메시지 전달, 기본 스케줄링, 메모리 관리)만 넣고, 파일 시스템·드라이버·네트워크 등은 사용자 공간 프로세스.\
   장점: 확장성·안정성·이식성·보안 (컴포넌트 하나 죽어도 전체 안 죽음)\
   단점: 사용자-커널 간 컨텍스트 스위치 많아 성능 저하
5. **모듈형 구조 (Modular / Loadable Kernel Modules)**\
   Solaris, Linux\
   핵심 기능만 정적 커널에, 나머지는 동적 로드 가능한 모듈(LKM)\
   장점: 유연성 최고, 필요한 모듈만 로드 → 메모리 효율
6. **하이브리드 구조 (Hybrid Kernel)**\
   Windows NT 계열, macOS (XNU)\
   마이크로커널의 모듈성 + 모놀리식의 성능 결합

### 2.9 운영체제 생성·부팅·디버깅 (Generation, Booting, Debugging)

* **부팅 과정** (Linux 중심): BIOS/UEFI → GRUB 부트로더 → 커널 로드 → 초기화 (메모리·인터럽트·장치) → systemd/init 실행
* **디버깅 도구**: strace, dtrace, perf, BCC (eBPF 기반), kgdb 등
