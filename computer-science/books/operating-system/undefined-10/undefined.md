# 스트림

\*\*스트림(STREAMS)\*\*은 UNIX System V에서 처음 도입된 메커니즘으로, 사용자 프로세스와 장치 드라이버 사이의 전이중(Full-Duplex) 통신 채널을 동적으로 구성할 수 있게 해주는 프레임워크입니다. 이를 통해 I/O 처리 모듈을 유연하게 조립하고 재사용할 수 있습니다.

**스트림의 구조**

스트림은 다음과 같은 계층적 구성 요소로 이루어져 있습니다.

* **스트림 헤드 (Stream Head)**:
  * 사용자 프로세스와 가장 가까운 끝단입니다.
  * 사용자 프로세스가 수행하는 시스템 호출(write, read, ioctl 등)을 스트림 내부의 메시지로 변환하거나, 그 반대의 작업을 수행합니다.
* **스트림 엔드 (Stream End)**:
  * 하드웨어와 가장 가까운 끝단으로, **장치 드라이버**가 위치합니다.
  * 장치 컨트롤러의 인터럽트를 처리하고 하드웨어와 데이터를 주고받습니다.
* **모듈 (Modules)**:
  * 스트림 헤드와 스트림 엔드 사이에 위치하는 처리 단위입니다.
  * 사용자는 필요에 따라 스트림에 모듈을 \*\*푸시(Push)\*\*하여 추가하거나 \*\*팝(Pop)\*\*하여 제거할 수 있습니다.
  * 각 모듈은 데이터 암호화, 압축, 프로토콜 처리(예: TCP/IP) 등의 특정 기능을 수행합니다.

**데이터 흐름과 큐 (Flow and Queues)**

스트림 내의 데이터 이동은 **메시지 패싱(Message Passing)** 방식을 따르며, 각 구성 요소는 한 쌍의 큐를 가집니다.

* **읽기 큐 (Read Queue)**:
  * 하드웨어(스트림 엔드)에서 사용자 프로세스(스트림 헤드) 방향으로 올라가는 데이터를 저장합니다.
* **쓰기 큐 (Write Queue)**:
  * 사용자 프로세스(스트림 헤드)에서 하드웨어(스트림 엔드) 방향으로 내려가는 데이터를 저장합니다.
* **비동기 처리**:
  * 모듈 간의 데이터 전달은 인접한 모듈의 큐로 메시지를 넘기는 방식으로 이루어지며, 이는 비동기적으로 처리될 수 있어 유연성이 높습니다.

**스트림의 장점**

* **모듈성 및 재사용성**:
  * 디바이스 드라이버 내에 복잡한 프로토콜 처리 로직을 모두 넣을 필요가 없습니다. 대신, 범용적인 모듈(예: 네트워크 프로토콜 모듈)을 여러 드라이버가 공유하여 사용할 수 있습니다.
* **동적 구성**:
  * 응용 프로그램은 실행 중에 `ioctl()` 시스템 호출을 사용하여 원하는 모듈을 스트림에 즉시 추가하거나 제거할 수 있습니다. (예: 키보드 입력 스트림에 '한글 처리 모듈'을 동적으로 삽입)
* **표준화된 인터페이스**:
  * 모든 I/O 처리가 동일한 스트림 인터페이스를 따르므로, 네트워크 소켓, 터미널, 파이프 등 다양한 장치에 일관된 방식으로 접근할 수 있습니다.
