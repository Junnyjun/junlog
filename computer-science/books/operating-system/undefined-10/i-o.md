# 응용 I/O 인터페이스

운영체제는 다양한 종류의 하드웨어 I/O 장치(키보드, 디스크, 프린터 등)의 복잡성을 숨기고, 응용 프로그램이 일관되고 단순한 방식으로 I/O 작업을 요청할 수 있도록 표준화된 인터페이스를 제공합니다.

**1. 장치 독립성 (Device Independence)**

I/O 시스템의 주요 목표는 장치 독립성을 달성하는 것입니다.

* 원리: 응용 프로그램은 특정 장치(예: 'HP-1020 레이저 프린터')의 세부 사항을 알 필요 없이, 일반적인 I/O 호출 (예: `open`, `read`, `write`)을 사용합니다.
* 구현: 운영체제의 I/O 서브시스템이 이러한 일반 요청을 실제 장치 드라이버가 이해할 수 있는 장치 종속적인 명령으로 변환합니다.
* 효과: 새로운 장치가 시스템에 추가되어도 응용 프로그램을 다시 컴파일할 필요가 없어 시스템의 유연성이 높아집니다.

**2. I/O 시스템 호출 (I/O System Calls)**

운영체제는 파일 시스템 I/O와 마찬가지로, 장치 I/O를 위해 일련의 표준 시스템 호출을 제공합니다.

* Open / Close: 장치를 사용하기 위해 논리적으로 열고(open) 사용이 끝나면 닫습니다(close). 이 과정에서 장치 드라이버가 해당 장치를 초기화하거나 점유합니다.
* Read / Write: 장치에서 데이터를 읽거나(read) 장치로 데이터를 씁니다(write). 이 호출들은 블록 또는 문자 단위로 데이터를 처리합니다.
* Seek: 파일 시스템에서처럼, \*\*장치 내의 특정 위치(Offset)\*\*로 논리적 포인터를 이동시키는 데 사용됩니다 (주로 디스크와 같은 무작위 접근 장치에 적용).
* Ioctl (I/O Control):
  * 목적: 표준화된 `read`/`write` 호출로 처리할 수 없는 특정 장치 제어 기능을 수행할 때 사용됩니다.
  * 예시: 테이프 드라이브를 되감거나, 디스크의 포맷 정보를 얻는 등 장치 고유의 특화된 명령을 전달합니다.

**3. 장치 유형별 특성 (Characteristics by Device Type)**

응용 프로그램이 I/O를 요청하는 방식은 장치의 특성에 따라 분류됩니다.

* 블록 장치 (Block Devices):
  * 특성: 데이터를 고정된 크기의 블록(Block) 단위로 처리하며, \*\*무작위 접근(Random Access)\*\*이 가능합니다.
  * 예시: 디스크, 광 디스크, 솔리드 스테이트 드라이브(SSD).
  * I/O 요청: 블록 단위로 읽기/쓰기를 요청하며, 위치 지정(Seek)이 가능합니다.
* 문자 장치 (Character Devices):
  * 특성: 데이터를 한 번에 한 문자(Byte) 단위로 처리하며, 일반적으로 \*\*순차적 접근(Sequential Access)\*\*만 가능합니다.
  * 예시: 키보드, 마우스, 프린터, 네트워크 인터페이스.
  * I/O 요청: 바이트 스트림을 보내거나 받으며, 위치 지정(Seek)이 의미 없습니다.

**4. 동기 대 비동기 I/O (Synchronous vs. Asynchronous I/O)**

I/O 시스템 호출은 프로세스의 실행 흐름을 멈추는지 여부에 따라 두 가지 방식으로 나뉩니다.

* 동기 I/O (Synchronous I/O):
  * 작동: I/O 작업이 완료될 때까지 호출한 프로세스가 대기(Wait) 상태에 머뭅니다.
  * 장점: 프로그래밍이 단순하고 일관성 유지에 유리합니다.
  * 단점: I/O 작업이 느릴 경우 CPU 이용률이 저하됩니다.
* 비동기 I/O (Asynchronous I/O):
  * 작동: I/O 작업을 요청한 후, 프로세스는 즉시 다른 작업을 계속 수행하고, I/O 작업은 백그라운드에서 진행됩니다. 작업이 완료되면 인터럽트나 시그널을 통해 프로세스에 통보합니다.
  * 장점: I/O 대기 시간 동안 CPU를 활용할 수 있어 시스템 스루풋이 증가합니다.
  * 단점: I/O 완료를 확인하는 복잡한 메커니즘이 필요합니다.
