# I/O 요청을 하드웨어 동작

응용 프로그램이 파일을 읽으려는 단순한 시도는 커널의 여러 계층과 하드웨어의 복잡한 상호작용을 거치게 됩니다. 일반적인 `read()` 시스템 호출이 하드웨어 동작으로 변환되는 과정은 다음과 같습니다.

**I/O 요청의 하향 흐름 (User to Hardware)**

*   시스템 호출 발생: 응용 프로그램이 이전에 열어둔 파일 기술자(File Descriptor)를 사용하여 `read()` 시스템 호출을 보냅니다.<sup>1</sup> 이때 데이터가 저장될 메모리 주소와 읽을 크기가 함께 전달됩니다.

    <a class="button secondary"></a>
* 커널 시스템 호출 처리: 커널은 전달된 매개변수의 유효성을 검사합니다. 만약 요청한 데이터가 이미 \*\*페이지 캐시(Page Cache)\*\*에 있다면, 하드웨어 접근 없이 데이터를 즉시 사용자 메모리로 복사하고 반환합니다.
* 논리적 I/O 요청: 캐시에 데이터가 없는 경우, 커널은 파일 시스템 계층을 통해 해당 데이터가 디스크의 어떤 논리적 블록에 위치하는지 계산합니다.
* 장치 드라이버 전달: 계산된 논리적 블록 주소는 해당 장치를 관리하는 \*\*장치 드라이버(Device Driver)\*\*로 전달됩니다. 드라이버는 이 요청을 장치 대기열(Request Queue)에 추가합니다.
* I/O 스케줄링 및 명령 생성: 디바이스 드라이버는 스케줄링 알고리즘을 통해 대기열의 요청 순서를 최적화한 후, 하드웨어 컨트롤러가 이해할 수 있는 구체적인 명령(예: 특정 섹터 읽기)을 작성합니다.
* 하드웨어 제어: 드라이버는 장치 컨트롤러의 \*\*명령 레지스터(Command Register)\*\*에 명령을 쓰고, DMA 컨트롤러에 데이터 전송 목적지 주소를 설정합니다.

**하드웨어 동작 및 상향 통보 (Hardware to User)**

* 장치 동작: 디스크 컨트롤러가 하드웨어를 조작하여 데이터를 읽습니다. 읽어 들인 데이터는 장치 내부의 로컬 버퍼에 임시 저장됩니다.
* DMA 전송: 장치 컨트롤러는 CPU의 개입 없이 \*\*DMA(Direct Memory Access)\*\*를 통해 로컬 버퍼의 데이터를 메인 메모리로 직접 전송합니다.
* 인터럽트 발생: 데이터 전송이 완료되면 하드웨어는 CPU에 인터럽트 신호를 보냅니다.
* 인터럽트 처리: CPU는 현재 작업을 멈추고 \*\*인터럽트 서비스 루틴(ISR)\*\*을 실행합니다. ISR은 작업 완료를 확인하고, 대기 중이던 프로세스를 준비(Ready) 상태로 전환합니다.
* 결과 반환: 커널은 하드웨어로부터 읽어온 데이터를 사용자 프로세스의 메모리 공간으로 복사하고, 시스템 호출의 결과를 반환하며 제어권을 응용 프로그램에 넘깁니다.

**복잡성 추상화의 이점**

* 하드웨어 독립성: 응용 프로그램은 데이터가 HDD에 있는지 SSD에 있는지 알 필요 없이 동일한 인터페이스를 사용합니다.
* 성능 최적화: 커널은 변환 과정 중에 캐싱, 스케줄링, 버퍼링 등을 수행하여 하드웨어의 느린 속도를 보완합니다.
* 오류 격리: 하드웨어에서 발생한 물리적 오류(예: 배드 섹터)를 커널 수준에서 감지하고 처리하여 응용 프로그램의 비정상 종료를 방지합니다.

***

이 내용이 사용자님의 파일 기준 \*\*12.5장 'I/O 요청을 하드웨어 동작으로 변환'\*\*의 정확한 내용입니다. 이전 답변에서 12.5장으로 제공했던 '성능' 부분은 사용자님의 목차 구조상 12.6장으로 이동하는 것이 맞을까요? 진행 방향을 말씀해 주세요.
