# 시스템 호출

### 시스템 호출 예시 — 파일 복사를 통해 보는 시스템 콜 체인

운영체제가 사용자와 하드웨어 사이의 중재자 역할을 한다는 말은 이론적으로는 간단하지만, 실제 프로그램 실행 과정에서는 어떻게 작동할까요?

```bash
cp file1 file2
```

이는 단순한 파일 복사 명령어입니다. 하지만 이 명령이 수행되기 위해선 내부적으로 수많은 시스템 호출이 작동하며, 운영체제는 그 모든 작업을 커널에서 처리합니다.

***

#### 사용자 명령어의 내부 구조

사용자가 `cp file1 file2`를 입력하면 다음과 같은 흐름이 발생합니다:

1. **쉘이 fork()를 호출**하여 `cp` 명령을 위한 자식 프로세스를 생성
2. **자식 프로세스가 exec()을 호출**하여 `cp` 프로그램을 메모리에 적재 후 실행
3. `cp` 명령은 내부적으로 다음 시스템 콜을 수행:
   * `open("file1", O_RDONLY)`
   * `create("file2")`
   * 반복:
     * `read(fd1, buffer, size)`
     * `write(fd2, buffer, size)`
   * `close(fd1)`
   * `close(fd2)`

이 과정에서 사용자는 단 하나의 명령을 실행했지만, 운영체제는 내부적으로 수많은 시스템 자원(파일 디스크립터, 버퍼, 메모리, 커널 테이블 등)을 관리하고 처리합니다.

***

#### 시스템 콜 호출 순서 요약

| 순서 | 시스템 콜             | 설명                     |
| -- | ----------------- | ---------------------- |
| 1  | `fork()`          | `cp` 실행을 위한 자식 프로세스 생성 |
| 2  | `exec()`          | 자식 프로세스에 `cp` 바이너리 로드  |
| 3  | `open("file1")`   | 읽을 파일 열기               |
| 4  | `create("file2")` | 새 파일 생성 및 열기           |
| 5  | `read()`          | 입력 파일에서 버퍼로 데이터 복사     |
| 6  | `write()`         | 버퍼 내용을 출력 파일로 기록       |
| 7  | `close()`         | 파일 디스크립터 정리 후 자원 해제    |

***

#### 파일 디스크립터와 커널 자원

각 파일(`file1`, `file2`)은 열릴 때 \*\*파일 디스크립터(File Descriptor)\*\*를 커널로부터 할당받습니다. 이 값은 정수이며, 커널의 전역 테이블에서 다음과 같은 정보를 유지합니다:

* 파일 위치 (오프셋)
* 접근 권한
* 캐시 여부
* 커널 버퍼와 연동 여부

커널은 이 구조체를 기반으로 `read()` 요청을 처리하며, 오프셋과 권한을 검사한 후 실제 디스크 블록에서 데이터를 읽어옵니다.

***

#### 프로세스 제어와 사용자 ↔ 커널 모드 전환

위와 같은 시스템 콜은 모두 사용자 모드에서 호출되지만, 커널 모드로 진입하면서 특권 명령을 실행할 수 있게 됩니다.

> 예: `read()` 호출 시\
> → 사용자 프로그램은 `libc`의 `read()` 함수를 호출\
> → 해당 함수는 시스템 콜 번호를 레지스터에 저장하고 소프트웨어 인터럽트를 발생\
> → 커널이 해당 시스템 콜을 찾아 실행하고 결과를 반환

이러한 방식으로 **운영체제는 사용자에게 제한적이고 통제된 방식으로 자원을 제공**합니다.

***

#### POSIX 코드

아래는 위의 과정과 동일한 기능을 수행하는 POSIX C 코드 예시입니다:

```c
int main() {
    int in, out;
    char buf[512];
    int count;

    in = open("file1", O_RDONLY);
    out = creat("file2", 0666);

    while ((count = read(in, buf, sizeof(buf))) > 0)
        write(out, buf, count);

    close(in);
    close(out);
    return 0;
}
```

***

## 응용 프로그래밍 인터페이스 (Application Programming Interface)

### 운영체제는 어떻게 사용자에게 기능을 제공하는가?

시스템 콜은 운영체제 기능을 호출하는 저수준 메커니즘입니다. 하지만 대부분의 응용 프로그램은 **시스템 콜을 직접 호출하지 않습니다.** 대신, 고수준 언어에서 제공하는 \*\*API(Application Programming Interface)\*\*를 통해 간접적으로 시스템 콜을 사용합니다.

***

### API vs System Call: 구조 비교

| 구분    | 시스템 콜 (System Call)     | API (Application Programming Interface)   |
| ----- | ----------------------- | ----------------------------------------- |
| 수준    | 저수준 (커널 진입점)            | 고수준 (사용자 접근점)                             |
| 직접 호출 | 일반적으로 불가능 또는 비효율적       | 가능                                        |
| 목적    | 운영체제 기능 수행              | 프로그래머 인터페이스 제공                            |
| 예     | `sys_read`, `sys_write` | `fread()`, `fprintf()`, `CreateProcess()` |

예를 들어 C 언어의 `fread()` 함수는 내부적으로 `read()` 시스템 콜을 호출하고, 그 시스템 콜은 다시 커널 내부에서 디스크 I/O를 수행합니다.

***

### API 호출 흐름도

```
[ 사용자 코드 ]
     ↓ API 호출 (예: read())
[ 라이브러리 코드 ] (glibc / Windows DLL)
     ↓ 시스템 콜 인터페이스
[ 커널 모드 진입 ]
     ↓ 커널 디스패처 (System Call Handler)
[ 실제 커널 기능 실행 ]
```

라이브러리는 시스템 콜 번호를 적절한 레지스터에 로드하고, `syscall` 또는 `int 0x80` 명령으로 커널 진입을 수행합니다.

***

### 운영체제별 API 설계 예시

#### ✅ Windows API

* API는 Win32 또는 Windows Native API로 구성됨
* `CreateProcess()` API는 내부적으로 수많은 하위 시스템 콜(`NtCreateProcess`, `NtCreateThread`, `NtOpenFile` 등)을 호출

```c
HANDLE hProcess = CreateProcess(
  "notepad.exe", NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi);
```

#### ✅ POSIX API (Linux/UNIX)

* POSIX 표준은 `fork()`, `exec()`, `open()`, `read()` 등의 시스템 호출과 1:1로 매핑되는 API를 정의
* 예:

```c
pid_t pid = fork();
if (pid == 0) {
    execl("/bin/ls", "ls", NULL);
}
```

* 위 API는 실제로 `sys_fork`, `sys_execve` 시스템 콜을 호출

#### ✅ Java API

* Java는 시스템 콜을 직접 노출하지 않음
* JVM 내부에서 OS에 맞는 시스템 콜을 네이티브 메서드(Native Method)로 래핑하여 처리

예: `new FileInputStream("file.txt")` → 내부적으로 `open()` 시스템 콜 호출

***

### API의 장점: 추상화와 이식성

#### 1. **이식성 (Portability)**

* 동일한 API 코드는 Windows, Linux, macOS에서도 컴파일만 다르게 하면 동작
* 시스템 콜은 OS마다 다르기 때문에 직접 사용하면 이식성 저하

#### 2. **단순화**

* 시스템 콜은 다양한 파라미터를 요구하지만, API는 이를 단순화
* 오류 처리, 버퍼 크기, 리턴 값 관리 등을 내부적으로 처리

#### 3. **보안 및 안정성**

* API는 사용자의 잘못된 호출을 내부에서 막아줌
* 시스템 콜 인터페이스 직접 사용 시, 잘못된 접근으로 인한 시스템 오류 가능성 ↑

***

### 시스템 콜 흐름

```c
#include <unistd.h>
char buf[100];
read(3, buf, 100);
```

내부 처리 구조:

```
read()      // API 호출
→ syscall(0x3, 3, buf, 100)   // 시스템 콜 번호와 인자 설정
→ 커널 진입 → sys_read() 실행
```

***

## 시스템 콜 유형별 분류

운영체제는 다양한 기능을 시스템 콜이라는 형태로 제공하며, 이를 논리적으로 분류하면 다음과 같은 **6가지 범주**로 정리됩니다. 이 분류는 커널이 어떤 서비스를 수행하는지에 대한 이해를 돕고, 시스템 인터페이스 설계 및 API 설계 시 기준이 됩니다.

***

### 프로세스 제어 (Process Control)

**역할**: 새로운 프로세스를 생성하고, 실행하며, 종료하는 기능

#### 주요 시스템 콜

| 시스템 콜                  | 설명                        |
| ---------------------- | ------------------------- |
| `end()` / `abort()`    | 현재 실행 중인 프로세스를 종료         |
| `load()` / `execute()` | 새로운 프로그램 로딩 및 실행          |
| `create_process()`     | 사용자 정의 구조 기반 프로세스 생성      |
| `wait()`               | 자식 프로세스 종료까지 대기           |
| `fork()`               | 부모 프로세스를 복제하여 자식 생성       |
| `exec()`               | 현재 프로세스 이미지를 새 실행파일로 덮어쓰기 |
| `exit()`               | 종료 코드 반환 후 프로세스 정리        |

#### 예시 흐름

UNIX 계열 시스템에서 새로운 명령을 실행할 때:

1. `fork()` → 새로운 자식 프로세스 생성
2. `exec()` → 자식 프로세스가 다른 프로그램으로 덮어쓰기
3. `wait()` → 부모는 자식 종료를 대기

***

### 파일 관리 (File Management)

**역할**: 파일 생성, 삭제, 읽기, 쓰기, 속성 변경 등

#### 주요 시스템 콜

| 시스템 콜                                   | 설명             |
| --------------------------------------- | -------------- |
| `create()` / `delete()`                 | 파일 생성 또는 삭제    |
| `open()` / `close()`                    | 파일 디스크립터 할당/해제 |
| `read()` / `write()`                    | 버퍼 I/O         |
| `get_attributes()` / `set_attributes()` | 파일 메타데이터 제어    |

#### 특징

* 대부분의 운영체제에서 **파일, 디바이스, 소켓을 동일한 추상화 객체로 취급**함
* 동일한 시스템 콜(`read`, `write`)로 다양한 자원을 다룰 수 있음

***

### 디바이스 관리 (Device Management)

**역할**: 장치 사용 요청, 장치 해제, 제어 명령 전달

#### 주요 시스템 콜

| 시스템 콜                | 설명                                    |
| -------------------- | ------------------------------------- |
| `request_device()`   | 장치에 대한 소유권 요청                         |
| `release_device()`   | 장치 해제                                 |
| `read()` / `write()` | 디바이스 입출력                              |
| `ioctl()`            | 장치 제어 명령 전송 (Device-specific control) |

#### 예시

* 프린터 제어
* 마우스, 키보드 동작 모드 변경
* 터미널 설정 (`stty` 등)

***

### 정보 유지 (Information Maintenance)

**역할**: 시스템 정보 및 상태 조회, 설정

#### 주요 시스템 콜

| 시스템 콜                       | 설명            |
| --------------------------- | ------------- |
| `getpid()`                  | 현재 프로세스 ID 조회 |
| `alarm()` / `sleep()`       | 타이머 설정 및 대기   |
| `get_time()` / `set_time()` | 시스템 시간 조회/설정  |
| `dump_memory()`             | 메모리 상태 조회     |

#### 실용 사례

* 로그 기록용 시스템 시간 수집
* 프로파일링 도구에서 PID 추적

***

### 통신 (Communication)

**역할**: 프로세스 간 통신(IPC) 및 네트워크 기반 통신 처리

#### 통신 모델

1. **메시지 전달(Message Passing)**: 프로세스 간 명시적 메시지 송수신
2. **공유 메모리(Shared Memory)**: 프로세스 간 동일 메모리 영역 공유

#### 주요 시스템 콜

| 시스템 콜                                           | 설명                |
| ----------------------------------------------- | ----------------- |
| `create_pipe()` / `open_pipe()`                 | 파이프 생성            |
| `send()` / `receive()`                          | 메시지 전송 및 수신       |
| `socket()` / `bind()` / `listen()` / `accept()` | 네트워크 소켓 통신 처리     |
| `shared_memory_create()` / `attach()`           | 공유 메모리 영역 생성 및 연결 |

#### 예시

* 명령어 파이프라인 (`ls | grep foo`)
* TCP/IP 기반 소켓 통신 (웹 서버/클라이언트)

***

### 보호 (Protection)

**역할**: 사용자 인증, 접근 권한 제어, 리소스 보호

#### 주요 시스템 콜

| 시스템 콜                   | 설명             |
| ----------------------- | -------------- |
| `setuid()` / `setgid()` | 사용자 및 그룹 ID 설정 |
| `chmod()` / `chown()`   | 파일 권한 및 소유자 변경 |
| `access()`              | 접근 권한 확인       |

#### 관련 챕터

* 접근 제어는 Chapter 17 (보호 시스템)
* 보안과 인증은 Chapter 16에서 심화 다룸

***

### 📝 운영체제별 시스템 콜 비교

| 기능      | Windows API         | UNIX/Linux POSIX      |
| ------- | ------------------- | --------------------- |
| 프로세스 생성 | `CreateProcess()`   | `fork()` + `exec()`   |
| 파일 열기   | `CreateFile()`      | `open()`              |
| 파일 읽기   | `ReadFile()`        | `read()`              |
| 종료      | `ExitProcess()`     | `exit()`              |
| 권한 설정   | `SetSecurityInfo()` | `chmod()`, `setuid()` |
