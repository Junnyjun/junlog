# 요구 페이징

실행 가능한 프로그램이 보조 저장 장치(secondary storage)에서 메모리로 적재되는 방법을 고려해봅시다. 프로그램 실행 시 프로그램 전체를 물리 메모리에 적재하는 것은 메모리 낭비, 느린 시작 시간, 제한된 동시성 등의 문제점을 가집니다.

이러한 문제를 해결하기 위해 요구 페이징(Demand Paging) 기법이 사용됩니다. 이 기법은 페이지가 실제로 요구될 때만 메모리에 적재하는 방식으로, 메모리 사용 효율을 높이고 더 많은 프로그램이 동시에 실행될 수 있도록 합니다.

**기본 개념 (Basic Concept)**

* 논리적 vs. 물리적 공간: 요구 페이징을 사용하면, 프로세스의 논리적 주소 공간은 물리적 메모리보다 훨씬 커질 수 있습니다.
* 유효-무효 비트: 페이지 테이블 항목에 있는 유효(valid)/무효(invalid) 비트는 이 기법을 구현하는 데 결정적인 역할을 합니다.
  * 유효(valid): 연관된 페이지가 합법적이고 물리 메모리에 있음을 나타냅니다.
  * 무효(invalid): 연관된 페이지가 메모리에 없음을 나타내거나(현재 보조 저장 장치에 있음), 혹은 해당 페이지가 프로세스의 논리적 주소 공간에 속하지 않음을 나타냅니다.

**페이지 오류 (Page Fault)의 상세 처리 과정**

페이지 오류는 요구 페이징의 핵심 메커니즘입니다. CPU가 페이지에 접근하려고 할 때, 페이지 테이블에서 해당 페이지의 유효-무효 비트가 \*\*'무효(invalid)'\*\*인 것을 발견하면 \*\*페이지 오류(page fault)\*\*라는 운영체제 트랩이 발생합니다.

페이지 오류를 처리하는 상세 단계:

1. 트랩 발생 및 저장: 하드웨어가 운영체제에 \*\*트랩(trap)\*\*을 발생시키고, 페이지 오류를 일으킨 명령어를 저장합니다.
2. 유효성 검사: 운영체제는 먼저 페이지 참조가 합법적인지 (즉, 유효한 주소 공간 내에 있는지) 확인합니다.
3. 디스크 위치 확인: 페이지가 합법적인 참조이지만 메모리에 없는 경우, 운영체제는 해당 페이지가 보조 저장 장치(스와핑 공간)의 어디에 있는지를 확인합니다.
4. 프레임 할당: 운영체제는 물리 메모리에서 빈 프레임을 찾습니다. (만약 빈 프레임이 없다면, 페이지 교체 알고리즘을 사용하여 희생자 페이지를 선택하고 해당 페이지를 디스크로 내보냅니다. 이 부분이 바로 페이지 교체의 필요성입니다.)
5. 디스크 I/O 예약: 디스크 I/O를 예약하여 요구된 페이지를 새로 확보된 프레임으로 로드합니다.
6. I/O 대기: 디스크 I/O가 완료될 때까지 이 프로세스는 \*\*대기 상태(waiting state)\*\*로 전환됩니다.
7. 페이지 테이블 업데이트: 디스크 I/O가 완료되면, 페이지 테이블의 해당 항목이 업데이트되고 유효 비트가 \*\*'유효(valid)'\*\*로 설정됩니다.
8. 프로세스 재시작: 대기 상태에 있던 프로세스가 준비 큐로 이동하고, 페이지 오류를 일으켰던 명령어가 다시 시작됩니다.

**성능 (Performance of Demand Paging)**

요구 페이징의 성능은 주로 \*\*유효 접근 시간(Effective Access Time, EAT)\*\*으로 측정됩니다.

* 페이지 오류율 (Page Fault Rate): ![](data:,)는 페이지 오류율(![](data:,))이며, $(1-p)$는 페이지가 메모리에서 발견되는 확률(hit ratio)입니다.
* EAT 공식: ![](data:,)
  * 페이지 오류 처리 시간은 수백만 나노초에 달할 수 있어, 메모리 접근 시간(수백 나노초)에 비해 매우 길기 때문에, 페이지 오류율 ![](data:,)가 매우 낮게 유지되어야만 성능 향상 효과를 볼 수 있습니다.

**스와핑 영역 (Swap Space)**

요구 페이징 환경에서 페이지가 물리 메모리에 없는 경우, 해당 페이지는 \*\*스와핑 영역(swap space)\*\*이라 불리는 보조 저장 장치에 보관됩니다. 스와핑 영역은 파일 시스템과는 별개로, 더 빠른 접근 속도를 위해 최적화된 디스크 공간입니다.
