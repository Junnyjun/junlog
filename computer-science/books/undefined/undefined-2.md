# 설계원칙

### 설계 원칙의 이해와 활용

앞 장에서는 객체지향의 기본 개념을 살펴보았습니다. 이제 본격적으로 SOLID, KISS, YAGNI, DRY, LoD와 같은 고전적이고 중요한 설계 원칙들을 소개하겠습니다. 이러한 설계 원칙을 잘 이해하는 것도 중요하지만, 더욱 중요한 것은 실제 개발 현장에서 이 원칙들을 정확히 어떻게 적용하는지를 아는 것입니다.&#x20;

설계 원칙을 충분히 이해하지 못한 채 무조건적으로 엄격하게 적용하면 오히려 부작용이 발생할 수 있습니다.&#x20;

***

### 단일 책임 원칙 (Single Responsibility Principle, SRP)

앞서 SOLID 원칙을 간단히 언급한 바 있습니다. SOLID는 하나의 원칙이 아니라 다섯 가지 설계 원칙을 모아둔 용어입니다. 여기에는 단일 책임 원칙, 개방 폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존 역전 원칙이 포함되어 있습니다. 지금부터는 SOLID의 첫 번째 원칙인 단일 책임 원칙을 깊이 있게 알아보겠습니다.

#### 단일 책임 원칙의 정의와 해석

단일 책임 원칙은 간단히 말하면 “하나의 클래스나 모듈이 오직 하나의 책임이나 기능만을 수행해야 한다”는 원칙입니다. 여기서 중요한 점은 클래스와 모듈이라는 두 가지 개념을 모두 다룬다는 것입니다. 이 개념에 대해서는 두 가지 해석이 가능합니다.

* 하나는 모듈이 클래스보다 더 추상적인 개념이고 클래스도 모듈의 일종으로 보는 것입니다.
* 다른 하나는 여러 클래스가 하나의 모듈을 구성한다고 보는 것입니다.

이 두 가지 해석 중 어느 쪽을 따르든, 원칙적으로 클래스나 모듈은 명확히 정의된 단일한 책임만 수행하도록 설계되어야 합니다.

예를 들어 하나의 클래스가 사용자 관리 기능과 주문 처리 기능을 동시에 담당한다면, 이는 두 개의 독립된 클래스(사용자 클래스와 주문 클래스)로 나누어야 합니다. 이렇게 해야 코드의 복잡성을 줄이고 유지 보수를 용이하게 할 수 있습니다.

***

#### 클래스의 단일 책임 여부를 판단하는 방법

클래스가 정말 단일 책임 원칙을 충족하는지 판단하는 일은 쉽지 않습니다. 다음과 같은 예시를 통해 실제로 어떻게 판단할 수 있는지 알아보겠습니다.

다음과 같은 사용자 정보를 관리하는 클래스 `UserInfo`가 있다고 생각해 봅시다.

```java
public class UserInfo {
    private long userId;
    private String username;
    private String email;
    private String telephone;
    private long createTime;
    private long lastLoginTime;
    private String avatarUrl;
    private String provinceOfAddress;
    private String cityOfAddress;
    private String regionOfAddress;
    private String detailedAddress;
    // 기타 메서드 생략
}
```

이 클래스는 두 가지 관점에서 평가할 수 있습니다.

* 한편으로는 모든 정보가 사용자라는 비즈니스 모델과 관련된 것이므로 단일 책임을 충족한다고 볼 수 있습니다.
* 다른 한편으로는 주소 정보가 상당한 비중을 차지하므로, 이를 별도의 `UserAddress` 클래스로 분리하는 것이 더 좋다는 의견도 있습니다.

이때 어떤 의견이 맞는지 결정하려면 실제 비즈니스 상황을 고려해야 합니다. 만약 주소 정보가 단순히 사용자 정보를 표시하는 데만 사용된다면 현 설계도 충분히 괜찮습니다. 하지만 이 서비스가 발전하여 전자상거래 같은 추가 기능이 들어가고 주소 정보가 독립적인 배송 로직에 활용될 수 있다면, 이를 별도의 클래스로 분리하는 것이 바람직합니다.

즉, 단일 책임 원칙은 상황과 요구사항에 따라 다르게 판단될 수 있습니다. 처음에는 거친 형태로 설계되었다가 비즈니스가 점점 발전하면서 클래스가 복잡해지면, 이를 작은 단위로 세분화하는 방식이 일반적입니다.

***

#### 클래스 분할 여부를 결정하는 기준

단일 책임 원칙을 적용하여 클래스를 분할할지 결정할 때 다음과 같은 기준들을 참고할 수 있습니다.

* 클래스에 너무 많은 코드와 메서드가 있어서 가독성과 유지 보수에 어려움이 있는 경우
* 클래스가 지나치게 다른 클래스에 의존하여 결합도가 높아지는 경우
* 클래스에 private 메서드가 너무 많아 재사용성이 떨어지는 경우 (이때 private 메서드를 별도의 클래스로 분리하고 public으로 전환)
* 클래스의 이름을 정확히 정의하기 어렵거나 일반적인 단어(Manager, Context 등)를 사용하는 경우 (책임이 명확하지 않다는 신호)
* 클래스의 특정 속성과 메서드들이 강하게 결합되어 있고 나머지 속성들과 무관한 경우

이러한 기준들을 통해 클래스가 단일 책임 원칙을 충족하는지 판단하고 적절히 분할하여 관리하면 더욱 좋은 코드 품질을 유지할 수 있습니다.

***

#### 지나친 클래스 분할의 문제와 균형 잡기

클래스를 너무 잘게 나누는 것도 항상 바람직한 것은 아닙니다. 다음과 같은 직렬화와 역직렬화 기능을 가진 클래스 `Serialization`의 예를 보겠습니다.

```java
public class Serialization {
    private static final String IDENTIFIER_STRING = "UEUEUE;";
    private Gson gson = new Gson();

    public String serialize(Map<String, String> object) {
        return IDENTIFIER_STRING + gson.toJson(object);
    }

    public Map<String, String> deserialize(String text) {
        if (!text.startsWith(IDENTIFIER_STRING)) return Collections.emptyMap();
        String json = text.substring(IDENTIFIER_STRING.length());
        return gson.fromJson(json, Map.class);
    }
}
```

이 클래스의 직렬화와 역직렬화를 각각 `Serializer`와 `Deserializer` 클래스로 나누면, 나중에 수정이 필요할 때 항상 두 클래스를 함께 수정해야 하는 부담이 생깁니다. 이런 경우에는 오히려 하나의 클래스로 유지하면서 인터페이스를 사용해 책임을 나누는 것이 더 효율적입니다.

예를 들어, 하나의 클래스에서 두 개의 인터페이스를 구현해 외부 클래스가 필요한 인터페이스만 참조하도록 하면, 불필요한 기능에 대한 접근을 제한하고 LoD(디미터 법칙)를 위반하지 않으면서도 코드의 응집력을 유지할 수 있습니다.

설계 원칙을 적용할 때는 절대적인 정답이 없으며, 실제 상황과 비즈니스 필요에 따라 유연하게 결정해야 합니다. 지나친 설계를 피하고, 상황에 맞는 적절한 균형을 찾는 것이 중요합니다.

***

#### 주요 설계 원칙들의 차이점

마지막으로 이번 장에서 다룬 SOLID, KISS, YAGNI, DRY, LoD 설계 원칙의 핵심적인 차이를 정리해보면 다음과 같습니다.

* **SOLID**: 객체지향 설계의 핵심적인 5가지 원칙을 모아둔 개념 (책임 분리, 확장성 유지, 대체 가능성, 인터페이스 분리, 의존성 역전)
* **KISS**: 코드 설계를 단순하게 유지하는 원칙으로, 불필요한 복잡성을 피하는 것을 강조합니다.
* **YAGNI**: 실제로 필요할 때까지는 기능이나 구조를 미리 만들지 말라는 원칙입니다.
* **DRY**: 중복된 코드나 로직을 피하고 코드의 재사용성을 높이라는 원칙입니다.
* **LoD (디미터 법칙)**: 클래스 간의 결합도를 낮추고, 클래스가 반드시 알아야 하는 정보와만 상호작용해야 한다는 원칙입니다.
