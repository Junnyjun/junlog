# 프로세스

프로세스는 하나의 작업 단위이다. 프로그램을 실행하면 프로세스가 된다.

폰노이만 구조에서는 프로세스가 실행된다는 것은 메모리에 올라와서 작업이 진행된다는 의미를 가진다.

**일괄 작업 방식**에서는 한번에 하나의 프로세스만 처리한다. **시분할 방식**에서는 CPU의 시간을 쪼개서 여러 프로세스에 배분한다.

프로세스가 된다는것은 PCB `프로세스 제어 블록`을 생성한 다는 것이다.

### 프로세스 실행

프로세스는 시스템의 작업 단위로써 `테스크`라고도 불린다. 프로그램을 메모리의 적당한 위치로 가져온다. 동시에 작업 지시의 내용이 담긴 프로세스 제어 블록 PCB가 만들어 진다.

#### 프로세스 제어 블록

🟠 프로세스 구분자 : 메모리에는 여러 개의 프로세스가 존재하므로 각 프로세스를 구분하는 구분자가 필요하다. 🟡 메모리 관련 정보 : CPU는 실행하려는 프로세스가 메모리 어디에 위치하고 있는지 알아야 한다. 메모리 보호를 위한 경계 레지스터, 한계 레지스터도 포함되어 있다. 🟢 각종 중간값 : 프로세스의 중간값이 저장된다.

하나의 프로세스를 실행 할 때엔 PCB의 구성 요소와 프로그램 카운터 각종 레지스터등을 관리해야 한다. PCB는 운영체제가 프로세스를 위해 관리하는 데이터 구조이기 때문에 운영체제 영역에 만들어 진다. 프로세스와 PCB는 같은 생명 주기를 가진다.

#### 프로세스의 상태

`일괄 작업 시스템`의 상태는 생성,실행,완료 만 가진다.

`시분할 시스템`에서의 프로세스 상태는 조금 더 세분화 되어있다. CPU를 프로세스가 나눠서 사용하기 때문이다

```
생성 상태 : 프로세스가 메모리에 올라와 준비를 완료한 상태이다. PCB가 생성되며, 실행 순서가 정해진다.

준비 상태 : 프로세스가 CPU의 작업을 기다리는 상태이다.
준비 큐에서 실행을 대기한다.

실행 상태 : CPU를 어덩 실제 작업을 수행하는 상태이다.

대기 상태 : 입출력 관리자의 응답을 길다리는 상태이다. 입출력이 완료되면 인터럽트가 발생되어 프로세스가 준비상태로 변경된다.

완료 상태 : 작업이 완료된 상태이며 PCB가 삭제된다.

휴식 상태 : 프로세스가 작업을 일시적으로 쉬고 있는 상태이다.

보류 상태 : 메모리에서 쫓겨난 상태이다. 일시 정지 상태라고 불리며, 스왑영역에 저장된다.
```

다음에 실행할 프로세스는 CPU 스케줄러에 의해 결정된다. CPU 스케줄러에 의해 실행되는 작업을 `디스패치`라고 한다. 또한, CPU에 할당된 작업시간을 타임 슬라이스 , 타임 퀀텀 이라고 부르는데 이 시간동안 작업을 끝내지 못하면 다시 준비 상태로 돌아가는데 이를 `타임아웃` 이라고 한다.

***

### 프로세스 제어 블록

중요한 정보를 보관하는 자료구조 TCB라고 한다. 모든 프로세스는 고유의 프로세스 제어 블록을 가지고 있으며, 프로세스 생성 시 만들어지고 실행을 완료 후 폐기 된다.

#### PCB의 구성

![](https://velog.velcdn.com/images/junny8643/post/95c13924-177c-4fdc-9bda-e842df6ce741/image.png)

```
포인터 : PCB의 첫 번쨰 블록에 저장된다. 준비&대기 상태의 큐를 구현할 때 이용한다
프로세스 상태 : 프로세스 상태를 저장한다 
프로세스 구분자 : 운영체제 내의 프로세스를 구별한다
프로그램 카운터 : 다음에 실행될 명령어의 위치를 가리키는 값
프로세스 우선순위 : 프로세스를 실행 상태로 옮길 순서를 정한다.
각종 레지스터 정보 : 프로세스가 실행되는 중에 사용하던 레지스터의 값 저장
메모리 관리 정보 : 프로세스가 메모리의 어디에 있는지 나타내는 메모리 위치 정보, 경계 레지스터값과 한계 레지스터값이 저장된다
할당된 자원 정보 : 입출력 자원이나 입출력 장치관리자의 정보이다
계정 정보 : 계정 번호, CPU 할당 시간, CPU 사용 시간
부모&자식 프로세스 구분자 : PID , PPID의 정보가 저장된다
```

**💭 포인터**

입출력이 완료되기를 기다리는 프로세스는 대기 상태로 모인다.

같은 종류의 입출력을 기다리는 프로세스를 모아놓게 된다면 관리하기가 용이하다. 대기 큐에서 완료 인터럽트가 오면, PCB를 준비 상태로 바꾼 후 , 장치관리자의 큐에서 제거한다

#### 문맥 교환

CPU를 차지하던 프로세스가 나가고 새로운 프레스르르 받아들이는 작업이다. 양쪽의 PCB가 뒤 바뀌게 되며, 실행상태에서 나가는 PCB는 작업내용을 저장하고 들어오는 PCB의 내용으로 CPU가 다시 세팅된다.

**💭 문맥 교환 방식**

실행 상태의 프로세스 P1 의 타임아웃이 발생하면 ▶ P1의 PCB에 작업 결과가 저장되고 ▶ 준비상태로 바뀐다 ▶ P2 가 실행상태로 바뀌며 CPU의 레지스터가 P2의 PCB로 채워지고 ▶ 작업을 진행한다.

문맥 교환은 타임아웃, 인터럽트 시 발생한다.

***

### 프로세스 연산

프로세스는 코드 영역, 데이터 영역, 스택 영역으로 구성되어 있다.

📗 코드 영역 프로그램의 텍스트가 기술되어 있다. 작성된 프로그램은 코드 영역에 탑재되어 읽기 전용으로 처리된다.

📘 데이터 영역 코드가 실행되면서 사용하는 변수, 파일 각종 데이터가 저장되어 있다. 읽기&쓰기가 가능하다

📙 스택 영역 프로세스를 실행하기 위해 부수적으로 필요한 데이터를 모아놓은 곳이다.

#### 생성과 복사

프로그램이 실행 되면 운영체제는 프로그램을 메모리에 올린 후, 코드영역에 넣고 PCB를 생성한다. 그후, 메모리에 데이터 영역과 스택 영역을 확보한 후, 프로세스를 실행한다.

**💭 fork()**

`fork()` 는 실행 중인 프로세스로 부터 새로운 프로세스를 복사하는 함수이다. 일종의 시스템 호출이며, 실행중인 프로세스와 똑같은 프로세스가 하나 더 만들어지게 된다.

**💭 fork() 동작 과정**

PCB을 부모 프로세스 영역의 대부분이 자식프로세스에 복사되어 똑같은 프로세스를 생성한다.

```
프로세스의 생성 속도가 빠르다
자원을 바로 상속할 수 있다
시스템 관리를 효율적 으로 할 수있다
```

PID, 메모리 위치, PPID & CPID 만 서로 다르다.

**💭 exec()**

기존의 프로세스를 새로운 프로세스로 전환하는 함수 이미 만들어진 PCB , 메모리, PPID-CPID 관계를 그대로 사용할 수 있다.

**💭 exec() 동작 과정**

코드영역에 있는 기존의 내용을 지운뒤 새로운 코드로 바꾼다. 데이터 영역이 새로운 변수로 채워지고 스택 영역이 리셋 된다. PCB의 각종 레지스터와 파일 정보는 전부 리셋된다

***

### 스레드

코드와 데이터를 메모리에 가져오고 PCB를 생성하고 작업에 필요한 메모리 영역을 확보한 후, 프로세스를 준비 큐에 삽입한다. 프로세스가 생성되면 CPU 스케줄러는 프로세스가 해야할 일을 전달한다

**💭 프로세스**

하나의 큰 작업 단위이다, 쓰레드를 이뤄 프로세스를 만든다

**💭 스레드**

프로세스가 CPU에 작업 요청을 하는 하나의 실행 단위이다.

#### 종류

**💭 멀티 스레드**

프로세스 내 작업을 여러 스레드로 분할함으로써 작업의 부담을 줄인다

**💭 멀티 태스킹**

CPU에 작업을 줄 때 시간을 잘게 나누어 배분하는 기법이다. 시분할 시스템에서 사용하는 방식이다

**💭 멀티 프로세싱**

CPU를 여러 개 사용하여 여러 스레드를 동시에 처리하는 작업 환경이다.

**💭 CPU 멀티 스레드**

한번에 하나씩 처리해야 하는 스레드를 파이프라인 기법을 이용하여 동시에 여러 스레드를 처리하도록 만든 기법

#### 스레드 구조

`fork()` - `exec()` 구조는 낭비 요소가 많다. 코드 영역과 데이터 영역의 일부만 메모리에 중복되어 존재하여 제거할 수 없는 낭비 요소가 생긴다 이런 멀티태스킹의 낭비요소를 제거하기 위해 `스레드`를 사용한다. 코드, 데이터를 공유하며 여러 개의 일을 하나의 프로세스에서 하는 것이다

프로세스는 정적인 영역과 동적인 영역으로 구분되는데, 정적인 영역은 바뀌지 않는 영역이고, 동적인 영역은 레지스터값, 스택, 힙 처럼 바뀌는 영역이다.

**💭 장점**

🔴 응답성 향상 : 입출력으로 인해 작업이 진행되지 않아도 다른 스레드가 작업을 계속하여 사용자의 작업 요구에 응답한다. 🟠 자원 공유 : 독립적인 스레드를 생성하면 프로세스가 가진 자원을 모든 스레드가 공유하게 되어 작업을 원할하게 진행 🟡 효율성 향상 : 여러 개의 프로세스를 생성하는 것과 달리 멀티스레드는 불필요한 자원의 중복을 막는다. 🟢 다중 CPU 지원 : 프로세스 작업이 분할되어 처리시간이 단축 된다

**💭 단점**

독립적인 프로세스가 아니기 때문에 문제가 생겼을 때, 전부 종료된다

#### 멀티 스레드 모델

`커널 스레드` : 커널이 직접 관리 `사용자 스레드` : 라이브러리에 의해 구현되었다

**💭 사용자 스레드**

운영 체제가 멀티 스레드를 지원하지 않는 경우 사용, 사용자층 에서 구현하기 때문에 라이브러리를 사용한다. 프로세스의 여러 스레드가 하나의 커널과 연결된다 `1 to N`

**💭 커널 스레드**

하나의 사용자 스레드가 하나의 커널 스레드와 연결된다 `1 to 1` 독립적으로 스케쥴링이 되기 때문에, 다른 스레드가 멈추지 않는다.

**💭 멀티레벨 스레드**

사용자 스레드와 커널스레드를 혼합한 방식 이다 `M to N` 사용자&커널 스레드가 혼용된 방식으로 필요한 부분에 유연하게 처리할 수 있다.

***

### 동적 할당 영역

스택 영역과 힙 영역은 프로세스가 실행되는 동안 만들어 지는 영역 이므로, 크기가 늘거나 줄거나 한다.

🔴 스택 함수 호출과 복귀 시 스택이 사용된다. 변수 사용 범위에 영향을 미치는 영역을 구현할 때 사용된다. 스택은 FILO 구조이다. 🟡 힙 동적으로 할당되는 변수 영역이다
