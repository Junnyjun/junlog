# 컴퓨터 구성

## 하드웨어 구성

컴퓨터는 CPU, MEMORY, 입/출력 장치로 구성된다.

📗 CPU와 메모리 명령어를 해석하여 실행하는 장치, 메모리는 작업에 필요한 프로그램과 데이터를 저장하는 장소

📘 입출력장치 외부의 데이터를 컴퓨터에 입력하는 장치

📙 저장 장치 데이터를 반영구적으로 저장한다.

📕 메인 보드 컴퓨터의 부품은 버스로 연결되는데, 메인보드는 이 부품들을 연결하는 판이다

### 폰노이만 구조

CPU - MEMORY - I/O 장치 - 저장장치 가 버스로 연결되어 있는 구조이다. 가장 중요한 특징은, 모든 프로그램은 메모리에 올라와야 실행 가능하다 라는 것이다.

```
하드웨어 용어

클록 : CPU의 속도 단위
헤르츠 : 클록의 실행 단위인 클록틱이 발생하는 속도이다

시스템 버스 (FSB) : 전면 버스라고 불리며 메모리와 주변장치를 연결하는 버스 이다
CPU 내부 버스 (BSB) : 후면 버스라고 불리며 CPU 내부의 장치를 연결한다.
```

***

### CPU와 메모리

CPU는 산술논리 연산장치, 제어장치, 레지스터로 구성되며 협업하여 작업을 처리한다.

📗 산술 논리 연산장치 CPU에서 데이터를 연산하는 장치이다 산술(+,-,/,\* )연산과 논리(AND, OR)의 연산을 수행한다.

📘 제어 장치 CPU에서 작업을 지시하는 부분이다

📙 레지스터 CPU내에 데이터를 임시로 보관하는 곳이다

#### 💡 레지스터의 종류

CPU는 필요한 데이터를 메모리에서 가져와 레지스터에 저장하고 산술논리 연산장치를 이용하여 연산을 한 후, 결과를 레지스터에 저장한뒤 메모리에 옮긴다.

**사용자 가시 레지스터**

🔴 데이터 레지스터 (DR) : 메모리에서 가져온 데이터를 임시로 보관할 때 사용한다. 🟠 주소 레지스터 (AR) : 데이터 또는 명령어가 저장된 메모리의 주소 저장된다.

사용자 불가시 레지스터

🟡 프로그램 카운터 (PC) : CPU는 어떤 명령어를 처리해야 할지 알아야 한다. 다음에 실행할 명령어의 주소를 기억하고 있다가 제어장치에 알려준다.

🟢 명령어 레지스터 (IR) : 실행중인 명령어를 저장한다 제어장치는 명령어 레지스터에 있는 명령어를 해석한 후 외부장치에 제어신호를 보낸다

🔵 메모리 주소 레지스터 (MAR) : 데이터를 가져오거나 데이터를 보낼때 사용한다. 명령어를 처리하는 과정에서 필요한 메모리 주소를 넣으면 메모리 관리자가 데이터를 가져오거나 저장한다.

🟣 메모리 버퍼 레지스터 (MBR) : 메모리의 데이터를 임시로 저장한다

```
`PC`가 명령어를 제어장치에 전송한다.
제어장치가 명령어 레지스터에 데이터 신호를 보낸다
메모리의 데이터를 메모리 버퍼 레지스터로 가져온다
```

#### 💡 버스의 종류

CPU와 MEMORY, 주변장치 간에 데이터를 주고받을 때 사용한다.

**📗 제어버스**

어떤 작업을 할건지 지시하는 제어 신호가 오간다. 데이터를 가져오거나, 데이터를 저장하는 지시 정보가 오고간다.

**📘 주소버스**

메모리를 읽거나 쓸 때, 어느 위치에서 작업할 것인지 알려주는 위치 정보가 오간다. 주소 버스는 메모리 주소 레지스터와 연결되어 있으며 단방향이다.

**📙 비휘발성 메모리**

플래시 메모리, fram, pram등이 있다.

***

#### 💡 메모리 보호

일괄 작업 시스템에서는 메모리가 운영체제 영역과 사용자 영역으로 구분 된다. 메모리를 보호하기 위해 CPU는 현재 진행중인 작업의 메모리 시작 주소를 경계 레지스터에 저장한 후 작업 한다.

**부팅**

운영체제를 메모리에 올리는 과정을 말한다.

ROM에 저장된 바이오스가 실행 되면서, CPU 메모리 IO등 주요 하드웨어의 작동을 검사한다

그후, 마스터 부트 레코드에 저장된 프로그램을 실행한다. 부트스트랩이 메모리에 올라오면 하드디스크에 있는 운영체제를 메모리로 불러온다.

```
마스터 부트 레코드는 하드디스크의 첫번째 섹터이다.
운영체제를 실행하기 위한 코드인 부트스트랩이 저장되어 있다.
```

***

### 컴퓨터 성능 향상 기술

CPU와 메모리, 하드디스크의 속도 차이를 개선하고 작업 속도를 올리기 위해 개발된 기술중 운영체제의 기술을 설명한다.

#### 🌈 버퍼

버퍼는 속도에 차이가 있는 두 장치에서 차이를 완화 시켜준다 일정량의 데이터를 모아서 옮김으로써, 속도의 차이를 완화 시켜준다.

**스플**

버퍼와 유사한 동작을 하는 기능으로, 스플은 CPU와 입출력장치가 독립적으로 동작하도록 고안된 `소프트웨어 버퍼`이다 대표적으로 프린터가 있는데, 출력명령과 독립적으로 동작한다.

#### 캐시

메모리와 CPU간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 저장해두는 임시 장소이다. 버퍼의 일종으로 CPU가 사용할것으로 예상되는 데이터를 `prefetch`한다.

캐시는 메모리의 내용중 일부를 미리 가져오고 메모리에 접근전 캐시를 먼저 뒤져서 데이터를 찾는다. 데이터를 찾으면 `캐시 히트`가 되어 바로사용하고 데이터를 찾지 못하면 `캐시 미스`가 되어 메모리를 찾는다.

**즉시&지연 쓰기**

캐시에 데이터가 변경되는 경우 반영해야 되는 문제가 존재한다.

🔴 즉시 쓰기 캐시의 데이터가 변경되면 이를 즉시 메모리에 반영되는 방식이다. 🟠 지연 쓰기 주기적으로 변경된 내용을 반영하는 copy back 방식이다.

**L1 & L2 캐시**

캐시는 명령어와 데이터의 구분을 두지 않는 `일반 캐시`와 구분하는 `특수 캐시`가 존재한다.

명령어 캐시& 데이터 캐시는 CPU 레지스터에 직접 연결 되는 `L1캐시`이며 일반 캐시는 메모리와 연결되는 `L2캐시`이다

#### 저장 장치의 계층 구조

계층구조를 활용하면 CPU와 가까운쪽에 레지스터나 캐시를 활용하여 CPU의 작업속도를 지연시키지 않을 수 있다. 메모리에서 작업한 내용을 저렴한 하드디스크에 저장할 수 있게 한다.

저장장치의 계층 구조는 데이터의 일관성의 문제가 생길 수 있음에 주의해야 한다.

#### 인터럽트

CPU작업과 저장장치의 데이터 이동을 독립적으로 운영함 으로써, 데이터 입출력이 일어나는 동안 CPU가 다른일을 처리하는 방식이다.

**동작 과정**

입출력 관리자가 CPU에 보내는 완료 신호를 인터럽트라고 한다. 하던 작업을 중단하고 처리해야 하는 신호라는 의미이다

```
CPU가 입출력 관리자에게 입출력 명령을 보낸다
명령받은 데이터를 메모리에 가져다 놓거나, 메모리의 데이터를 저장장치로 옮긴다.
데이터 전송이 완료되면 완료 신호를 CPU에 보낸다
```

인터럽트 방식에는 어떤 저장장치의 작업이 끝낫는지를 `인터 럽트 번호`로 알려준다. 여러개의 인터럽트를 하나의 배열로 만든 인터럽트 배열인 `터럽트 벡터` 잦은 인터럽트를 방지한다

**직접 메모리 접근**

CPU는 입출력이 필요할 때 입출력 관리자에게 요청을 보내고 하던일을 계속하게 된다. 메모리는 CPU만 접근 권한을 가진 공간 이기 때문에 입출력 관리자가 접근하지 못하여 직접 메모리 접근`DMA` 라는 공간을 제공한다.

**메모리 매핑 입출력**

DMA는 인터럽트 방식의 시스템을 구성하는 중요한 요소이다. CPU가 사용하는 메모리 공간과 DMA가 사용하는 공간을 분리하면서, 데이터가 섞여 관리하기 복잡해짐을 방지하였는데, 메모리의 일정 부분을 입출력에 할당하는 기법을 메모리 매핑 입출력 `MMIO` 라고 한다

#### 사이클 훔치기

두 장치가 동시에 메모리에 접근하게 되면 대부분 CPU는 권한을 양보하는데 이러한 상황을 `cycle stealing`이라고 한다.

***

### 병렬 처리

CPU를 5GHz를 넘게 만드는 기술은 개발하기 어렵기 때문에 동시에 실행 가능한 명령의 수를 늘리는 방법을 사용했다.

`병렬 처리`는 동시에 여러 개의 명령을 처리하는 방식이다. 여러개의 스레드로 작업을 처리하는 방식을 `파이프 라인 기법`이라고 부르는데, 이 스레드는 CPU가 처리할 수 있는 하나의 작업 단위를 나타낸다.

#### 병렬 처리 기법

CPU내에서 명령어는 제어장치가 처리한다. 제어장치는 명령어를 가져와 해석 후, 실행&결과 저장하는 과정을 반복한다.

```
병렬 처리 주의 사항
- 상호 의존성이 없어야 한다.
- 스레드의 시간을 일정하게 맞춰야 한다
```

CPU 에서 명령을 실행하는 과정은 크게 4단계인데.

```
명령어 패치 : 다음에 실행할 명령어를 레지스터에 저장 
명령어 해석 : 명령어 해석
실행 : 명령어 실행 
쓰기 : 결과 처리
```

이러한 처리는 크게 `파이프라인` 기법과 `슈퍼 스칼라` 기법으로 나뉘어 진다.

**파이프라인**

하나의 코어에 여러 스레드를 사용하는 방식이다. 명령어를 여러 단계로 분할 후 각 단계까 명령어를 처리할 수 있도록 한다.

💭 문제점 🔴 데이터 위험 : 데이터 의존성 떄문에 발생한다. 후에 실행되는 명령어가 앞의 데이터를 필요로 할때 생기는데, 명령어 단계를 지연하여 해결한다.

🟠 제어 위험 : 분기 처리시, 프로그램 카운터 값을 변화시켜 발생하는 문제이다. 분기 예측이나 분기 지연 방법으로, 나열된 명령어가 필요없어 지는 경우를 방지한다.

🟡 구조 위험 : 서로 다른 명령어가 하나의 자원에 접근하려 할 때 발생한다.

**슈퍼 스칼라**

파이프라인을 처리할 수 있는 코어를 여러개 구성하여 복수의 명령어가 동시에 실행되게 한다.
