# 인프라를 지탱하는 응용 이론

## 캐시(Cache)

캐시는 사용 빈도가 높은 데이터를 고속으로 액세스할 수 있는 위치에 두는 것을 의미한다.&#x20;

CPU의 1차 캐시나 2차 캐시, 저장소 캐시, OS 페이지 캐시, 데이터베이스 버퍼 캐시 등 광범위하게 캐시 기술이 사용되고 있다.

### 특징

일부 데이터를 데이터 출력 위치와 가까운 지점에 일시적으로 저장한다.\
데이터 재사용을 전제로 한다.

### 어디에 사용되나?

#### 브라우저 캐시

웹 브라우저가 접속한 페이지를 캐싱

웹 서버 접속을 줄이고 브라우저 표시를 고속화할 수 있다.

#### 웹 서버와 클라이언트 사이에 캐시 서버 배치

웹 서버 자체 부하를 줄임

캐시 서버 대신 CDN(Content Delivery Network)라는 다른 네트워크에 웹 콘텐츠 캐시를 배치하는 구조를 이용하기도 함

### 정리

#### 캐시의 주요 장점은 다음과 같다.

데이터를 고속으로 액세스할 수 있다.

실제 데이터에 대한 액세스 부하를 줄일 수 있다.

#### 적합한 시스템

참조 빈도가 높은 데이터

캐시의 데이터가 손실돼도 문제가 없는 시스템

#### 주의할 점은 다음과 같다.

데이터가 실제 데이터와 캐시라는 이중 구조로 저장되기 때문에 리소스 소비가 늘어난다.\
시스템 가동 직후 등에는 캐시 데이터가 없기 때문에 원하는 성능이 나오지 않을 수 있다.

캐시 계층이 늘어나기 때문에 시스템 성능 문제나 데이터 불일치 문제가 발생한 경우는 문제 발생을 야기한 용의자가 늘어난다.

캐시의 데이터가 손실되는 경우를 대비해서 복구 순서를 설계 시에 확립해야 한다.\
갱신 데이터를 캐시할 때 캐시가 여러 개 있으면 갱신된 최신 데이터를 서로 뺏으려는 상태가 \
발생하지 않도록 주의해야 한다.

#### 부적합한 시스템

데이터 갱신 빈도가 높은 시스템\
대량의 데이터에 액세스하는 시스템

## 끼어들기(Interupt)

어떤 원인으로 인해 지금 하고 있는 일을 중단하고 급히 다른 일을 하는 것을 끼어들기라고 한다. \
급한 일을 먼저 하도록 CPU에 알리는 중요한 역할을 한다.

### 특징

끼어들기는 급한 일이 생겨서 지금 진행 중인 일을 중단하고 급한 일을 끝낸 후에 \
다시 원래 일을 진행하는것

구체적으로는 키보드 입력 등의 특정 이벤트가 발생했을 때 CPU에 이것을 알려서 해당 이벤트에 대응하는 처리를 끝낸 후 원래 하던 처리를 계속하는 것

### 어디에 사용되나?

입출력 장치가 CPU에게 통지하는 하드웨어 끼어들기\
네트워크 통신으로 데이터가 도착하면 발생하는 네트워크 끼어들기

프로세스나 스레드가 허가되지 않은 메모리 위치에 액세스 시 발생하는 `‘조각화(segmentation) 위반`' \
예외 발생으로 인해 OS가 프로세스를 강제 종료하는 것 역시 끼어들기 일종

### 정리

끼어들기는 어떤 일이 발생하면 연락하는 이벤트 주도 구조다.

반면 CPU가 정기적으로 폴링(pollinnng)을 해서 입출력 장치 상태를 확인하는 방법도 있지만, \
폴링 간격이 길면 디스크 I/O가 완료됐더라도 금방 알아차리지 못한다.

반대로 폴링 간격이 짧으면 CPU를 쓸데 없이 많이 사용하게 된다.\
CPU 동작 속도에 비해 입출력 장치의 상태 갱신 빈도가 높지 않다면 폴링보다 끼어들기를 \
이용해서 제어하는 것이 효율적

## 폴링(Polling)

폴링은 정기적으로 질의하는 것을 가리킨다. 정기적으로 질의함으로써 상대가 어떤 상태인지, \
어떤 요구를 가지고 있는지 등을 알 수 있다.

### 특징

질의 방향이 단방향이다.\
질의는 일정 간격을 따라 정기적으로 발생한다.

### 폴링의 주요 장점

반복(루프)만 하면 되기에 프로그래밍이 쉽다.\
상대가 응답하는지 확인할 수 있다.\
모아서 일괄적으로 처리할 수 있다.

→ 폴링과 반대되는 것이 이벤트 주도 또는 끼어들기 방식이다. 이것은 요구가 있을 때만 처리하는 구조다.

#### 주의 사항

네트워크를 경유한 폴링일 때는 처리 지연 시간을 줄이기 위해서 폴링 간격을 너무 짧게 잡으면 \
트래픽 양이 증가하므로 주의가 필요하다. \
또한, 서버의 리소스 소비도 늘어난다.

### 정리

#### 적합한 처리

일정 간격으로 처리를 실행하면 좋은 처리\
감시 (컴포넌트가 자발적으로 상태를 전달할 수 없는 경우)

#### 부적합한 처리

상태가 아닌 입력 내용에 따라 실행 내용을 변경하는 처리\
처리 우선순위를 정해야 하는 처리

## I/O 크기

I/O 크기란 1회의 I/O에 필요한 사이즈, 즉 데이터를 주고 받을 때 사용되는 I/O의 크기를 의미한다. \
인프라 설계나 성능 튜닝에 있어 중요한 개념이다.

### 특징

물건을 운반할 때는 상자에 넣으면 효율적으로 관리할 수 있다.\
운반하는 양에 따라 상자 크기를 선택하면 효율적으로 운반할 수 있다.

### 어디에 사용되나?

#### 오라클 DB

오라클 DB가 데이터 파일을 읽기/쓰기 하는 최소 단위를 데이터 블록이라하고, \
그 크기를 블록 크기라고 한다.

블록 크기가 8KB라면, 1바이트의 데이터를 읽는 경우에도 8KB를 읽어야 한다. \
I/O 크기가 작을 때는 블록 크기를 작게, I/O 크기가 크면 블록 크기를 크게 해야 효율이 좋아진다.

데이터베이스 블록 크기가 OS 블록 크기와 다르면 배수가 되도록 권장한다. \
DB 블록 크기를 파일 시스템 블록 크기의 배수로 설정하면 꽉채워서 사용할 수 있기 때문

#### 네트워크

웹 브라우저가 데이터를 전송할 때는 TCP 세그먼트라는 상자로 분할하여 데이터를 전송한다.

송신 버퍼가 TCP 세그먼트로 분할될 때 MSS(Maximum Segment Size)를 초과하지 않는 범위에서 분할한다.

IP 소켓의 최대 크기를 MTU(Maximum Transfer Unit)라고 하는데, 대량의 데이터를 고속으로 전송해야하는 시스템에서는 소켓 버퍼나 MTU 크기를 튜닝하기도 한다.

### 정리

큰 상자는 대량의 데이터를 빠르게 운반할 수 있다 → 처리량 중시\
작은 상자는 소량의 데이터를 빠르게 운반할 수 있다 → 지연 시간 중시&#x20;

## 저널링

저널(Journal)은 트랜잭션이나 매일 갱신되는 데이터의 변경 이력을 가리킨다. 저널을 남겨 두는 것을 저널링(Jounaling)이라고 한다.&#x20;

저널링은 언제, 어디서, 무엇을 했는지 상세하게 기록해서 시스템 장애가 발생했을 때 어디까지 정상 처리됐는지, 그리고 어디부터 재실행하면 좋을지 알 수 있게 하는 기능이다.

### 특징

데이터 자체가 아닌 처리(트랜잭션) 내용을 기록한다.\
데이터 일관성이나 일치성이 확보되면 필요 없어진다.\
데이터 복구 시 롤백(Rollback), 롤포워드(Rollforward)에 이용된다.

### 어디에 사용되나?

데이터를 처리하는 기능의 대부분은 저널링이 구현돼 있으며, 다른 데이터 보호 구조도 존재한다.

#### 리눅스의 ext3 파일 시스템

ext3 파일 시스템은 저널링 기능을 갖추고 있으며, 파일 I/O도 트랜잭션으로 간주된다.

단, 오라클 DB와 달리 트랜잭션 시에 버퍼 정보를 디스크에 기록하지 않기 때문에 버퍼에 있는 최신 데이터를 잃을 수도 있다.

#### 오라클 DB

오라클 DB의 저널은 REDO 로그라 불린다.

트랜잭션 종료 시(커밋 시)에 버퍼가 디스크에 기록되지만, 기록 중인 REDO 로그가 파손된 경우에는 데이터를 최신 상태로 복원할 수 없다. 이 때문에 오라클 DB에서는 REDO로그를 이중화해서 보호한다.

### 정리

#### 장점

시스템 장애 시 복구가 빠르다.\
데이터 복제보다도 적은 리소스를 소비해서 데이터를 보호할 수 있다.

`적합한 시스템` -> 데이터 갱신이 발생하는 시스템\
`부적합한 시스템` -> 데이터 안정성보다 성능을 요구하는 시스템

#### 저널을 사용한 복구 방식

`롤백` -> 저널을 읽어서 실제 데이터 정보를 과거로 되돌리는 처리\
`롤포워드` ->저널을 읽어서 실제 데이터 정보를 앞으로 진행시키는 처리

### 주의점

저널 데이터는 메모리의 버퍼에 일단 저장됨. 이 정보가 디스크에 기록되지 않으면 장애 시에 잃을 수 있다. 이 때문에 시스템 요건에 따라 버퍼의 디스크 기록 시점을 검토, 조정해야 한다.&#x20;

하지만 기록 빈도가 많으면 오버헤드도 높아지기 때문에 trade-off를 고려해야 함.

저널은 트랜잭션 단위로 일치성을 보증하기 때문에 트랜재션 도중에 장애가 발생하면 종료되지 않은 트랜잭션을 파괴된다.&#x20;

하나의 트랜잭션 단위가 크면 트랜재션 도중에 장애가 발생할 가능성이 높다. \
따라서 트랜잭션이 길어지지 않도록 설계해야 한다.

## 복제

복제(Replication)는 DB나 저장소 등에서 자주 사용되는 기술이다.&#x20;

각종 재해에 대비해서 멀리 떨어진 장소에 데이터 센터를 구축해서 예비 시스템에 데이터를 복제하는 경우, 대량의 사용자 접속에 대비해 동일 데이터를 여러 서버에 복제해서 부하분산을 하는 등 \
복제 목적은 다양하며, 구조도 여러 가지가 있다.

### 특징

장애 시 데이터 손실을 예방할 수 있다.\
복제를 이용한 부하분산이 가능하다.

이러한 특징에 다음과 같은 장점을 얻을 수 있다.

사용자가 데이터에 액세스할 때 복제한 것이라는 것을 의식할 필요가 없다.\
복제 데이터를 캐시처럼 사용할 수 있다.

### 어디에 사용되나?

#### 저장소 복제

블록 단위로 증감 데이터만 복제 위치에 반영해서 데이터 전송량을 줄인다. \
복제 전송량은 실제 갱신 데이터 양에 비례한다.

데이터 보호를 최우선으로 할 때는 쓰기 처리 시 데이터가 복제되기까지 기다리는 모드가 있다.

#### MySQL 복제

MySQL 복제는 데이터 추가, 갱신, 삭제 등의 변경 처리(트랜잭션)를 복제 측으로 보낸다. 실제 데이터 블록을 전송하는 것이 아니기 때문에 복제 데이터 전송량을 줄일 수 있다. 복제 전송량은 트랜잭션 수와 비례한다.

복제를 통해 데이터의 최종 복사본이 다른 곳에 생성되며, 이 복사본을 캐시처럼 사용하거나, 가까운 곳에 있는 복사본을 읽을 수 있으며, 한쪽 서버의 부하가 높다면 다른 쪽에 있는 부하가 낮은 서버에서 복사본을 읽는 방식도 고려할 수 있다.

### 정리

#### 적합한 시스템

데이터 손실을 허용하지 않고 장애 시 복구 속도가 빨라야 하는 시스템\
데이터 참조와 갱신 부분이 나뉘어져 있으며, 참조가 많은 시스템

#### 부적합한 시스템

데이터 갱신이 많은 시스템

#### 주의사항

복제 위치가 많으면 갱신이 많은 시스템과 같이 복제 오버헤드가 높아진다.

실제 데이터와 복제 데이터를 완전히 일치시키고 싶으면 복제 데이터의 쓰기 완료 처리를 보장해야 한다. 이 경우 시스템 응답이 악화될 수 있다.

시스템 유지 관리나 장애 시에는 복제 데이터도 고려해야 하므로 설계나 운용 난이도가 높아질 수 있다.

복제 데이터와 실제 데이터의 차이가 커지면 그 차이를 채우기 위한 시간이나 성능도 고려해야 한다.&#x20;

## 마스터-워커

마스터-워커(Master-Worker)는 주종 관계를 가리킨다. 이 구조에서는 한 명이 관리자가 돼서 다른 모든 것을 제어하게 된다. 반대로, 상호 관리라는 의미에서 피어 투 피어(Peer-to-Peer) 관계도 성립한다.

### 어디에 사용되나?

#### 오라클 Real Application Cluster(RAC)

마스커-워커와 피어 투 피어의 장점만 조합해서 이용

특정 서버가 마스터가 되는 것이 아니라, 모두가 대등한 관계라서 특정 서버가 다운돼더라도 데이터베이스 전체 가용성에는 영향을 주지 않는다.

구체적으로는 데이터를 하나의 물리 서버가 모두 관리하는 것이 아니라, 리소스 단위로 관리 마스터가 달라진다. 물리 서버가 다운된다면 해당 서버가 마스터로 관리하고 있던 리소스는 다른 마스터 서버가 관리하게 된다.

### 정리

#### 마스터-워커의 장점

관리자가 한 명이기 때문에 구현이 쉽다.

워커 간 처리를 동기화할 필요가 없기 때문에 통신량이 줄어든다.

마스터가 없어지면 관리를 할 수 없다(작업 인계 구조가 필요)

마스터의 부하가 높아진다.

## 압축

디지털 데이터는 압축을 할 수 있다. 디지털 데이터에서 교환하는 ‘정보'의 낭비를 막으면 압축을 할 수 있다.&#x20;

낭비되는 정보란 무엇일까? ‘자신에게 필요없는 정보'나 ‘이미 알고 있는 정보'다.

### 특징

디지털 데이터 압축의 기본은 ‘중복 패턴 인식'과 그것을 ‘변경'하는 것이다. 같은 패턴이 많을수록 압축률이 높아진다.

압축을 하는 장점은 데이터 크기를 줄이는 것이고, 단점은 처리 시간이 걸린다는 것이다.

원래 상태로 복구할 수 있는 압축을 가역 압축이라고 하고, 원래 상태로 복구할 수 없지만 압축률이 높은 방식을 비가역 압축이라고 한다.

압축/해제 처리로 인해 리소스 부하가 높아지거나 처리 시간이 증가한다는 단점이 있음&#x20;

## 오류 검출

의도하지 않은 때에 데이터가 망가질 수도 있다. 이것을 방지하기 위해 오류 검출이라 불리는 구조가 있다.

### 원인

#### 통신 중에 데이터 파손

대부분의 통신 방식에는 전기 신호를 이용해서 데이터를 교환하고 있다.\
경로 도중에 낙뢰로 전기적인 잡음 등이 발생하면 데이터가 파손될 수 있다.

#### 칩(chip)에서의 데이터 파손

메모리의 데이터도 전기적으로 전달된다.\
이 때문에 통신 중인 데이터 파손처럼 전기적인 영향으로 값이 바뀌는 경우가 있다.

## 패리티 체크 방식

패리티 비티(Parity Bit)라는 이중화 비트를 부여하는 방식\
비트에서는 반드시 1이라는 수가 짝수 개 또는 홀수 개가 되도록 1비트만 추가한다.

패리티 비트를 설정한 단위의 1비트가지 데이터가 바뀌어도 1이 짝수 개인지 홀수 개인지 확인해서 오류를 검출할 수 있다.

단, 동시에 2비트를 바꿔 버리면 짝수가 반환되기 때문에 오류를 인지할 수 없다.

패리티 방식 외에도 체크섬, CRC 등의 기법이 있다.

### 어디에 사용되나?

#### CPU나 메모리

CPU나 메모리 내부에서는 오류 검출 및 수정 기능을 가지고 있다.

특히 메모리는 여러 개가 있어서 컴퓨터 내부에서도 비교적 에너지 입자의 영향을 받기 쉬운 하드웨어다.\
서버용 메모리에는 오류 수정 기능이 있는 ‘ECC 메모리'라는 것이 있다.

이 메모리에서는 쓰기 처리 시에 패리티 비트 계산을 해서 패리티 정보도 함께 기록한다. 읽을 때는 다시 패리티 계산을 해서 오류가 없는지 검사한다.&#x20;

오류가 있다면 수정 가능한 경우에는 수정을, 불가능한 경우에는 오류만 검출해서 반환한다.

## 네트워크 통신

네트워크 통신에서는 프로토콜에 따라 각 계층의 오류 검출용 구조를 갖추고 있다.

TCP/IP 및 이더넷은 계층별로 체크섬이나 CRC 오류를 검출하는 구조를 도입하고 있다.

오류 검출의 장점은 명칭 그대로 오류를 알 수 있다는 것. 단점으로는 추가 데이터를 부여해야 하므로 데이터 양이 증가하며, 오류 여부를 알기 위한 계산이 필요해서 처리에 오버헤드가 발생한다는 것.&#x20;

또한, 검출뿐만 아니라 파손된 데이터를 바로 수정할 수 있는 ‘오류 수정'이라는 구조도 있다. 오류 수정에선 검출 때보다 많은 추가 데이터를 부여해야 한다.
