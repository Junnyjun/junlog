# 구조적 프로그래밍

### 구조적 프로그래밍 개요

&#x20;

* 1968년 에츠허르 비버 데이크스트라가 발견
* 데이크스트라는 무분별한 점프(goto 문장)는 프로그램 구조에 해롭다는 사실을 제시
* 데이크스트라는 점프들을 if/then/else와 do/while/untill과 같이 더 익숙한 구조로 대체했다.

> 구조적 프로그래밍은 제어흐름 직접적인 전환에 대해 규칙을 부과한다.\
>

&#x20;

### 구조적 프로그래밍

모든 프로그램은 인간의 두뇌로 감당하기에는 너무 많은 세부사항을 담고 있었다.

아주 작은 세부사항이라도 간과하면 프로그램이 동작하는 것처럼 보이더라도 결국엔 예상 외의 방식으로 실패하곤 했다.

&#x20;

데이크스트라는 증명(proof)이라는 수학적인 원리를 적용하여 이 문제를 해결하고자 했다.

그것은 공리, 정리, 따름정리, 보조정리로 구성되는 유클리드 계층구조를 만드는 것이었다.

데이크스트라는 수학자가 유클리드 계층구조를 사용하는 방식을 프로그래머도 사용할 수 있다고 믿었다.

프로그래머는 입증된 구조를 이용하고, 이들 구조를 코드와 결합시키며, 그래서 코드가 올바르다는 사실을 스스로 증명하게 되는 방식이었다.

&#x20;

데이크스트라는 이 연구를 진행하면서 goto 문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견했다.&#x20;

모듈을 분해할 수 없다면 증명에 필수 기법인 분할 정복 접근법을 사용할 수 없게 된다.

&#x20;

goto 문장을 사용하더라도 모듈을 분해할 때 문제가 되지 않는 경우도 있었다.

goto 문의 좋은 사용방식은 if/then/else와 do/while과 같은 분기와 반복이라는 단순한 제어 구조에 해당한다는 사실을 발견했다.

&#x20;

모듈이 이러한 제어 구조만을 사용한다면 증명 가능한 단위로까지 모듈을 재귀적으로 세부화하는 것이 가능해 보였다.

&#x20;

> 뵘과 야코파니는 모든 프로그램을 순차(sequence), 분기(selection), 반복(iteration) 이라는 세 가지 구조만으로 표현할 수 있다는 사실을 증명했다.

### &#x20;

### 기능적 분해

* 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었고, 이는 결국 모듈을 기능적으로 분해할 수 있음을 뜻했다.
* 문제를 고수준의 기능들로 분해할 수 있고, 이들 각 기능은 다시 저수준의 함수들로 분해할 수 있었다.
* 이러하 분해 과정을 끝없이 반복할 수 있다.
* 분해한 기능들은 구조적 프로그래밍의 제한된 제어 구조를 이용하여 표현할 수 있었다.
* 구조적 분석이나 구조적 설계 기법을 사용하면 프로그래머는 대규모 시스템을 모듈과 컴포넌트로 나눌 수 있다.
* 모듈과 컴포넌트는 입증할 수 있는 아주 작은 기능들로 세분화할 수 있다.

### 테스트

> "테스트는 버그가 있음을 보여줄 뿐, 버그가 없음을 보여줄 수는 없다." - 데이크스트라

* 테스트를 통해 프로그램이 잘못되었음을 증명할 수는 있지만, 프로그램이 맞다고 증명할 수는 없다.
* 구조적 프로그래밍은 프로그램을 증명 가능한 세부 기능 집합으로 재귀적으로 분해할 것을 강요한다.
* 구조적 프로그래밍은 테스트를 통해 증명 가능한 세부 기능들이 거짓인지를 증명하려고 시도한다.
* 거짓임을 증명하려는 테스트가 실패한다면, 이 기능들은 목표에 부합할 만큼은 충분히 참이라고 여기게 된다.

&#x20;

### 결론

* 구조적 프로그래밍이 오늘날까지 가치 있는 이유는 프로그래밍에서 반증 가능한 단위(세분화된 기능)를 만들어 낼 수 있는 능력 때문이다.
* 아키텍처 관점에서는 기능적 분해를 최고의 실천법 중 하나로 여기는 이유이기도 하다.
* 소프트웨어 아키텍트는 모듈, 컴포넌트, 서비스가 쉽게 반증 가능하도록(테스트 용이하도록) 만들기 위해 노력해야 한다. 이를 위해 _구조적 프로그래밍과 유사한 제한적인 규칙들을 받아들여 활용해야 한다._
