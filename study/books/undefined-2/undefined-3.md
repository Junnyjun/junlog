# 데이터 전송 기초

### 01 데이터 전송 방식

#### &#x20;1. 전송과 교환

&#x20; \- 컴퓨터 네트워크에는 전송 매체로 연결된 호스트들이 존재하며 송수신 호스트가 데이터를 전달하려면 전송과 교환 과정을 거쳐야 한다.

교환(Switching) : 전송경로가 둘 이상일 때 라우터에서 데이터를 어느 방향으로 전달할지를 선택하는 기능으로 다양한 기준에 따라 데이터를 올바른 경로로 전달할 수 있도록 해준다.

전송(transmission) : 특정한 물리 매체에 의하여 일대일(1:1)로 직접 연결된 두 시스템 간의 신뢰성 있는 전송을 데이터 전송을 보장하기 위한 것.

&#x20;

* 전송 방식의 종류

네트워크를 분류하는 기준은 연결된 호스트의 지리적 분포에 따른 구분(LAN, WAN..)과 데이터 전송 교환 기술(점대점, 브로드캐스팅 방식)로의 분류가 있다.

&#x20;

\-점대점 방식은 호스트 간의 데이터 전달 과정에서 송신 호스트가 중개 호스트와 일대일로 연결되므로 다른 호스트에는 데이터가 전달되지 않는다. WAN에서 주로 사용하고 원거리에 있는 시스템 사이의 통신 방식이다.

&#x20;

\-브로드캐스팅 방식에서는 공유 전송 매체 하나에 여러 호스트를 연결하기 때문에 네트워크에 연결된 모든 호스트에 데이터가 전송된다. 교환 기능이 필요 없지만 자신을 목적지로 하지 않은 데이터를 받은 호스트는 받은 데이터를 버려 하나의 목적지 호스트만 데이터를 수신하도록 해야 한다. 가까운 LAN에서 주로 사용.

&#x20;

#### &#x20;2. 점대점 방식

&#x20;\- 전체 연결 개수가 많아지면 성능 면에서 유리하지만 비용이 많이 들고 연결 개수가 적어지면 네트워크 혼잡도가 증가한다. ex) 스타형, 링형, 완전형, 불규칙형

&#x20;

<figure><img src="https://blog.kakaocdn.net/dn/c1F3R2/btrcQeLTx4s/8S89aSP4m0KFOnabJJ3FYK/img.png" alt=""><figcaption></figcaption></figure>

&#x20; **2.1 스타형**

&#x20; : 중앙에 있는 하나의 중개 호스트 주위로 여러 호스트를 일대일로 연결하는 형태.

&#x20; 주변 호스트가 데이터를 송수신하려면 중앙의 중개 호스트를 거쳐야 하고 이를 확장하면 중앙에 있는 스타 구조

주변에 위치한 호스트들을 중심으로 새로운 스타 구조가 확장되는 형태이다.(트리형)

하지만 중앙 호스트에 문제가 발생하면 전체 네트워크에 영향을 준다.

&#x20;

&#x20;  **2.2 링형**

&#x20; : 호스트의 연결이 순환 고리 구조이며, 전송 데이터가 브로드 캐스팅되는 특징이 있지만 일대일로 직접 연결되기 때문에 점대점 방식에도 포함된다. 송수신 호스트의 거리가 멀수록 중개 호스트의 개수도 증가한다.

여러 호스트가 데이터를 동시에 전송하면 충돌이 발생하는데 토큰이라는 특수한 제어 프레임이 기능을 수행한다.&#x20;

단점은 한 호스트가 고장나면 전체 네트워크가 동작하지 않을 수 있다.

&#x20;

&#x20;  **2.3 완전형**

&#x20; : 네트워크에 존재하는 모든 호스트가 다른 모든 호스트와 일대일로 직접 연결하는 방식으로 교환 기능이 필요 없지만 비용 측면에서 비효율적이다.

&#x20;

&#x20;  **2.4 불규칙형**

&#x20;  : 말 그대로 전송 맻에 의한 연결 구조를 특정 패턴으로 분류할 수 없고 여러 환경 요인에 의해 구조가 결정된다.

&#x20; ex)특정 두 호스트 사이에 통신 트래픽이 많으면 이들을 직접 연결하고 적으면 다른 호스트의 중개 과정을 거쳐서 데이터를 주고받도록 설계함

&#x20;

#### &#x20;3. 브로드캐스팅 방식

&#x20; **3.1 버스형**

&#x20; : 다수의 호스트가 하나의 전송 매체를 공유하므로 전송 데이터를 모든 호스트에서 수신할 수 있지만 둘 이상의 호스트에서 데이터를 동시에 전송하면 데이터 출동이 발생할 수 있다.

&#x20;충돌 해결 첫 번째는 사전에 호스트의 전송 권한을 제한해서 전송 시간대를 분할하여 각 호스트 별로 데이터를 전송할 수 있는 시간대(Time Slice)를 다르게 지정해서 예방할 수 있다.

&#x20;두번째는 충돌 허용으로 공유 버스 방식인 이더넷의 CSMA/CD로 충돌을 해결할 수 있다.

&#x20;

&#x20; **3.2 링형**

&#x20;\- 위의 링형과 같음

#### &#x20;4. 멀티포인트 통신

&#x20;유니포인트(Unipoint) : 송신 호스트를 기준으로 수신 호스트 하나와 연결

&#x20;멀티포인트(Multipoint) :  송신 호스트를 기준으로 다수의 수신 호스트와 연결(1:1, 1:n 모두 지원) 서비스로 원격 교육, 화상 회의 등에 사용

&#x20;유니캐스팅(Unicasting) : 송신 호스트가 한 번의 전송으로 수신 호스트 하나에만 데이터를 전송이며 텔넷, ftp, 웹 검색과 같은 대부분의 서비스는 유니캐스팅 방식을 사용한다.

&#x20;멀티캐스팅(Multicasting) : 송신 호스트가 한 번의 전송으로 다수의 수신 호스트에 전송할 수 있는 경우

&#x20;

&#x20; **4.1 멀티포인트 유니캐스팅(Multipoint Unicasting)**

&#x20; : 유니캐스팅 방식은 두 호스트 사이의 1:1 통신만 지원한다. 그래서 유니캐스팅 방식의 1:다 통신을 하기 위해 사용

&#x20;

<figure><img src="https://blog.kakaocdn.net/dn/dOS92j/btrcNJ6PMpK/qA51qf8be63cl80Kq4QSPk/img.png" alt=""><figcaption></figcaption></figure>

&#x20;\-> a가 다수의 수신 호스트(d, e, f)에 데이터를 전송하려면 각 수신 호스트와 개별적으로 연결을 설정해야 한다.(3개의

연결 설정)

&#x20;

&#x20; **4.2 브로드캐스팅**

&#x20; : 송신 호스트가 전송한 데이터가 네트워크에 연결된 모든 호스트에 전송되는 방식

<figure><img src="https://blog.kakaocdn.net/dn/EaUG2/btrcMESHHt5/CkZekmVBsawfCklakziXs1/img.png" alt=""><figcaption></figcaption></figure>

&#x20;\-> a가 전송한 데이터는 네트워크에 연결된 모든 호스트(b, c, d, e)에 전달, 자신과 일치하지 않는 호스트는 데이터를 받지 않는다.

&#x20; **4.3 멀티캐스팅**

: 멀티캐스팅 방식 자체가 일대다 전송 기능을 구현해 연결 설정 한 번으로 지원 가능.(멀티포인트 유니캐스팅과 비교됨)

&#x20;ex) 화상회의, 인터넷 뉴스, 인터넷 주식..

&#x20;\- 멀티캐스팅 구현 시 그룹을 생성하고 관리하는 기능이 필요.

<figure><img src="https://blog.kakaocdn.net/dn/kCyYW/btrcRo1Vsk4/bw6jMM1BHS9SWdi2x7pEOk/img.png" alt=""><figcaption></figcaption></figure>

### 02 오류 제어

&#x20;\- 2계층에서의 오류 발생 여부 인지(변형, 분실)

#### &#x20;1. 전송 오류의 유형

&#x20; \- 전송 프레임의 오류를 극복하고, 상위 계층에 신뢰성 있는 전송 서비스를 제공하려면 다음과 같은 기본 기능을 이용해 오류 복구 기능을 제공해야 한다.

* 수신 호스트의 응답 프레임

&#x20; \- 송신 호스트가 전송한 데이터 프레임의 일부가 깨지는 프레임 변형 오류를 확인한 수신 호스트는 송신 호스트에 응답 프레임을 전송해 원래의 데이터 프레임을 재전송하도록 요구할 수 있다.

수신 호스트가 전송하는 응답 프레임의 종류에는 데이터 프레임이 정상적으로 도착했을 때 회신하는 긍정 응답 프레임과 데이터 프레임이 깨졌을 때 회신하는 부정 응답 프레임이 있다.&#x20;

&#x20;

* 송신 호스트의 타이머 기능

&#x20; \- 송신 호스트가 전송한 데이터 프레임이 수신 호스트에 도착하지 못하는 분실 오류가 발생하면 수신 호스트는 이 사실을 인지할 수 없으므로 복구 과정이 송신 호스트 주도로 이뤄져야 한다. 일정 시간 이내에 수신 호스트로부터 응답 프레임이 없으면 타임아웃 기능(Timeout)을 동작시켜 데이터 프레임을 재전송한다.

&#x20;

* 순서 번호 기능

&#x20; \- 수신 호스트가 보낸 긍정 응답 프레임을 분실하면 데이터 프레임이 제대로 도착해도 송신 호스트가 이를 인지할 수 없다. 따라서 송신 호스트가 타임아웃 기능에 의해 원래 프레임을 재전송함으로써 수신 호스트가 데이터 프레임을 중복 수신하는 결과를 초래한다. 이때 중복 프레임을 가려내려면 내부에 순서 번호(Sequence Number)를 기록해야 한다.

&#x20; \- 수신 호스트가 데이터 프레임을 올바로 수신하면 송신 호스트에 긍정 응답 프레임을 보냄으로써, 송수신 호스트 사이의 전송이 완결되나 변형 오류가 발생하면 부정 응답 프레임을 회신해 송신 호스트의 재전송 기능에 따라 복구 과정을 진행한다.

&#x20;

&#x20; **1.1 정상적인 전송**

&#x20; : 송신 호스트가 전송한 프레임이 오류 없이 수신 호스트에 전송된 경우다. 제대로 수신됐으면 긍정 응답 프레임을 회신함으로써 완료.

수신받지 못하면 오류가 발생한 것으로 타임아웃 기능에 따라 오류 복구 시작.

<figure><img src="https://blog.kakaocdn.net/dn/b5P15I/btrcMGiR3oa/zITjkn9hifTSyfRwnqFhXk/img.png" alt=""><figcaption></figcaption></figure>

&#x20;

&#x20; **1.2 프레임 변형**

&#x20; : 데이터 프레임이 수신 호스트에 도착했으나 전송 과정에서 프레임의 내용이 변형되는 오류가 발생한 경우다.

&#x20; \- 오류를 인지한 수신 호스트는 송신 호스트에 부정 응답 프레임을 전송함으로써, 원래의 데이터 프레임을 재전송하는 복구 과정이 진행된다.

<figure><img src="https://blog.kakaocdn.net/dn/GUz5L/btrcOd047ke/ijXI2wM0G4RRZkK5sS6n01/img.png" alt=""><figcaption></figcaption></figure>

&#x20;

&#x20; **1.3 프레임 분실**

&#x20; \- 수신 호스트는 송신 호스트로부터 어떠한 데이터 프레임도 전달받지 못했기 때문에 긍정이나 부정응답 프레임을 회신할 수 없고 무한정 기다리게 된다. 그래서 타임아웃 기능에 따라 일정 시간까지 응답이 없으면 재전송한다.

<figure><img src="https://blog.kakaocdn.net/dn/wvTyK/btrcNlrLKbc/A5Mw6RMZu4YMbokKA4ukc1/img.png" alt=""><figcaption></figcaption></figure>

&#x20;&#x20;

#### &#x20;2. 순서 번호

&#x20;: 오류 복구 기능 수행 중 동일한 데이터 프레임이 수신 호스트에 중복해 도착하기 때문에 이를 해결하기 위해 고유 번호인 순서 번호를 기록

&#x20; **2.2 순서 번호에 의한 프레임 구분**

<figure><img src="https://blog.kakaocdn.net/dn/cZoiTI/btrcSsC9VR9/UWrEtD47KDpZ0RqOesr750/img.png" alt=""><figcaption></figcaption></figure>

&#x20; \-> a처럼 프레임이 사라져 재전송해도 수신 호스트는 순서 번호에 근거하여 재전송된 프레임인지 확인할 수 있다.

&#x20;

#### &#x20;3. 흐름 제어(Flow Control)

&#x20;: 오류 제어와 함께 2 계층에서 제공하는 주요 기능은 데이터 프레임의 전송 속도를 조절하는 것으로 송신 호스트는 수신 호스트가 감당할 수 있을 정도의 전송 속도를 유지하면서 데이터 프레임을 전송하는 기능이다.

&#x20;\- 기본 원리는 수신 호스트가 다음에 수신할 데이터 프레임의 전송 시점을 송신 호스트에 통지하는 방식으로 슬라이딩 윈도우 프로토콜(ch06)을 많이 사용한다.

&#x20;

### 03 프레임(Frame)

&#x20;: 2 계층은 전송 데이터를 프레임이라는 작은 단위로 나누어 처리하고 오류를 확인하기 위해 체크섬, 송수신 호스트의 주소, 기타 프로토콜에서 사용하는 제어 코드 같은 정보가 포함된다.

프레임을 전송받은 수신 호스트는 제일 먼저 체크섬을 확인해 전송 중에 프레임 변형이 발생했는지 확인하고 복구과정을 거친다.

#### &#x20;1. 문자 프레임(Character Frame)

&#x20; \- 프레임 내용이 문자로 구성되므로 문자 데이터를 전송할 때 사용한다. 8비트 단위의 고정 크기로 동작한다.

&#x20;  **1.1 프레임의 구조**

&#x20; \- 하나의 프레임 단위를 구분하기 위해 프레임의 앞뒤에 아스키코드의 특수 문자를 이용한다. 즉, 각 프레임의 시작 위치에 DLE/STX 문자를 추가하고, 끝나는 위치에는 DLE/ETX를 추가해 프레임의 다른 정보와 구분할 수 있도록 한다.

<figure><img src="https://blog.kakaocdn.net/dn/ckvB4W/btrcMHozGBs/oVpCwe2dwXVa9et4SGd8P0/img.png" alt=""><figcaption></figcaption></figure>

&#x20;\-> a는 문자 프레임 방식의 프레임 구조로 시작과 끝에 프레임 구분용 특수 문자를 사용.

&#x20; 문제점은 b처럼 데이터의 내용 중 DLE/ETX의 문자가 포함되면 혼선을 줄 수 있다.

(실행파일과 같은 이진 코드 데이터를 전송하는 경우)

&#x20;

&#x20;  **1.2 문자 스터핑(Character Stuffing)**

&#x20;  : 문자 프레임 내부의 전송 데이터에 DLE 문자가 포함되면서 발생하는 혼란을 예방하는 방법.

<figure><img src="https://blog.kakaocdn.net/dn/dy9shK/btrcNl6mUMs/vecSFn06qJqfKxtN6KK1C1/img.png" alt=""><figcaption></figcaption></figure>

&#x20;\-> (a) - 전송 데이터가 DLE 문자를 포함하면 DLE 문자 다음에 DLE 문자 하나를 강제로 추가시켜 수신 호스트가 프레임 내용에 DLE 문자가 연속해서 두 번 나타나면 두 번째 DLE는 송신 호스트가 임의로 추가한 문자라고 판단할 수 있다.

(b)는 이를 설명하고 있으며 이와 같이 문자 프레임의 전송 과정에서 제어 문자를 추가하는 기능을 문자 스터핑(Character Stuffing)이라 한다.

&#x20;

#### &#x20;2. 비트 프레임(Bit Frame)

&#x20;\- 문자 단위의 가정을 없애고, 임의의 비트 패턴 데이터를 전송할 수 있다. 프레임의 시작과 끝 위치에 플래그(Flag)라는 패턴(01111110)을 사용해 프레임 단위를 구분한다.

&#x20;문자 프레임 방식에서는 DLE 패턴이 내용에 나타날 가능성이 있는 것처럼 플래그와 동일한 비트 패턴을 포함할 수 있어 적당히 조작하는 과정이 필요하다.

&#x20;

&#x20; **2.1 프레임의 구조**

&#x20; \- 데이터 전송 전 좌우에 플래그를 추가하고, 수신 호스트는 이 플래그를 제거해 전송 데이터와 필요한 제어 정보를 상위 계층에 전달할 수 있다.

<figure><img src="https://blog.kakaocdn.net/dn/Sa0vi/btrcSsQILwU/3ZAAefK51T8gamUTZzuVQ0/img.png" alt=""><figcaption></figcaption></figure>

&#x20; **2.2 비트 스터핑**

&#x20;\- 송신 호스트가 전송하고자 하는 데이터의 내용 중에 값이 1인 패턴이 연속해서 5번 발생하면 강제로 0을 추가해 전송한다. 플래그는 1이 연속해서 6개 나오는 패턴이므로 원천적으로 데이터 내용에 플래그 패턴이 발생하는 것을 차단하기 위해서다. \[굵은 숫자 0 2개가 송신 호스트가 추가한 비트]

&#x20;수신 호스트는 송신 과정에서 추가된 굵은 0을 제거하고 상위계층에 전달.

<figure><img src="https://blog.kakaocdn.net/dn/7EOTm/btrcNNIlNhy/iBWypMn8SLI86sDCkBSjr1/img.png" alt=""><figcaption></figcaption></figure>

&#x20;

### 04 다항 코드

&#x20;\-프레임 전송 과정에서 발생하는 오류를 극복하는 방법

&#x20;1\) 전송 프레임에 오류 검출 코드를 넣어 검출하는 방법 - 재전송(패리티 비트, 다항 코드 추가)

&#x20;2\) 오류 복구 코드를 넣어 수신 호스트가 오류 검출과 복구 기능을 하는 것

&#x20;  ex) 해밍 코드는 1비트 오류를 검출하고 복구하는 기능, 순방향 오류 복구(FEC : Forward Error Correction)

&#x20;

#### &#x20;1. 오류 검출

&#x20;역방향 오류 복구(BFC: Backward Error Correction) or ARQ(Automatic Repeat reQuest) : 네트워크에서 일반적으로(복구 코드로 순방향 오류 복구 방식을 쓰지 않음) 재전송 방식을 이용해 오류를 복구하는 방법

\- 기능을 수행하려면 수신한 프레임에 오류가 있는지 판단할 수 있어야 하는데 이를 위해 패리티 비트, 블록 검사, 다항 코드 등을 이용

&#x20;

&#x20; **1.1 패리티 비트(Parity bit)**

&#x20; : 1바이트 구조에서 7비트의 아스키코드를 제외한 나머지 1비트로 1의 개수가 짝수냐 홀수 냐에 따라 짝수 패리티, 홀수 패리티가 있다.

<figure><img src="https://blog.kakaocdn.net/dn/8jf5W/btrcSta3dHM/zDPB2psPlQWni2cxiYPkNK/img.png" alt=""><figcaption></figcaption></figure>

&#x20;\-> 1101001으로 짝수 패리티 방식을 사용해 전송하려면 11010010으로 만들어 전송한다. 1의 개수를 짝수로

데이터 전송 과정에서 비트가 변경되는 것을 판단

&#x20;

&#x20; **1.2 블록 검사(Block Sum Check)**

&#x20; \- 짝수 개의 비트에서 오류가 발생하면 오류가 검출되지 않는 문제가 있어 개선된 것이 블록 검사다.

&#x20; 여러 개의 바이트를 하나의 블록으로 구성한 후 교차 검사를 한다. 수평과 수직 방향에 모두 패리티 검사를 하여 오류 검출 확률을 높인다.

<figure><img src="https://blog.kakaocdn.net/dn/bsQhun/btrcNNn3B5w/8KOfBpFjM3fMGuN6DqU9Sk/img.png" alt=""><figcaption></figcaption></figure>

\-> 수평, 수직으로 패리티를 검출해 비트가 깨지면 오류를 검출한다. 하지만 오버헤드가 크고 수평, 수직 모두 사각형 형태로 짝수 개의 데이터 오류가 발생하면 검출하지 못한다.

&#x20;

#### &#x20;2. 다항 코드(=CYC: Cyclic Redundancy Code) Polynomial Code

&#x20; **2.1 생성 다항식**

\- 가장 많이 사용하며 0과 1인 다항식 형태를 기반으로 한다. 100101이면 1\*x의 5 제곱 +... 1\* x의 0 제곱으로 표현

\- 송신 호스트가 전송할 데이터가 m비트의 M(x)라면 데이터 전송 과정에서 n+1비트의 생성 다항식 G(x)를 사용해 오류 검출 코드를 생성함.

<figure><img src="https://blog.kakaocdn.net/dn/bEfaxE/btrcQgpvcUt/CSszIilXZejXdp8OW0zQ10/img.png" alt=""><figcaption></figcaption></figure>

&#x20;\-> 먼저 송신 호스트는 전송 데이터 M(x)를 생성 다항식 G로 나누어 체크섬 정보를 얻는다.

나누기 연산 과정에서 나머지를 보관할 n비트의 공간을 확보하고, 이 자리를 모두 0으로 채워 나누기 수행

나누기 과정에서의 다항 연산은 배타적 논리 합(XOR) 연산과 동일한 결과를 얻는다.

&#x20;\- 수신 호스트는 전송 오류가 발생했는지 판단하기 위해 수신한 m+n비트의 데이터를 생성 다항식 G로 나누는 연산을 수행한다. 결과로 얻은 나머지가 0이면 오류 없음, 아니면 오류 발생

&#x20;

&#x20; **2.2 체크섬의 예**

<figure><img src="https://blog.kakaocdn.net/dn/bq9lnj/btrcORi42DL/yDUoGAlCqOaQiajshlF2OK/img.png" alt=""><figcaption></figcaption></figure>
