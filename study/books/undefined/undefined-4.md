# 데이터 링크 계층

### 01 데이터 링크 계층 프로토콜의 기초

&#x20;\- 2계층에서 두 호스트가 통신하려면 일대일 형식의 점대점 방식으로 연결해 라우팅 과정 없이 전달된다.

&#x20;멀티드롭(Multi-Drop) : 하나의 호스트가 다수의 호스트와 연결된 비대칭 형태로 하나의 물리 매체를 여러 호스트가 공유하므로 임의의 호스트에서 전송한 프레임은 물리적으로 다른 모든 호스트에 전달된다.

&#x20;\- 점대점 방식은 호스트 구분하기 위한 주소가 필요 없지만 여러 수신 호스트 중 목적지 호스트를 지칭하기 위한 주소 개념이 필요하다.

#### &#x20;1. 프레임의 종류

&#x20;\- 전송 오류를 해결하는 과정에서 사용하는 프레임으로 정보프레임, 긍정 응답 프레임, 부정 응답 프레임

* 정보 프레임(Information Frame) : 상위 계층이 전송을 요구한 데이터를 수신 호스트에 전송하는 용도로 I프레임으로도 표기하며, 상위 계층에서 보낸 데이터와 함께 프레임의 순서 번호, 송수신 호스트의 주소 정보를 포함한다.

&#x20; \- 순서 번호(Sequence Number)는 각 정보 프레임에 부여되는 일련번호로 수신 호스트가 중복 프레임을 구분할 수 있도록 한다.

* 긍정 응답 프레임(Positive Acknowledgement) : 정보 프레임을 수신한 호스트는 맨 먼저 프레임의 내용이 깨졌는지 확인해야 한다. 프레임 변형 오류가 발생하지 않으면 송신 호스트에 해당 프레임을 올바르게 수신했다는 의미로 ACK 프레임인 긍정 응답을 회신한다.
* 부정 응답 프레임(Negative Acknowledgement) : 정보 프레임의 전송 과정에서 프레임 변형 오류가 발생하면 수신 호스트는 송신 호스트에 NAK 프레임인 부정 응답을 전달하여 송신 호스트가 오류 발생을 인지하고 원래의 정보 프레임을 재전송하도록 요청하는 것이다. 재전송 요구를 받은 송신 호스트는 오류가 발생한 프레임을 동일한 순서 번호로 다시 전송.&#x20;

&#x20;버퍼 부족으로 분실 오류 가능성 -> 흐름 제어 필요 -> 중복 재전송 방지 위해 순서 번호 기능 사용

&#x20;전송 오류로 변형 오류 가능성 -> 오류제어 필요 ->&#x20;

&#x20;

#### &#x20;2. 오류/흐름 제어가 없는 프로토콜

&#x20;\- 오류/흐름 제어가 필요없는 경우는 오류가 발생하지 않는 매우 이상적인 경우로 가장 단순화된 통신 환경이다.

&#x20; 또한 버퍼 용량 제한도 없어 속도 차이로 인한 프레임 분실도 없다.

* 단방향 통신 : 데이터는 송신 호스트에서 수신 호스트로만 전달
* 전송 오류가 없는 물리 매체 : 통신 채널에서는 어떠한 형태의 전송 오류도 발생하지 않는다.
* 무한 개의 수신 버퍼 : 수신 호스트의 버퍼 수는 무한하다.

<figure><img src="https://blog.kakaocdn.net/dn/E35wI/btrcZspZev8/EWnsVZKWnIWdSosPBSWhjK/img.png" alt="" height="348" width="382"><figcaption></figcaption></figure>

&#x20;\-> 송신 호스트가 전송한 프레임은 수신 호스트에 항상 도착한다.

&#x20;

#### &#x20;3. 오류 제어가 없는 프로토콜

&#x20;\- 두 번째로 가정하는 통신 환경은 다음과 같이 수신 호스트의 버퍼 개수가 유한한 것이며 송신 호스트가 전송한 정보 프레임의 수신 작업이 늦어질 때, 버퍼에 일시적으로 보관할 수 있는 프레임의 개수가 제한된다. 따라서 버퍼 용량 부족으로 프레임 분실 오류가 발생할 가능성이 있어 흐름 제어 기능이 필요하다.

* 단방향 통신 : 데이터는 소신 호스트에서 수신 호스트로만 전달
* 전송 오류가 없는 물리 매체 : 통신 채널에서는 어떠한 형태의 전송 오류도 발생하지 않는다.

&#x20; \- 흐름 제어는 주로 수신 호스트가 송신 호스트의 프레임 전송 시점을 제어하는 형태로 이뤄진다.

<figure><img src="https://blog.kakaocdn.net/dn/pSfIN/btrcOetjivF/JdEEbI9WRP6wIj9mtC5kk1/img.png" alt="" height="445" width="450"><figcaption></figcaption></figure>

&#x20;\-> 수신 호스트가 이전 프레임의 수신을 완료한 후에 다음 프레임을 전송하도록 송신 호스트에 지시하는 것이다 이때 사용하는 프레임이 ACK 프레임이다. ACK프레임은 긍정 응답의 기능을 수행하는 동시에, 다음 프레임을 전송하도록 지시하는 흐름 제어 기능도 수행한다.

&#x20;이처럼 각 정보 프레임에 대하여 수신 호스트가 회신하는 ACK 프레임이 도착해야 다음 프레임을 전송할 수 있는 프로토콜 방식을 정지-대기(stop-and-wait) 방식이라한다.(효율이 떨어져 사용 안 함)

&#x20; \- 흐름 제어 기능을 제공하지 않으면 버퍼 부족으로 분실 오류가 발생해 중복 프레임을 수신할 수 있다. 그래서 순서 번호 기능을 사용한다.

&#x20;

#### &#x20;4. 단방향 프로토콜

&#x20;\- 오류제어와 흐름 제어 기능을 지원하는 환경에서의 통신

* 단방향 통신 : 데이터는 송신 호스트에서 수신 호스트로만 전달

&#x20; **4.1 NAK가 없는 경우**

<figure><img src="https://blog.kakaocdn.net/dn/mjLdq/btrcXkeOFB3/t3OMcDAIncZ93nijmyb5E1/img.png" alt="" height="516" width="433"><figcaption></figcaption></figure>

&#x20;\-> (a)는 송신 호스트가 전송한 정보 프레임을 분실한 경우로, 수신 호스트는 받은 것이 없어 ACK를 보낼 수 없고 송신 호스트는 일정 시간을 설정해 재전송한다.

<figure><img src="https://blog.kakaocdn.net/dn/mie0q/btrcSr6Iv4G/F1quvzNgNnkGWngW0urAlK/img.png" alt="" height="287" width="457"><figcaption></figcaption></figure>

\->프레임 변형 오류에도 동일하게 적용된다. NAK 프레임이 정의되지 않아 타임아웃 기능에 의해 복구 진행

&#x20;

&#x20; **4.2 NAK가 있는 경우**

<figure><img src="https://blog.kakaocdn.net/dn/L7gd1/btrcZtbymrr/uux4RzMj0vR7qvocXwcYV0/img.png" alt="" height="523" width="441"><figcaption></figcaption></figure>

&#x20;  \- 프레임이 수신 호스트에 도착했으나 내용의 일부가 파손되는 프레임 변형 오류 발생의 경우 처리 방식

&#x20; 1\) 변형된 프레임을 무시하는 것으로 분실 오류와 동일한 결과로 타임아웃 기능을 거친다.

&#x20; 2\) (a)처럼 NAK 프레임을 이용해 프레임 변형 사실을 송신 호스트에 통보하는 것

&#x20;   \-> 타이머 기능보다 효과적일 수 있지만 실제 네트워크 프로토콜에서는 정보 프레임에서 변형된 부분이 중요한 부분일 수도 있고 다른 요소로 NAK를 사용하지 못할 수도 있다.

&#x20;

즉, 1) 정보 프레임에 대한 수신 호스트의 응답이 없을 때 송신 호스트의 타임아웃 기능에 의해 복구가 이뤄지는 경우

&#x20;   2\) 수신 호스트가 회신한 부정 응답 프레임(NAK)에 의해 복구가 이뤄지는 경우

&#x20;

### 02 슬라이딩 윈도우 프로토콜

&#x20;\- 앞부분은 단방향 통신이었고 실제로는 양방향 통신 환경에서 두 호스트 간의 프레임 전송을 위한 일반적인 통신으로 슬라이딩 윈도우 프로토콜이 있다.

* 기본절차

&#x20;1\) 정보 프레임을 전송하는 송신 호스트는 보내려는 데이터뿐 아니라 프레임의 순서 번호, 오류 검출 코드 등을 프레임에 표기한 후에 정해진 순서 번호에 따라 순차적으로 송신한다.

&#x20;

&#x20;2\) 정보 프레임을 받은 수신 호스트는 해당 프레임의 순서 번호에 근거하여 송신 호스트에 응답 프레임을 회신해야 한다. 일반적으로 응답 프레임의 내용에 포함되는 순서 번호는 정상적으로 수신한 프레임의 번호를 기재하지 않고, 다음에 수신하기를 기대하는 프레임의 번호를 표기한다.

&#x20;

&#x20;3\) 송신 호스트는 송신한 정보 프레임을 자신의 내부 버퍼에 유지하며, 이를 송신 윈도우라 한다. 송신 윈도우에서 대기하는 정보 프레임은 송신 호스트가 수신 호스트에 프레임 전송을 완료했지만 아직 수신 호스트로부터 긍정 응답을 받지 못한 프레임이다.

&#x20;

&#x20;4\) 수신 호스트는 수신한 정보 프레임을 보관하기 위해 내부 버퍼인 수신 윈도우를 유지할 수 있다. 수신 윈도우에는 개념적으로 수신을 기대하는 프레임의 순서 번호가 들어가기 때문에 프로토콜의 동작 방식에 따라 크기가 달라질 수 있다.

선택적 재전송(Selective Retransmission) 방식에서는 프레임의 도착이 비순서적으로 이뤄져도 처리가 가능하기 때문에 수신 윈도우의 크기가 송신 윈도우의 크기와 동일하다.

하지만 고백 N 방식에서는 수신 호스트가 항상 이전에 수신한 프레임의 바로 다음 프레임만 기다리기 때문에 수신 윈도우의 크기가 1이면 충분하다.

&#x20;

#### &#x20;1. 흐름 제어

&#x20; **1.1 순서 번호**

&#x20; \- 정보 프레임의 내용에는 프레임별로 고유하게 부여되는 순서 번호가 부여되는데 0부터 임의의 최댓값까지 있고 이후에는 0으로 되돌아와 순환 방식으로 할당된다. 따라서 프로토콜을 설계할 때 현재 처리되고 이는 서로 다른 프레임에 같은 순서 번호를 부여하지 않도록 주의해야 하며 이를 지키기 위해 순서 번호의 최댓값이 송신 윈도우의 크기보다 커야 한다.

&#x20;

&#x20; **1.2 윈도우 크기(Window Size)**

&#x20; : 송신 호스트가 수신 호스트로부터 긍정 응답 프레임을 받지 않고도 전송할 수 있는 정보 프레임의 최대 개수로 송신 호스트가 관리하는 송신 윈도우에 보관된 프레임은 수신 호스트에 전송되었으나 아직 긍정 응답 프레임을 받지 못한 프레임이다.

<figure><img src="https://blog.kakaocdn.net/dn/ckgUgd/btrcOfzhgrr/78xzf5DzEUIcf5VZp0cZo1/img.png" alt="" height="320" width="510"><figcaption></figcaption></figure>

\->

&#x20;(a) : 송신 윈도우의 최대 크기를 3으로 했을 때 슬라이딩 윈도우 프로토콜의 동작 과정으로 0,1,2번의 정보 프레임을 전송한 후에, 아직 해당 정보 프레임에 대한 ACK 프레임을 받지 못한 경우이다.\[3번을 전송하려면 0번에대한 긍정 응답 처리가 완료되야 한다]

&#x20;(b) : 수신 호스트로부터 0번에 대한 ACK 프레임이 돌아오면 프레임 처리가 완료된 것으로 1,2번만 존재한다.

&#x20;(c) : 윈도우의 최대 크기가 3이므로 3번 프레임을 전송할 수 있다.

&#x20;(d) : a, b, 와 같은 수순을 밟음

&#x20;(f) : 2,3번 프레임에 대한 ACK 프레임이 도착한 직후로 이후에는 5,6번을 전송할 수 있다. \[9까지 가면 다시 0부터 쭉]

<figure><img src="https://blog.kakaocdn.net/dn/pRzan/btrcNJ7VQKH/2AK1O5iY4zTuniK0N2J0F0/img.png" alt="" height="457" width="394"><figcaption></figcaption></figure>

#### &#x20;2. 연속형 전송

&#x20;\- 정지-대기 프로토콜은 송신 윈도우의 크기가 1인 경우로 송수신 호스트 사이의 물리적 거리 차로 인해 프레임의 전송 시간이 상대적으로 오래걸리는 환경에서 윈도우 크기가 1이면 효율이 떨어지며 이를 해결하려면 윈도우 크기를 늘려 ACK 프레임을 받지 않고도 여러 정보 프레임을 연속으로 전송하는 방식을 연속형 전송(Pipelining)이라 한다.

\-> 전송 오류 발생이 적은 환경에서만 효율적으로 해결 방법은 고백 N과 선택적 재전송 방식이 있다.

&#x20;

&#x20; **2.1 고백 N(Go-Back-N) 방식**

&#x20;: 오류 복구 과정에서 오류가 발생한 12번 프레임을 포함해 이후 전송된 모든 프레임을 재전송하는 방식으로 정상적으로 수신한 프레임까지 재전송하는 문제가 있다.

<figure><img src="https://blog.kakaocdn.net/dn/cjWqqy/btrcONWT8iE/y0KeLMZUAkmq6JEGvJpklK/img.png" alt="" height="515" width="486"><figcaption></figcaption></figure>

&#x20; \-> 부정 응답 기능을 수행하는 NAK 프레임이 전송되는 원인으로

하나는 12번 정보 프레임이 수신 호스트에 도착했으나 내용이 변질된 경우, 다른 하나는 12번 프레임이 도착하지 않은 경우이다.

후자인 경우는 수신 호스트에 10,11번 프레임이 도착 후 13,14,15번 순으로 프레임이 도착한다. 그러면 수신 호스트는 중간의 12번 프레임을 분실했음을 인지하여 NAK 프레임을 전송할 수 있다.

&#x20;\- 만약 프로토콜에서 NAK 프레임을 사용하지 않고 ACK 프레임만으로 작성하면 송신 호스트가 12번 프레임의 긍정 응답 프레임을 받을 수 없어 타임아웃 과정에 의해 재전송을 거친다.

&#x20;

&#x20; **2.2 선택적 재전송 방식(Selective Restransmission)**

&#x20;: 오류가 발생한 프레임만 선택적으로 복구하는 방식으로 고백 N의 문제점을 해결하기 위해 사용하는 것으로 12번만 재전송시킨다.

<figure><img src="https://blog.kakaocdn.net/dn/3ndDu/btrcOfMRHKz/jlUSt0N7ggvObe0rZjXCRk/img.png" alt="" height="519" width="441"><figcaption></figcaption></figure>

&#x20;\-> NAK (12) 프레임을 전송한 후 I(12) 번 프레임 처리를 완료할 때까지 다음 정보 프레임에 대한 긍정 응답 프레임을 전송하지 않도록 주의한다.

&#x20;

#### &#x20;3. 피기배깅(Piggybacking)

&#x20;: 응답 프레임의 전송 횟수를 줄이는 효과로 전송 효율을 높이는 것으로 정보 프레임의 구조를 적당히 조정해 재정의하면 정보 프레임을 전송하면서 응답 기능까지 함께 수행할 수 있다.

&#x20;\- 정보 프레임의 내용엔 전송할 데이터와 해당 데이터에 대한 순서 번호가 포함되었다. 피기배킹을 지원하려면 정보 프레임의 구조를 확장해 두 종류의 순서 번호를 모두 표기해야 한다. \[데이터, 순서 번호, 수신한 프레임의 순서번호 포함]

<figure><img src="https://blog.kakaocdn.net/dn/lewQQ/btrcQfewA3Z/qRp0U8dJlux9JhuQXZBx9K/img.png" alt="" height="616" width="398"><figcaption></figcaption></figure>

&#x20;\-> 비기배킹 사용과 사용하지 않을 때의 차이다.

&#x20; 정보 프레임의 표기 방식은 I(i, j)이며 i는 자신이 전송하는 데이터의 순서 번호이고, j는 제대로 수신한 프레임의 순서 번호이다.

&#x20;\- 응답 프레임을 전송할 시점에서 전송할 정보 프레임이 있으면 피기배킹 기능을 사용할 수 있지만, 정보 프레임이 없으면 응답 프레임만 전송해야 한다.

&#x20;

### 03 HDLC 프로토콜

(High-Level Data Link Control) : 일대일, 일대다로 연결된 환경에서 데이터의 송수신 기능을 제공하며

주국(Primary Station)과 종국(Secondary Station)으로 구분되고 다시 이들의 기능을 모두 지닌 혼합국(Combined Station)으로 정의한다.&#x20;

주국에서 전송되는 메시지는 명령이며 종국은 회신을 응답이라 한다.&#x20;

#### &#x20;1. 프레임 구조

&#x20;\- 프레임 좌우의 01111110 플래그는 프레임의 시작과 끝을 구분

<figure><img src="https://blog.kakaocdn.net/dn/Dc7e2/btrc1UNtlda/Gx9ruWXzcYkRmXTcygfc71/img.png" alt="" height="425" width="630"><figcaption></figcaption></figure>

* Address(주소) : 일대다로 연결된 환경에서 특정 호스트를 구분하여 지칭하는 목적으로 사용. 주국에서 정보 프레임을 전송할 때는 수신 호스트인 종국 주소를 표기하며, 종국에서 전송할 때는 송신 호스트인 자신의 주소가 기록된다.
* Control(제어) : 프레임의 종류를 구분한다. 프레임 유형에 따라 송신용 순서 번호, 회신용 순서 번호와 기타 중요한 제어 코드를 포함한다. \[I-정보, S-감독, U-비번호]
* Data(데이터) : 가변 크기의 전송 데이터가 포함되는데, 상위 계층인 네트워크 계층에서 보내진 패킷이 캡슐화된다.
* Checksum(체크섬) : CRC-CCITT를 생성 다항식으로 하는 오류 검출 용도로 사용된다.

&#x20;

#### &#x20;2. 프레임 종류

&#x20; **2.1 정보 프레임(Information Frame)**

&#x20; \- 위 그림처럼 3비트의 순서 번호를 이용한 슬라이딩 윈도우 프로토콜을 사용.

* Seq : 정보 프레임의 송신용 순서 번호로 사용
* Next : 피기배킹을 이용한 응답 기능으로 사용한다. 이 값은 제대로 수신된 프레임 번호가 아닌, 다음에 수신을 기대하는 프레임 번호이다. 이 번호 이전까지는 오류가 없었음.
* P/F : 값이 1로 되어있는 경우에 한해서 Poll 혹은 Final의 의미를 갖는다. 일반적으로 주국의 명령 프레임에서 사용될 때는 Poll(종국이 있는지 확인용), 종국의 응답 프레임에서 사용될 때는 Final(종국-> 주국으로 데이터 전송할 때).

\-하나의 주국 컴퓨터가 다수의 종국 컴퓨터를 제어하기 위한 용도로 종국에 데이터 전송을 허가할 때 사용.

&#x20;

&#x20; **2.2 감독 프레임(Supervisor Frame)**

&#x20;: 정보 프레임에 대한 응답 기능을 수행하는 프레임으로 크게 긍정, 부정으로 구분하고 세부적으로는 4개의 Type으로 구분.

<figure><img src="https://blog.kakaocdn.net/dn/b6gkEB/btrcQfZZbom/rjK4gu97DVeThhZ83aaSfK/img.png" alt="" height="304" width="618"><figcaption></figcaption></figure>

* Type 0 : RR로 정의된 긍정 응답 프레임으로 다음에 수신을 기대하는 프레임 번호를 Next 필드에 표시
* Type 1 : REJ로 정의된 부정 응답 프레임으로 Next 필드에는 재전송되어야 하는 프레임의 번호를 표시한다. 따라서 송신 호스트는 Next 필드의 번호로 시작하는 프레임부터 재전송해야 한다.
* Type 2 : RNR로 정의된 응답 프레임으로 흐름 제어 기능 제공한다. Next 필드에 표시한 순서 번호를 갖는 정보 프레임의 바로 앞 번호까지 제대로 수신되었다는 긍정 응답 기능과 함께 송신 호스트에 송신을 중지하도록 요구하고 송신 호스트에 다시 전송을 요구할 때는 RR, REJ 혹은 기타의 제어 프레임을 전송하면 된다.
* Type 3 : SREJ로 정의된 프레임으로 선택적 재전송 방식에서 부정 응답 기능을 지원하며 Next 필드의 순서 번호를 갖는 특정 프레임에 대해 재전송 요구 기능을 갖는다.

&#x20;

&#x20; **2.3 비번호 프레임(Unnumbered Frame)**

&#x20;: 순서 번호가 없는 프레임으로 주로 연결 제어 용도로 사용하지만 비연결형 데이터 전송을 위해 사용하기도 한다.

* SABM(Set ABM) : 비동기 균형 모드의 연결 설정을 요구
* SNRM(Set NRM) : 정규 응답 모드의 연결 설정을 요구
* SARM(Set ARM) : 비동기 응답 모드의 연결 설정을 요구
* DISC(DISConnect) : 연결 설정 해제를 요구
* RSET(ReSET) : 비정상적인 프로토콜의 동작에 따른 리셋 기능을 수행
* FRMR(FRaMe Reject) : 비정상적인 프레임의 수신을 거부
* UA(Unnumbered ACK) : 비번호 프레임에 대한 응답 기능을 수행

&#x20;

#### &#x20;3. LAP 프로토콜(Link Access Protocol)

&#x20;: 비동기 응답 모드인 ARM으로 동작하는 프로토콜이다. 연결 설정 과정은 주국에서 전송된 SARM 명령에 대해 종국에서 UA 응답을 전송해서 완성

<figure><img src="https://blog.kakaocdn.net/dn/bd248b/btrcOMX6oXt/xUh3gWekNjzltK1m0xRLKk/img.png" alt="" height="500" width="365"><figcaption></figcaption></figure>

#### &#x20;4. LAPB 프로토콜(Link Access Protocol-Balanced)

&#x20;: 양쪽 호스트가 혼합 국으로 동작하기 때문에 누구나 먼저 명령을 전송할 수 있다.

<figure><img src="https://blog.kakaocdn.net/dn/bqz53B/btrcVkzLkDd/l154GhQDOjaZVnT5uxTvn0/img.png" alt="" height="252" width="378"><figcaption></figcaption></figure>

&#x20;\-> 비동기 균형 모드의 연결을 설정하기 위해 오른쪽 호스트가 왼쪽 호스트에 SABM 명령을 전송한 경우로 UA응답을 전송함으로써 2 계층의 연결 설정 완료.
