# 재귀

**재귀(recursion)** : 어떤 함수의 구현 내부에서 자기 자신을 호출(재귀 호출, recursive call)하는 함수를 정의하는 방법.

**메모이제이션(memoization) :** 어떤 반복된 연산을 수행할 때 이전에 계산했던 값을 캐싱해서 중복된 연산을 제거하는 방법이다.

**꼬리 재귀(tail-recursion)** : 어떤 함수가 직간접적으로 자기 자신을 호출하면서도 \
그 호출이 마지막 연산인 경우.

**상호 재귀(mutual recursion)** : 함수 A가 함수 B를 호출하고, \
함수 B가 다시 함수 A를 호출하는 것.

**트램펄린(trampoline)** : 반복적으로 함수를 실행하는 루프(loop).

**성크(thunk)** : 트램펄린에서 반복적으로 실행되는 함수. \
다음에 실행될 함수를 매번 새로 생성하여 반환한다.

## 재귀 <a href="#undefined" id="undefined"></a>

재귀는 반복문에 비하여 복잡한 알고리즘을 간결하게 표현할 수 있지만, \
다음과 같은 문제점을 가진다.

```
동적 계획법 방식에 비해서 성능이 느리다.
스택 오버플로 오류(stack overflow error)가 발생할 수 있다.
```

재귀가 무한루프에 빠지지 않으려면 재귀에서 빠져 나오는 종료조건(edge condition)이 적어도 한 개 이상 존재해야 하고 재귀를 반복할수록 종료조건으로 수렴해야 한다.

```
종료조건(edge conditon) 정의
함수의 입력을 분할하여 어떤 부분에서 재귀 호출을 할지 결정
함수의 입력값이 종료조건으로 수렴하도록 재귀 호출의 입력값을 결정
```

종료조건을 정의할 때는 자료구조가 더는 쪼개지지 않아 재귀의 과정이 더 이상 의미 없는 값을 사용한다.\
함수의 입력을 분할할 때는 수학적 귀납법과 동일한 패턴을 적용한다.

## 메모이제이션

메모이제이션(memoization)을 이용하면 불필요한 재귀 호출을 줄이고, 성능을 개선할 수 있다.

일반적인 재귀는 호출이 반복되므로 깊이가 깊어지면 스택 오버플로(stack overflow)가 발생할 수 있다. 그러나 꼬리 호출일 때는 스택 오버플로 문제를 일으키는 스택 프레임(stack frame)을 컴파일러가 재사용할 수 있다.

## 꼬리 재귀 패턴

누산값(accumultor)의 타입은 최종 반환값 타입과 같다.

종료조건의 반환값은 누산값이거나 누산값을 포함한 연산 결과이다.

중간 결괏값(take 함수에서는 takeList)을 만드는 순서는 보통 ‘누산값 + 새로운 값’이다.

멱집합이란 어떤 집합의 모든 부분 집합의 집합이다
