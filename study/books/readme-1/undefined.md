# 벽돌부터 시작하기

## **패러다임 개요**

> 구조적 프로그래밍

제어흐름의 직접적인 전환에 대해 규칙을 부과한다

> 객체지향 프로그래밍

함수호출이 반환된 이후에도 함수에서 선언된 지역 변수가 오랫동안 유지될 수 있다.

이러한 함수는 클래스의 생성자가 되며 지역변수는 인스턴스 변수 그리고 중첩함수는 메서드가 된다.

제어흐름의 간접적인 전환에 대해 규칙을 부과한다

> 함수형 프로그래밍

람다 계산법을 기초로 하는 프로그래밍, 이는 불변성이며 심볼의 값이 변경되지 않는다.

할당문에 대해 규칙을 부과한다

**구조적 프로그래밍**

> 증명

공리, 정리, 따름정리, 보조정리로 구성되는 유클리드 계층구조를 만든다.

* 순차

단순 열거법을 이용해 올바름을 입증할 수 있다.

* 분기

각 경로를 열거후, 적절한 결과를 만들어 낸다면 수학적으로 신뢰성을 가진다

* 반복

귀납법을 이용한 추론, 열거법을 이용하여 수학적 신뢰성을 증명한다.

**기능적 분해**

구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해할 수 있게 되었다.

구조적 분석, 구조적 설계 등을 이용한 세분화

**객체 지향 프로그래밍**

본질적으로 캡슐화 상속 다형성을 가진다.

_의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력._

> 캡슐화

객체지향은 데이터화 함수를 쉽게 캡슐화 한다.

_캡슐화된 데이터를 우회해서 사용하지 않을 것 이라는 믿음을 기반으로 한다._

> 상속

암묵적인 업케스팅이 이뤄진다.

> 다형성

새로운 기능의 도입에 변경이 필요 하지 않다. - 플러그인 아키텍쳐

* 의존성 역전

소프트웨어 아키텍트가 소스코드 의존성 전부에 대한 방향을 결정할 수 있게된다.

**함수형 프로그래밍**

> 불변성과 아키텍쳐

가변 변수는 경합, 교착, 동시성 의 문제를 일으킨다.

> 가변성의 분리

불변성의 가장 중요한 타협은 **가변 컴포넌트**와 **불변 컴포넌트**로 분리하는 일이다

_가능한 많은 처리를 불변 컴포넌트로 옮기고 가변 컴포넌트의 코드를 빼내야 한다._

> 이벤트 소싱

생명주기 동안에 문제없이 동작할 정도의 저장 공간과 처리 능력 - 상태가 아닌 트랜잭션을 저장하는 전략

* 구조적 프로그래밍은 제어흐름의 직접적인 전환에 부과되는 규율
* 객체 지향 프로그래밍은 제어흐름의 간접적인 전환에 부과되는 규율
* 함수형 프로그래밍은 변수 할당에 부과되는 규율
