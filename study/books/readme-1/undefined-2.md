# 컴포넌트

## **컴포넌트**

**아키텍쳐**는 프로그래머이다 시스템을 구축했던 사람들이 만들어낸 시스템의 형태이다 시스템의 생명주기를 지원하고 비용과 생산성의 효율성을 끌어올린다.

* 배포 아키텍쳐는 시스템을 쉽게 배포할 수 있도록 배포전략을 고려해야 한다.
* 운영 아키텍쳐는 유스케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상 시키고, 개발자에게 주요 목표로 인식되게 해야한다.
* 유지보수 유지보수는 모든 측면에서 보았을때 비용이 가장 많이 든다.
* 선택사항 열어두기 확장성을 고려해야한다. ( 세부사항 , 고도화 ) 데이터베이스 시스템을 고려하지 않아도 된다

> 재 배치성

많은 라이브러리를 로드할 때, 메모리 과부하를 막는 **바이너리**를 사용

지능적인 로더를 사용하여 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일러를 수정, 이 때 로더는 재배치 코드가 자리할 위치 정보를 받는다.

이를 통해 필요한 함수만을 로드할 수 있게 된다.

> 링커

링킹 로더의 등장으로 개별적으로 컴파일하고 로드 할 수 있는 단위로 분할할 수 있게 되었다.

링커는 링크가 완료된 재배치 코드를 만들어 주었고, 로딩과정의 최적화가 일어났다.

> 무어

로드와 링크를 동시에 할 수 있게 되면서, 다수의 .jar 파일로 공유 라이브러리를 순식간에 서로 링크한 후, 프로그램을 실행할 수 있는 **컴포넌트 플러그인 아키텍쳐**가 탄생했다

**컴포넌트 응집도**

> REP: 재사용 릴리스 등가 원칙

메이븐, RVM 등의 모듈관리 도구가 등장하면서, 재사용 가능한 컴포넌트와 컴포넌트 라이브러리가 만들어졌다.

컴토넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면, 해당 컴포넌트를 재사용하고 싶어도 할 수가 없다.

하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다.

> CCP: 공통 폐쇄 원착

단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안된다.

변경될 가능성이 있는 클래스는 모두 한곳으로 묶는다. 전략적으로 변경을 위한 컴포넌트만 재배포 한다. ( 변경될 가능성이 있는 클래스는 한곳으로 묶어, 물리적 / 개념적으로 묶인 클래스는 하나의 컴포넌트에 속해야 한다.)

> CRP: 공통 재사용 원칙

클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙

의존성을 가지는 컴포넌트가 변경될 떄 마다 사용하는 컴포넌트도 변경해야 한다.

> 컴포넌트 응집도에 대한 균형 다이어그램

REP & CCP는 포함 원칙이다, 컴포넌트를 크게 만든다.

CRP는 배제원칙이며 컴포넌트를 작게 만든다.

**컴포넌트 결합**

컴포넌트 구조와 관련된 아키텍쳐를 침범하는 힘은 기술적이며, 정치적이고, 가변적이다.

> ADP: 의존성 비순환 원칙

컴포넌트 의존성 그래프에 순환이 있어서는 안된다.

주 단위 빌드, 의존성 비순환 원칙으로 협업시 발생하는 충돌을 방지한다.

* 의존성 비순환 원칙

개발환경을 릴리스 가능한 컴포넌트 단위로 분리한다.

컴토넌트의 릴리스(버전) 을 나눠 적용한다.

* 순환 끊기

의존성 역전을 적용한다.

모두 의존하는 컴포넌트를 만든다.

* 하향식 설계

컴포넌트 구조는 하향식으로 설계 될수 없다.

컴포넌트의 의존성 다이어크램은 어플리케이션의 **빌드가능성**과 **유지보수성** 을 보여주는 지도와도 같다.

> SDP : 안정된 의존성 원칙

공통 폐쇄원칙을 준수함으로써 특정 유형의 변경에만 민감하게 만들 수 있다.

변경이 쉽지 않은 컴포넌트가 변동이 예상되는 컴포넌트에 의존하게 만들어서는 안된다.

* 안정성

컴포넌트가 의존하지 않게 만드는 것이다.

* 추상 컴포넌트

오로지 인터페이스만 포함하는 컴포넌트.

> SAP: 안정된 추상화 원칙

고수준 정책을 어디에 위치시켜야 하는가?

고수준 아키텍쳐와 정책결정과 관련된 소프트웨어는 변동성이 없어야 한다.

* 안정된 추상화 원칙

안정된 추상화 원칙은 안정성과 추상화 정도 사이의 관를 정의한다.
