# java.lang패키지와 유용한 클래스

### 1. java.lang패키지 <a href="#1-javalang" id="1-javalang"></a>

자바프로그래밍에 가장 기본이 되는 크래스들을 포함하고 있다. 그렇기 때문에 import문 없이도 사용할 수 있게 되어 있다.

#### Object 클래스 <a href="#object" id="object"></a>

**1. equals(Object obj)**\
매개변수로 객체의 참조변수를 받아서 비교하여 그 결과를 boolean값으로 알려 주는 역할을 한다.

Object클래스로부터 상속받은 equals메서드는 두 참조변수에 저장된 값(주소값)이 같은지를 판단하는 기능밖에 할 수 없다.\
인스턴스가 가지고 있는 값을 통해서 비교하고 싶다면 equals메서드를 오버라이딩하여 변경하면 된다.\
String클래스 역시 Object클래스의 equals메서드를 그대로 사용하는 것이 아니라 오버라이딩을 통해서 문자열 값을 비교하도록 되어있다.

**2. hashCode()**\
Object클래스에 정의된 hashCode메서드는 객체의 주소값을 이용해서 해시코드를 만들어 반환하기 때문에 서로 다른 두 객체는 결코 같은 해시코드를 가질 수 없다.

클래스의 인스턴스변수 값으로 객체의 같고 다름을 판단해야한다면 equals와 마찬가지로 hashCode메서드도 적절히 오버라이딩해야 한다.

**3. toString()**\
인스턴스에 대한 정보를 문자열로 제공할 목적으로 정의한 것이다.

Object클래스에서 toString()의 접근 제어자가 public이므로, 이를 오버라이딩하는 클래스ㄴ에서는 toString()의 접근 제어자를 public으로 할 수 밖에 없다.

**4. clone()**\
자신을 복제하여 새로운 인스턴스를 생성한다.

Object클래스의 clone메서드는 단순히 인스턴스변수의 값만을 복사하기 때문에 참조탕비의 변수는 주소를 복제하기 때문에 원래의 인스턴스에 영향을 미친다. 이런경우 clone메서드를 오버라이딩해야 한다.

clone()을 사용하려면, 먼저 복제할 클래스가 Clonable인터페이스를 구현해야하고, clone()을 오버라이딩하면서 접근 제어자를 protected에서 public으로 변경해야 한다.

> **얕은 복사와 깊은 복사**\
> _**얕은 복사(Shallow Copy)**_\
> \- 객체를 복사할 때, 해당 객체만 복사하여 새 객체를 생성한다.\
> \- 복사된 객체의 인스턴스 변수는 원본 객체의 인스턴스 변수와 같은 메모리 주소를 참조한다.\
> \- 따라서, 해당 메모리 주소의 값이 변경되면 원본 객체 및 복사 객체의 인스턴스 변수 값은 같이 변경된다.\
> _**깊은 복사(Deep Copy)**_\
> \- 객체를 복사 할 때, 해당 객체와 인스턴스 변수까지 복사하는 방식.\
> \- 전부를 복사하여 새 주소에 담기 때문에 참조를 공유하지 않는다.

**5. getClass()**\
자신이 속한 클래스의 Class객체를 반환하는 메서드이다.

> Class객체는 클래스의 모든 정보를 담고 있으며, 클래스 당 1개만 존재한다.\
> 클래스 파일이 '클래스 로더'에 의해서 메모리에 올라갈 때, 자동으로 생성된다.

Class객체를 이용하면 클래스에 정의된 멤버의 이름이나 개수 등, 클래스에 대한 모든 정보를 얻을 수 있기 때문에 Class객체를 통해서 객체를 생성하고 메서드를 호출하는 등 보다 동적인 코드를 작성할 수 있다.

#### String클래스 <a href="#string" id="string"></a>

**변경 불가능한 클래스**\
문자열간의 결합이나 추출 등 문자열을 다루는 작업이 많이 필요한 경우에는 String클래스 대신 StringBuffer클래스를 사용하는 것이 좋다.

**문자열의 비교**\
문자열을 만들 때는 두가지 방법, 문자열 리터럴을 지정하는 방법과 String클래스의 생성자를 사용해서 만드는 방법이 있다.

String클래스의 생성자를 이용한 경우에는 new연산자에 의해서 메모리 할당이 이루어지기 때문에 새로운 String인스턴스가 생성된다. 그러나 문자열 리터럴은 이미 존재하는 것을 재사용하는 것이다.

따라서, 각 String인스턴스의 주소를 비교했을 때 결과가 달라질 수 있다.

**문자열 리터럴**\
자바 소스파일에 포함된 모든 문자열 리터럴은 컴파일 시에 클래스 파일에 저장된다. 이 때 같은 내용의 문자열 리터럴은 한번만 저장된다.

**빈 문자열**\
`String s ="";`은 가능하지만 `char c ='';`은 불가능 하다.

**유니코드의 보충문자**\
String클래스의 메서드 중 매개변수의 타입이 char인 것들이 있고 int인 것이 있다.\
이는 확장된 유니코드를 다루기 위한 것이다.

#### StringBuffer클래스와 StringBuilder클래스 <a href="#stringbuffer-stringbuilder" id="stringbuffer-stringbuilder"></a>

StringBuffer클래스는 문자열 변경이 가능하다.

이 때, 편집할 문자열의 길이를 고려하여 버퍼의 길이를 충분히 잡아주는 것이 좋다.\
버퍼의 크기를 지정해주지 않으면 16개의 문자를 저장할 수 있는 크기의 버퍼를 생성한다.

**StringBuffer의 비교**\
StringBuffer클래스는 equals를 오버라이딩하지 않아서 등가비교연산자(==)와 같은 결과가 나온다.\
반면에 toString()은 담고있는 문자열을 String으로 반환하도록 오버라이딩 되어 있다. 그래서 StringBuffer인스턴스에 담긴 문자열을 비교하기 위해서는 toString()을 호출해서 String인스턴스를 얻은 다음에 equals메서드를 사용하여 비교해야 한다.

**StringBuilder**\
StringBuffer클래스에서 쓰레드의 동기화만 뺀 클래스이다. 동기화가 StringBuffer의 성능을 떨어뜨리기 때문이다.

#### 래퍼(wrapper)클래스 <a href="#wrapper" id="wrapper"></a>

기본형 변수를 객체로 다뤄야 하는 경우에 사용된다.

char형과 int형을 제외한 나머지는 자료형의 이름의 첫글자를 대문자로 한 것이 각 래퍼클래스의 이름이다.

* char -> Character
* int -> Integer

래퍼클래스의 생성자는 매개변수로 문자열이나 각 자료형의 값들을 인자로 받는다.

래퍼클래스들은 모두 equals()가 오버라이딩되어 있어서 객체가 가지고 있는 값으로 비교한다.

**Number클래스**\
추상클래스로 내부적ㅇ,로 숫자를 멤버변수로 갖는 래퍼 크래스들의 조상이다.

**오토박싱 & 언박싱**\
컴파일러가 자동으로 기본형과 참조형 간의 계산이 가능하도록 변환하는 코드를 넣어준다.

기본형 값을 래퍼클래스의 객체로 자동으로 변환해주는 것을 '오토박싱'이라 하고, 반대로 변환하는 것을 '언박싱'이라고 한다.



### 2. 유용한 클래스 <a href="#2" id="2"></a>

#### 정규식 - java.util.regex <a href="#javautilregex" id="javautilregex"></a>

**정규식을 정의하고 데이터를 비교하는 과정**\
1\. 정규식을 매개변수 Pattern 클래스의 static메서드인 Pattern compile(String regex)을 호출하여 Pattern인스턴스를 얻는다.\
`Pattern p = Pattern.compile("c[a-z]*");`\
2\. 정규식으로 비교할 대상을 매개변수로 Pattern클래스의 Matcher matcher(CharSequance input)를 호출해서 Matcher인스턴스를 얻는다.\
`Matcher m = p.matcher(data[i]);`\
3\. Matcher인스턴스에 boolean matchses()를 호출해서 정규식에 부합하는지 확인한다.\
`if(m.matches())`
