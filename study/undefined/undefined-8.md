---
description: 데이터를 가져오는 정책에 대해서 알아봅니다.
---

# 요구 페이징

## 요구페이징?

메모리를 효율적으로 관리하기 위해, 적은양의 프로세스만 유지한다.

필요한 모듈들만 올려 응답 속도를 향상하기 위해서다



사용자가 요구한 특정 기능을 수행할 때 해당 모듈들을 메모리에 올려두면 여러 이점들이 있는데, 이와 같이 요구한 페이지를 메모리에 올리는 것을 요구 페이징 이라고 한다.

{% hint style="info" %}
미리가져오기?? :  요구페이징과 반대로 앞으로 필요할 것이라고 예상된 페이지를 미리 가져온다
{% endhint %}

### 페이지 테이블엔트리

가상 메모리는 물리 메모리와 스왑 영역을 합친 것이다.

<img src="../../.gitbook/assets/file.drawing (2) (1) (2).svg" alt="swapIn &#x26; swapOut" class="gitbook-drawing">

사용자 프로세스는 물리 메모리와 스왑 영역 둘중 한곳에 있다.

페이지 테이블은 페이지가 메모리에 있는지 스왑 영역에 있는지 표시해야 하는데, 이걸 `유효 비트`라고 한다



PTE 내부에는 페이지번호, 플래그 비트, 프레임 번호가 존재하는데, 이중 프레임 번호를 가지고 어느 프레임에 있는지 알려준다.

이 프레임 번호는 주소 필드 라고도 한다.

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

이 PTE에는 여러 플래그 비트들이 존재한다.

```
접근 비트 : 페이지에 올라온 후 사용된 적이 있는지 여부 (참조 비트라고 한다)
변경 비트 : 페이지에 올라온 후 변경된 적이 있는지 여부 (더티 비트라고 한다)
유효 비트 : 실제 메모리에 있는지 아닌지 나타내는 경우 (프레젠트 비트 라고 한다)
읽기&쓰기&실행 비트 : 권한을 나타내는 비트
```

### 페이지 부재

페이지에 위치에 따라 유효 비트는 0,1을 가지게 된다.

```
유효비트 1 -> 스왑영역 , 유효비트 0 -> 물리 메모리 영역 
```

프로세스가 페이지를 요청했을 때 그 페이지가 메모리에 없는 상황을 페이지 부재라고 한다.

<img src="../../.gitbook/assets/file.drawing (1) (6) (1).svg" alt="" class="gitbook-drawing">

페이지 폴트가 발생하면 스왑 영역에서 메모리로 데이터를 옮겨야 한다.

페이지 폴트가 발생하면 스왑영역의 데이터를 메모리의 빈 공간에 옮긴 뒤 갱신 한다.

메모리에 빈 프레임이 많은 경우엔 수월하지만, 메모리 프레임이 가득 차있다면 `페이지 교체 알고리즘`을 통해 특정 페이지(`대상페이지`)를 스압 영역으로 내보낸다.

### 지역성

메모리가 꽉차서 스왑 영역으로 보낼 때는 앞으로 사용하지 않을 페이지를 쫓아내는 것이 좋다.

지역성은 아래 세가지를 기준으로 체크한다.

#### 공간의 지역성

현재 위치에서 가까운 데이터에 접근할 확률이 먼 거리에 있는 확률 보다 높다.

#### 시간의 지역성

현재를 기준으로 가장 가까운 시간에 접근한 데이터가 먼 시간에 접근한 데이터보다 확률이 높다

#### 순차적 지연성

작업은 순차적으로 진행되는 경향이 있다는 걸 의미한다.



### 페이지 교체 알고리즘

Page Fault가 발생하면 스왑 영역에서 페이지를 가져오는데, 메모리가 꽉 찻다면 메모리에 있는 페이지를 스왑영역으로내보내야 한다.

이떄 내보낼 페이지를 선택하는 알고리즘은 시스템의 성능을 향상 시킨다.

| Algorithm | Characteristic       |
| --------- | -------------------- |
| RANDOM    | 무작위로 선정              |
| FIFO      | 처음 올라온 페이지 선정        |
| 최적        | 미래의 접근 패턴을 보고 페이지 선정 |
| LRU       | 시간적으로 멀리 떨어진 페이지를 선정 |
| LFU       | 사용 빈도가 적은 페이지를 선정한다  |
| NUR       | 최근에 사용한 적이 없는 페이지 선정 |
| FIFO 변형   | FIFO를 변형하여 선능 개선     |

LRU, LFU, NUR은 최적 페이지 교체 알고리즘에 근접하는 성능을 보인다.



#### 무작위 페이지 교체

스왑 영역으로 내보낼 페이지를 무작위로 선정한다

#### FIFO 페이지 교체

가장 먼저 들어온 페이지를 스왑영역에 쫓아내는 알고리즘이다.

지역성은 고려하지 않은채 가장 먼저 사용된 페이지를 쫓아내기 때문에, 자주사용하는 페이지는 고려되지 않아 성능이 떨어진다.

#### 최적 페이지 교체

앞으로 사용하지 않을 페이지를 스왑 영역으로 옮긴다.

메모리가 앞으로 사용할 페이지를 살펴보고 교체 선정 시점부터 사용 시점까지 가장 멀리 있는 페이지를 선정한다.

가장 이상적인 방법이지만 구현할 수 없다

#### LRU 페이지 교체

최적 근접 알고리즘 중 시간을 기준으로 가장 오래동안 사용되지 않은 페이지를 스왑 영역에 보낸다.

카운터나, 참조 비트를 이용하는 방법도 있다.



접근 시간에 기반한 방식 : 페이지에 접근(연산이 이루어진 시간)한 시간을 기록한다

카운터에 기반한 방식 : 접근 시간이 아닌 접근 카운터를 사용하여 구현할 수도 있다.

참조 비트의 시프트 방식 :  각 페이지에 참조 비트를 만들어서 사용한다.

참조 비트가 계속 갱신되다가 가장 참조비트의 수가 낮은 페이지를 내보낸다.

<img src="../../.gitbook/assets/file.drawing (1) (8) (1).svg" alt="" class="gitbook-drawing">

기록하기 위한 만큼의 메모리공간이 낭비되는 단점이 있다.

#### LFU 페이지 교체

최소 빈도 사용 알고리즘 이라고도 불린다.

페이지가 몇번 사용되었는지를 기준으로 대상 페이지를 선정한다.&#x20;

현재 프레임에 있는 페이지마다 사용된 횟수를 세어 가장 적은 페이지를 스왑 영역으로 옮긴다.

#### NUR 페이지 교체

페이지 교체 알고리즘은 공간 낭비 문제를 해결한 알고리즘이다.

접근 시간과 접근 빈도의 정확한 값을 유지하지 않는 방식이다.

추가 비트 2개만 사용하여 미래를 추정한다

{% hint style="info" %}
참조 비트 : 페이지에 접근하면 1\
변경 미트 : 페이지가 변경되면 1
{% endhint %}

우선 고려대상은 참조 비트이다. 참조비트가 0인 페이지 먼저 찾은 후 변경 비트를 찾는다.



#### FIFO 변형

2차 기회 페이지 교체

특정 페이지에 접근하여 페이지 부재 없이 성공한다면 해당 페이지를 큐의 맨뒤로 이동시킨다. ( 2차검증)



시계 알고리즘

원형 큐를 사용하여 옮길 대상의 대상 페이지를 가리키는 포인터를 사용한다.



## 스레싱과 프레임 할당

메모리가 부족하여 하드디스크와 입출력이 많아지는 상태를 스레싱 이라고 한다.

스레싱은 각 프로세스에 프레임을 할당해주는 문제와도 연관되어 있는데, 프로세스에 프레임을 할당하는 방식은 정적할당과 동적 할당으로 구분한다.

#### 정적 할당

실행 초기에 프레임을 나누어 준 후 크기를 고정하는 것이다.

#### 균등 할당

프로세스 크기와 상관없이 동일하게 할당한다

#### 비례 할당

프로세스 크기에 비례하여 할당하는 방식이다.

#### 동적 할당

시시각각 변하는 프로세스의 프레임을 수용하는 방식이다.

작업 집합 모델 : 지역성을 바탕으로, 가장 접근한 프레임을 우선으로 한다.

페이지 부재 빈도 : 페이지 폴트의 횟수를 기록하여 부재 비율을 계산하는 방식이다.



### 전역&지역 교체

페이지를 교체할때 사용하는 방식이다.

**전역 교체** : 전체 프레임을 대상으로 스왑 영역에 보낼 페이지를 찾는다.

**지역 교체** : 자신에게 할당된 프레임의 개수의 변화가 없기 때문에 페이지 교체가 프로세스에 영향을 미치지 않는다



