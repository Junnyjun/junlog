# Job

코틀린 코루틴에서 **Job**은 코루틴의 생명주기와 실행 상태를 관리하는 핵심적인 인터페이스입니다. 코루틴을 생성할 때 반환되는 Job 객체를 통해 코루틴의 시작, 취소, 완료 여부 등을 제어할 수 있습니다. 이를 통해 복잡한 비동기 작업에서도 코루틴의 흐름을 효율적으로 관리할 수 있습니다.

#### Job의 역할

* **생명주기 관리**: 코루틴의 시작부터 완료까지의 상태를 추적합니다.
* **취소 기능 제공**: 필요에 따라 코루틴을 취소할 수 있으며, 취소 시 자식 코루틴까지 전파됩니다.
* **완료 대기**: `join()` 함수를 통해 코루틴이 완료될 때까지 기다릴 수 있습니다.

#### Job 생성과 사용

코루틴 빌더인 `launch`나 `async`를 사용하여 코루틴을 생성하면 내부적으로 Job 객체가 반환됩니다.

```kotlin
val job: Job = launch {
    // 코루틴에서 수행할 작업
}
```

이렇게 생성된 Job 객체를 사용하여 코루틴의 상태를 확인하거나 제어할 수 있습니다.

#### Job의 주요 메서드와 속성

*   **`cancel()`**: 코루틴을 취소합니다. 취소된 코루틴은 `CancellationException`을 발생시키며, 코루틴 내에서 이를 처리할 수 있습니다.

    ```kotlin
    job.cancel()
    ```
*   **`join()`**: 코루틴이 완료될 때까지 현재 스레드를 일시 중단합니다.

    ```kotlin
    job.join()
    ```
*   **`cancelAndJoin()`**: 코루틴을 취소하고, 완료될 때까지 대기합니다.

    ```kotlin
    job.cancelAndJoin()
    ```
*   **`isActive`**: 코루틴이 활성화되어 실행 중인지 확인합니다.

    ```kotlin
    if (job.isActive) {
        // 실행 중인 경우 수행할 작업
    }
    ```
*   **`isCompleted`**: 코루틴이 완료되었는지 확인합니다.

    ```kotlin
    if (job.isCompleted) {
        // 완료된 후 수행할 작업
    }
    ```

#### Job의 계층 구조와 취소 전파

Job은 부모-자식 관계의 계층 구조를 가질 수 있습니다. 부모 코루틴 내에서 자식 코루틴을 생성하면, 자식 코루틴의 Job은 부모의 Job에 종속됩니다.

```kotlin
val parentJob = launch {
    val childJob = launch {
        // 자식 코루틴의 작업
    }
}
```

부모 Job이 취소되면 자식 Job도 함께 취소됩니다. 이를 통해 여러 코루틴이 협력하여 작업할 때, 전체 작업의 일관성을 유지할 수 있습니다.

#### Job의 상태

Job은 코루틴의 진행 상황에 따라 다양한 상태를 가집니다.

* **New**: 코루틴이 생성되었지만 아직 시작되지 않은 상태.
* **Active**: 코루틴이 실행 중인 상태.
* **Completing**: 코루틴의 실행이 종료되었지만, 아직 완료 처리 중인 상태.
* **Completed**: 코루틴이 정상적으로 완료된 상태.
* **Cancelling**: 코루틴이 취소 요청을 받아 종료 중인 상태.
* **Cancelled**: 코루틴이 취소되어 종료된 상태.

#### 예제 코드

아래는 Job을 활용하여 코루틴을 관리하는 예제입니다.

```kotlin
fun main() = runBlocking {
    val job = launch {
        repeat(10) { i ->
            println("코루틴 작업 중... $i")
            delay(300L)
        }
    }

    delay(1000L)
    println("메인: 코루틴을 취소합니다.")
    job.cancelAndJoin()
    println("메인: 코루틴이 종료되었습니다.")
}
```

**설명**:

* `launch`를 통해 코루틴을 생성하고, Job 객체를 받습니다.
* `repeat`와 `delay`를 사용하여 반복 작업을 수행합니다.
* 메인 코루틴에서 `delay(1000L)`로 1초간 대기한 후, `job.cancelAndJoin()`을 호출하여 코루틴을 취소하고 완료될 때까지 기다립니다.

#### Job의 활용 사례

* **네트워크 요청 취소**: 사용자가 화면을 벗어나거나 취소 버튼을 누를 때 진행 중인 네트워크 요청을 취소할 수 있습니다.
* **타임아웃 처리**: 일정 시간이 지나도 완료되지 않는 작업을 취소하여 리소스를 절약할 수 있습니다.
* **병렬 작업 관리**: 여러 코루틴을 실행하고, 모든 작업이 완료될 때까지 대기하거나, 특정 조건에 따라 작업을 취소할 수 있습니다.

#### 주의 사항

* 코루틴 내부에서 취소를 확인하려면 **취소 가능 지점**이 필요합니다. `delay`, `yield` 등의 함수는 취소 가능 지점으로, 코루틴이 취소되었는지 확인하고 `CancellationException`을 발생시킵니다.
* **취소 불가능한 코드 블록**이 있으면 코루틴이 즉시 취소되지 않을 수 있으므로, 장시간 실행되는 작업은 적절히 분할하여 취소 가능하도록 설계해야 합니다.

#### 결론

Job은 코루틴의 실행과 생명주기를 관리하는 데 핵심적인 역할을 합니다. 이를 활용하여 코루틴의 상태를 제어하고, 복잡한 비동기 작업에서도 안정적이고 효율적인 코드 작성을 할 수 있습니다.
