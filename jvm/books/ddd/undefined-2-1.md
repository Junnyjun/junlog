# 모델 주도 설계

비즈니스 도메인 전문가와 소프트웨어 분석가가 모델을 도출하더라도, 소프트웨어 개발자의 구현 레벨에서 간극이 생길 수 있다.

모델을 코드로 어떻게 변환할 것인가?



1안) 도메인 분석과 코드 구현을 별개로 분리함. \
개발자는 분석모델을 참고만 할 뿐이어서 코딩이 시작되면 분석모델은 폐기됨

```
영속성, 성능 등에 있어서 분석 모델이 항상 최적최선은 아니기 때문이다.
분석된 모델을 개발자들에게 문서로 넘겨줄 때, 분석가들의 지식이 온전히 전달되지 않는다. 
개발자들은 어림짐작을 하게 된다.
```

2안) 분석가와 개발자가 함께 참여하여 소프트웨어로 표현될 수 있는 모델을 설계해야 한다.

```
개발을 고려하지 않는 분석은 구현에서 발생할 수 있는 문제점을 놓치고 모델은 비현실적인 게 된다.
구현과 모델을 밀접하게 연관시키려면 객체지향 언어처럼 모델링 패러다임을 지원하는 걸 사용하는게 좋다.
```

반 버논(Vaughn Vernon)은 전술적 설계 중 일부만 차용한 것을 DDD-Lite 라고 정의한다.

## 설계 블록&#x20;

<figure><img src="https://blog.kakaocdn.net/dn/9Jjqj/btrqMQy14cl/szzHtxAmAQM8VdkyfrRpFk/img.png" alt=""><figcaption></figcaption></figure>

### 계층형 아키텍처 (Layered Architecture) <a href="#dddquickly-3-1.-layeredarchitecture" id="dddquickly-3-1.-layeredarchitecture"></a>

어플리케이션은 도메인, 비즈니스 외에도 DB, 네트워크, 파일 등 인프라스트럭처 코드들이 상당하다.\
도메인 코드가 다른 레이어와 섞여있으면, 이해하기가 어려워지고 외부변경에 사이드이펙트가 있을 수 있다.

아래와 같이 레이어를 분할해야한다.

```
프리젠테이션   : UI영역, view
어플리케이션   : 어플리케이션 활동을 조율하며, 각 영역을 호출하고 작업의 결과를 보관한다.
도메인        : 비즈니스 객체를 다룬다. 서비스와 모델로 구성되어 있는 듯
인프라스트럭처 : 영속성 구현, 레이어 간 통신 제공
```

### 엔티티 (Entity) <a href="#dddquickly-3-2.-entity" id="dddquickly-3-2.-entity"></a>

엔티티는 연속성과 식별성을 갖는 객체이다. 소프트웨어가 여러 상태를 거치는 동안에도 유일하다.

인스턴스와 엔티티의 차이

```
객체가 메모리에 보관되고 주소를 할당받는 인스턴스는 참조될 동안만 존재하며, 같은 값을 가질 수 있기 때문에 식별성이 있진 않다.
엔티티를 구현한다는 것은 식별자를 만들어내는 것이라고 볼 수 있다.
도메인 객체 ⊃ 엔티티
```

### 값 객체 (Value Object) <a href="#dddquickly-3-3.-valueobject" id="dddquickly-3-3.-valueobject"></a>

모든 객체를 엔티티로 만들 필요는 없다. 굳이 식별할 필요가 없는 것도 있으므로..\
하나의 객체가 도메인의 어떤 측면을 표현하는데 사용되지만 식별자가 없다면 값 객체

쉽게 생성되고 쉽게 폐기되며 영속화도 신경안써도 된다. 설계를 단순하게 만들고, VO의 단순함을 유지해라.

불변으로 사용해야 한다. 상태를 변경해야한다면 새로운 VO를 만들어서 사용해라.\
VO 역시 도메인 로직을 갖는다. 예를들면 변환, 포매팅, 검증 등이 있겠다.

### 서비스 <a href="#dddquickly-3-4." id="dddquickly-3-4."></a>

도메인의 행위 가운데 어떤 행동은 어느 객체에도 속하기 어려운 것이 있을 수 있다.

```
예를들어, 송금 행위에서 송금인 객체에서 이걸 메소드화할 것인가? 
    ㄴ수취인 객체에서 이걸 메소드화할 것인가? 둘다 아니다.

이 부분은 Object Oriented Design 와의 큰 차이점이라고 볼 수도 있겠다. 
    ㄴ행동을 객체에서 의도적으로 분리시키기 때문이다.
```

이러한 행위들을 서비스 객체로 정의한다.\
내부적인 상태를 갖지 않으면서 도메인의 기능을 제공한다.

#### 서비스의 특징

```
엔티티, VO에 속할 수 없는 도메인의 개념
도메인의 다른 객체를 참조
```

서비스가 어느 레이어에 속해야하는지는 상황과 개념에 따라 다르다.\
이 부분에서 문득, 자주 다루는 Spring 프레임워크의 @Service 과는 무슨 상관이 있을까? 궁금했는데..

<figure><img src="https://blog.kakaocdn.net/dn/ml3MZ/btrqNxSWJY3/RMKnvWpwErFPKJ0kwkBdeK/img.png" alt=""><figcaption></figcaption></figure>

### 모듈 <a href="#dddquickly-3-5." id="dddquickly-3-5."></a>

모델이 거대해지면서 전체를 파악하기 어려워짐\
모듈화는 관련된 개념과 작업을 조직화하여 모델을 모듈로 쪼개는 것이다.\
모듈을 쪼갤 때, 높은 응집도(High Cohesion)와 낮은 결합도(Loose Coupling)를 추구해야 한다는 원칙을 지키기 위해 노력해야한다.

```
통신(communicational) 응집도 : 비슷한 데이터들을 그룹핑하여 모듈화
기능(functional) 응집도
```

모듈은 다른 모듈에서 쉽게 접근 할 수 있는 인터페이스를 가져야한다.\
구체적인 클래스를 참조하지 않아도 되므로 결합도 감소

모듈은 관점에 따라 MSA의 마이크로서비스 단위가 될 수도 있을 듯?

```
cf) 반 버논은 분할된 컨텍스트 내 여러 마이크로서비스가 들어갈 수도 있다고 한다.
```

### 집합 (Aggregate) <a href="#dddquickly-3-6.-aggregate" id="dddquickly-3-6.-aggregate"></a>

도메인 객체의 소유권과 경계를 정의하는 패턴\
모델링에서의 과제는 어떻게 해야 단순하고 이해하기 쉬운 모델을 만들 수 있는가?

```
보통 두 객체간 참조 관계를 제거하며 단순화함
1대N 관계는 N이 1의 집합으로 들어감으로써 단순화
N대M 관계는 아래와 같이 단순화하라
```

모델의 핵심이 아닌 관계는 제거\
관계에 참여하는 객체의 수를 제약사항으로 걸러내어 감소\
양방향인데 단방향으로 대체

```
ex) 자동차에 엔진이 있고, 엔진에는 호환되는 자동차 목록이 있음. 
    그러나 전자만 고려하여 단방향으로 바꿔버릴 수 있음
```

복잡한 참조관계를 유지하며 데이터 무결성을 지키기 위해, DBMS의 트랜잭션을 사용한다.

```
모델이 잘못 설계되었을 수록 DB에 기대야하며, lock 등으로 인하여 높은 비용이 소모된다.
따라서, 모델 설계수준에서 직접 해결할 수 있다면 가장 좋다.
```

집합은 하나의 root(=엔티티)를 갖는다. \
root는 집합된 다른 객체들을 참조하고 있고 관계를 맺고 있다.\
집합을 사용하면 데이터 무결성을 보장하고 불변식을 강제할 수 있다.

```
하위의 집합된 객체들은 root만이 참조하고 변경할 수 있기때문이다. 외부에서는 root만 public하므로..
외부에서 하위 객체를 꼭 참조해야한다면 데이터 무결성을 위하여 복사하여 VO으로 전달해야한다.
```

영속성 레벨에서는 집합된 데이터를 어떻게 저장해야 좋을까?

```
NoSQL 같은 경우, 통으로 저장할 수도 있겠다.
RDB라면 table 다 쪼개서 저장하고 join 하는 형태로?
하위 집합의 객체들이 DB에 별도 table 에 저장되어있다면
```

### 팩토리 (Factory) <a href="#dddquickly-3-7.-factory" id="dddquickly-3-7.-factory"></a>

거대한 엔티티를 생성자를 통해 생성하기에는 너무 크고 복잡하다. \
이러한 복잡한 객체 생성의 절차를 캡슐화한 것이 팩토리다.

{% code title="자동차 공정" %}
```
프레스(new FramePress(철판, ...), new BodyPanel(...)) -> 차체(new 차량구조(각종 판넬, 용접기)) -> 도장 -> 의장(조립) -> 검사 -> 완성
여러 모듈들이 먼저 완성되고 이것들을 조합한 것이다. (new Car(제조공정의 결과물들))
이렇게 복잡한 것을 별도로 분리하여 캡슐화한다는 것이다.
```
{% endcode %}

#### 팩토리 구현 방식

팩토리 메소드 패턴

* 조건에 따라 객체 생성을 팩토리 클래스에 위임
* 하나의 종류당 1개의 팩토리이며 단일메소드를 가짐

추상 팩토리 패턴

* 조건에 따라 객체를 생성하는 팩토리 생성을 팩토리 클래스에서 한다.
* 생성된 팩토리 객체는 연관있는 객체들을 일관되게 생성할 수 있다.

root를 생성하려면 집합된 객체들도 생성하고 관계를 잡아줘야한다. 이런 로직은 어떤 객체에도 포함하는게 어색하기 때문에 factory 객체가 맡는게 적절하다.\
마치 컴퓨터라는 도메인 객체가 CPU, RAM, 디스크 등 여러 하위 객체들로 구성된 것처럼..

#### 팩토리가 굳이 필요하지 않고, 생성자로 충분한 경우

1. 생성 작업이 복잡하지 않음
2. 객체 생성이 다른 객체의 생성과 연관되어 있지 않음
3. 전략 패턴을 선택할 때

```
cf) 전략 패턴 : 객체가 할 수 있는 행위들을 각각의 전략으로 만들고, 행위의 수정이 필요하다면 
    전략을 단순히 교체만하면 되도록 함
```

4. 인자에 따라 생성되는 클래스가 달라지지 않고, 자기 자신 일때

### 리파지토리 (Repository) <a href="#dddquickly-3-8.-repository" id="dddquickly-3-8.-repository"></a>

클라이언트가 DB에서 필요한 정보(객체)를 조회하고 바로 사용한다면, 도메인 모델 설계에 위반한다.

```
sql 결과로 필요이상으로 많은 데이터가 노출된다.
도메인 개념보다 인프라스트럭처를 더 다루게 된다.
모델은 단순히 데이터운반 역할만 하게 될 것이다.
인프라스트럭처 변경에도 취약해진다.
```

하위 집합의 어떤 객체가 필요하더라도, 도메인 모델 설계에 맞게 root(=엔티티, 도메인객체)를 조회하고, root부터 참조하라

객체의 참조를 얻는 로직을 캡슐화하기 위하여 리파지토리를 사용하라

```
리파지토리로만 참조할 수 있다면, 도메인 모델은 본분에 충실할 수 있다.
도메인 모델이 객체의 저장이나 참조와 연관을 없애고 인프라스트럭처에 접근할 필요가 없어지는 효과
```

리파지토리는 객체 조회 시, cache hit 하기도 하지만, cache miss 라면 영속성 스토리지에서 읽어오는 경우가 더 많다.

리파지토리는 팩토리와 다르게 인프라스트럭처 레이어와도 연결이 포함될 수 있다.\
리파지토리는 CRUD를 수행할 수 있다. 여기서 Create는 아무것도 없는 상태에서 객체를 생성하는 것이 아니라, 팩토리에서 넘겨받은 객체를 추가하는 것이다.

<figure><img src="https://blog.kakaocdn.net/dn/m3sOg/btrqN3cYulm/8kJoJ4fTBkaD3iYPB4zp7K/img.png" alt=""><figcaption></figcaption></figure>

Spring 프레임워크의 @Repository 도 역시 DDD 에서 따온 개념이라 한다.

<figure><img src="https://blog.kakaocdn.net/dn/dig1Xy/btrqUSuYEr1/BBwHXMKQKXR5Eo6QKmkOp0/img.png" alt=""><figcaption></figcaption></figure>
