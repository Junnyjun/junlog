# 깊은 통찰을 향한 리팩터링

도메인 모델링의 리팩토링

```
초창기에 비즈니스 명세를 읽으며 명사는 클래스로 동사는 메소드로 변환하는 것부터 시작하지만 초기에는 깊이가 얕고 편협하다.
코드적, 패턴을 기반으로 하는 기술적인 동기를 갖는 리팩토링과는 다르다.
리팩토링은 어플리케이션의 기능에 변화를 주지 않고 코드를 더 좋게 만들기 위해 재설계하는 절차
도메인에 대한 통찰, 모델이나 코드에 드러나는 표현을 가다듬기 위한 것도 리팩토링이다.
```

정교한 모델, 좋은 모델은 도메인 전문가와 개발자들이 밀접하게 엮여서 반복적으로 리팩토링을 해야 만들어진다.\
도메인 전문가와 이야기할 때, 모델에 표현되지 않은 암시적 개념이 설계에서 핵심적 역할을 한다면, 이것을 모델에 추가함으로써 명시적으로 만들어야한다.

암시적 개념, 누락된 개념을 발견하는 방법

```
언어를 주의 깊게 듣는다.
누락이 되었다면, 어떤 객체는 그것을 대체하기 위해 매우 비대해졌을 가능성이 높다.
도메인 전문가의 요구사항이 다른 요구사항과 상충되어 보이더라도, 조화시키려고 노력해야한다. 그 과정에서 중요한 개념이 도출될 수도 있다.
해당 도메인의 문헌을 활용하라
```

명시적인 것을 만들어낼 때, 유용한 것은 아래 3가지다.

#### 제약 조건(constraint)

```
제약사항을 별도 메소드로 분리하여 명확하게 하라
읽기 쉬워지고, 제약 조건이 추가되어도 넣기 쉬워진다.
```

#### 처리(process)

```
대개 절차적 코드로 표현된다. 처리를 표현하는 권장방법은 Service 를 이용하는 것이다.
```

#### 명세(specification)

객체가 특정 기준(비즈니스 규칙)을 만족하는지 여부\
개별 비즈니스 규칙들은 자체적인 객체로 분리되어 캡슐화되어야 한다. 이것들을 조합해서 하나의 규칙을 표현한다.

```java
Customer customer = customerRepository.findCustomer(id);
Specification customerEligibleForRefund = new Specification(new CustomerPaidHisDebtsInThePast(), new CustomerHasNoOutstandingBalances());
if (customerEligibleForRefund.isSatisfiedBy(customer)) { ... }
```

코드만 읽어도 명세파악이 가능해야 한다.
