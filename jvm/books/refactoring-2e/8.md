# 8장

Self Encapsulate Field

```
field에 직접 접근하고 있는데 Field에 대한 결합이 이상해지면,
그 Field에 대한 get/set 메소드를 만들고 항상 이 메소드를 사용하여 Field에 접근하라
클래스 안에서도 get/set으로 접근해야 한다 
```

Replace Data Value with Object

```
추가적인 데이터나 동작을 필요로 하는 데이터 아이템이 있을 때는
데이터 아이템을 객체로 바꾸어라.
```

동기

```
간단한 데이터 아이템인 줄 알았는데 특별한 동작이 여럿 필요한 경우 데이터 값을 객체로 바꿔야 함
```

절차

```
데이터 값에 대한 클래스를 만든다. 
소스 클래스의 값과 같은 타입으로 필드를 만들어 final로 선언한다.
get 메소드와 데이터 값의 필드를 파라미터로 취하는 생성자를 추가한다.
컴파일
소스 클래스 필드의 타입을 새로운 클래스로 바꾼다.
소스 클래스의 get 메소드를 새로운 클래스의 get 메소드를 호출하도록 바꾼다.
만약 필드가 소스 클래스의 생성자에서 사용되면, 새로운 클래스의 생성자를 사용하여 필드에 값을 할당
get 메소드에서 새로운 클래스의 인스턴스를 생성하도록 바꾼다.
컴파일, 테스트
새로운 객체에 대해 Change Value to Reference를 사용할 필요가 있는지 확인
```

Change Value to Reference

```
동일한 인스턴스를 여러 개 가지고 있는 클래스가 있고 여러 개의 동일한 인스턴스를 하나의 객체로 바꾸고 싶으면,
그 객체를 참조 객체로 바꾸어라.
```

동기

```
어떠한 변경이 그 객체를 참조하고 있는 모든 곳으로 전파되기를 원할 때
```

Change Reference to Value

```
작고, 불변성이고, 관리하기가 어려운 참조 객체가 있는 경우
그것을 값 객체로 바꾸어라.
```

Replace Array with Object

```
배열의 특정 요소가 다른 뜻을 가지고 있다면,
배열을 각각의 요소에 대한 필드를 가지는 객체로 바꿔라.
= 변경 전 =
String[] row = new String[3];
row[0] = "Liverpool";
row[1] = "15";
= 변경 후 =
Performance row = new Performance();
row.setName("Liverpool");
row.setWins("15");
```

Duplicate Observed Data

```
GUI  컨트롤에서만 사용 가능한 도메인 데이터가 있고, 도메인 메소드에서 접근이 필요한 경우,
그 데이터를 도메인 객체로 복사하고, 옵저버를 두어 두 데이터를 동기화하라
```

특별한 의미를 가지는 숫자 리터럴이 있으면, 상수를 만들고, 의미를 잘 나타내도록 이름을 지은 다음, 숫자를 상수로 바꾸어라.

매직넘버는 상수로 만약 매직넘버가 타입 코드라면 Replace Type Code with Class 적용 고려\
\
Replace Type Code with Class

```
클래스의 동작에 영항을 미치지 않는 숫자로 된 타입 코드가 있으면, 
숫자를 클래스로 바꾸어라
```

Replace Type Code with Subclasses&#x20;

```
클래스의 동작에 영향을 미치는 변경 불가능한 타입 코드가 있다면
타입 코드를 서브클래스로 바꾸어라.
```

동기

```
많은 조건문이 있을 때 ( if, switch 등 )
각각 subclass 만들고  Factory로 객체 생성
```
