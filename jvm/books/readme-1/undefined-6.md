# 컴포넌트 응집도

* REP(Reuse/Release Equivalence Principle) - 재서용/릴리스 등가 원칙
* CCP(Common Closure Principle) - 공통 폐쇄 원칙
* CRP(Common Reuse Principle) - 공통 재사용 원칙

&#x20;

#### REP: 재사용/릴리스 등가 원칙

&#x20;

> 재사용 단위는 릴리스 단위와 같다.\
>

&#x20;

소프트웨어 컴포넌트가 릴리스 절차를 통해 추적 관리되지 않거나 릴리스 번호가 부여되지 않는다면 해당 컴포넌트를 재사용하고 싶어도 할 수도 없고, 하지도 않을 것이다.

&#x20;

릴리스 번호를 통해 재사용 컴포넌트들이 서로 호환되는지 알 수 있다.

개발자들은 릴리스 변경사항을 살펴보고 이를 적용할지 결정할 수 있다.

&#x20;

이 원칙은 소프트웨어 설계와 아키텍처 관점에서 보면 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 함을 뜻한다.

&#x20;

하나의 컴포넌트로 묶인 클래스와 모듈은 반드시 함께 릴리스할 수 있어야 한다.

&#x20;

&#x20;

#### CCP: 공통 폐쇄 원칙

> 동일한 이유로 동일한 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라.\
> 서로 다른 시점에 다른 이유로 변경되는 클래스는 다른 컴포넌트로 분리하라.

&#x20;

이 원칙은 단일 책임 원칙을 컴포넌트 관점에서 다시 쓴 것이다.

&#x20;

CCP에서도 마찬가지로 단일 컴포넌트는 변경의 이유가 여러 개 있어서는 안 된다고 말한다.

&#x20;

애플리케이션에서 코드가 반드시 변경되어야 한다면, 변경 모두가 단일 컴포넌트에서 발생하는 편이 낫다.

&#x20;

따라서 CCP는 같은 이유로 변경될 가능성이 있는 클래스는 모두 한곳으로 묶을 것을 권한다.

&#x20;

&#x20;

SRP와의 유사성

&#x20;

CCP는 컴포넌트 수준의 SRP다.

SRP에서는 서로 다른 이유로 변경되는 메서드를 서로 다른 클래스로 분리하라고 말한다.

CCP에서는 서로 다른 이유로 변경되는 클래스를 서로 다른 컴포넌트로 분리하라고 말한다.

두 원칙은 모두 다음과 같은 교훈으로 요약할 수 있다.

> 동일한 시점에 동일한 이유로 변경되는 것들을 한데 묶어라. 서로 다른 시점에 다른 이유로 변경되는 것들은 서로 분리하라.

&#x20;

### CRP: 공통 재사용 원칙

> 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라.

공통 재사용 원칙도 클래스와 모듈을 어느 컴포넌트에 위치시킬지 결정할 때 도움되는 원칙이다.

CRP에서는 같이 재사용되는 경향이 있는 클래스와 모듈들은 같은 컴포넌트에 포함해야 한다고 말한다.

&#x20;

재사용 가능한 클래스는 재사용 모듈의 일부로써 해당 모듈의 다른 클래스와 상호작용하는 경우가 많다.

CRP에서는 이런 클래스들이 동일한 컴포넌트에 포함되어야 한다고 말한다.

&#x20;

예시) container와 iterator - 이들 클래스는 서로 강하게 결합되어 있기 때문에 함께 재사용된다. 따라서 동일한 컴포넌트에 위치해야한다.

&#x20;

또한, CPR는 동일한 컴포넌트로 묶어서는 안되는 클래스가 무엇인지도 말해준다.

&#x20;

어떤 컴포넌트가 다른 컴포넌트를 사용하면, 두 컴포넌트 사이에 의존성이 생긴다.

사용하는 클래스에서 사용되는 클래스에서 단 하나의 클래스만 사용한다고 해도 의존성은 약해지지 않는다.

&#x20;

이런 의존성으로 인해 사용되는 컴포넌트가 변경될 때 마다 사용하는 컴포넌트도 변경해야할 가능성이 높다.

&#x20;

따라서 의존하는 컴포넌트가 있다면 해당 컴포넌트의 모든 클래스에 대해 의존함을 확실히 인지해야 한다.

&#x20;

CRP는 강하게 결합되지 않은 클래스들을 동일한 컴포넌트에 위치시켜서는 안 된다고 말한다.

&#x20;

ISP와의 관계

CRP는 인터페이스 분리 원칙(ISP)의 포괄적인 버전이다.

&#x20;

ISP는 사용하지 않는 메서드가 있는 클래스에 의존하지 말라고 조언한다.

CRP는 사용하지 않는 클래스를 가진 컴포넌트에 의존하지 말라고 한다.

&#x20;

이 두 조언은 다음의 한 문장으로 요약할 수 있다.

> 필요하지 않는 것에 의존하지 말라.

&#x20;

### 컴포넌트 응집도에 대한 균형 다이어그램

&#x20;

REP와 CCP는 포함(inclusive) 원칙이며, 컴포넌트를 더욱 크게 만든다.

CRP는 배제(exclusive)원칙이며, 컴포넌트를 더욱 작게 만든다.

&#x20;

따라서 이 원칙들이 균형을 이루는 방법을 찾아야 한다.

&#x20;

<figure><img src="https://blog.kakaocdn.net/dn/x0ECu/btq1aSfYgOc/GD2Hc1dm6MCxqAjTBQ59PK/img.jpg" alt=""><figcaption><p>결합도 원칙들의 균형 다이어그램</p></figcaption></figure>

&#x20;

위 균형 다이어그램에서 다이어그램의 각 변은 반대쪽 꼭지점에 있는 원칙을 포기했을 때 감수해야 할 비용을 나타낸다.

&#x20;

REP와 CRP에만 중점을 두면, 사소한 변경에 너무 많은 컴포넌트에 영향을 미친다.

CCP와 REP에만 과도하게 집중하면 불필요한 릴리스가 너무 빈번해진다.

CRP와 CCP에만 집중하게 되면 재사용성이 떨어지게 된다.

&#x20;

뛰어난 아키텍트는 현재 개발팀에서 관심을 기울이는 부분을 충족시키는 위치를 찾아야 하며, 시간이 흐르면서 주의 기울이는 부분 역시 변한다는 사실도 이해해야 한다.

&#x20;

### 결론

어느 클래스들을 묶어서 컴포넌트로 만들지를 결정할 때, 재사용성과 개발 가능성이라는 상충하는 힘을 반드시 고려해야 한다.

&#x20;

이들 사이에서 애플리케이션의 요구에 맞게 균형을 잡는 일은 중요하다. 심지어 이 균형점은 항상 유동적이다.
