# 자바 메모리 영역과 메모리 오버플로

## 런타임 데이터 영역

자바 가상 머신은 프로그램을 실행하는 동안 필요한 메모리를 몇 개의 데이터 영역으로 나눠 관리한다.\
이 영역들은 각각 목적과 생성/삭제 시점이 있다.

<img src="../../../.gitbook/assets/file.excalidraw (51).svg" alt="" class="gitbook-drawing">

### 프로그램 카운터

프로그램 카운터 레지스터는 작은 메모리 영역으로, 현재 실행중인 스레드의 바이트 코드 줄 번호 표시기라고 생각하면 된다. 프로그램의 제어 흐름, 분기, 순환 점프등을 표시한다

각각 스레드의 멈춤 지점을 정확하게 복원하기 위해서는 각 스레드의 고유한 프로그램 카운터가 필요하다.\
이 메모리 영역을 `스레드 프라이빗` 메모리 라고한다.

### 자바 가상 머신 스택

자바 가상머신 스택도 `스레드 프레이빗`하며, 연결된 스레드와 운명을 같이한다.\
각 메서드가 호출될 때마다, 스택 프레임을 만들어 지역 변수 테이블, 피 연산자 스택, 동적 링크 등 정보를 저장한다

지역 변수 테이블에는 컴파일 타임에 알 수 있는 다양한 기본 데이터타입, 객체 참조, 반환 주소 타입을 저장한다\
지역 변수 테이블에서 이 데이터 타입들을 저장하는 공간을 지연 변수 슬롯이라고 한다\
이 슬롯은 32비트의 크기를 가진다.

### 네이티브 메서드 스택

가상 머신 스택과 비슷한 역할이지만, 네이티브 메서드를 실행할 때 사용한다.

### 자바 힙

자바 어플리케이션이 사용할 수 있는 가장 큰 메모리이다. 모든 스레드가 공유하며, 가상 머신이 구동될 때 만들어진다.

자바 힙은 모든 스레드가 공유한다. 따라서 객체 할당 효율을 높이고자 스레드 로컬 할당 버퍼 여러개로 나뉘어진다.\
이는 자바 힙을 빠르게 회수하기 위함이다.

### 메서드 영역

타입 정보, 상수, 정적 변수 등을 저장하는 데 이용된다. 힙에 영구세대에 구현되어 있다.

메서드 영역에서 회수 대상은 상수 풀과 타이이라 회수 효과가 굉장히 적고 까다롭다.

### 런타임 상수 풀

메서드 영역의 일부로써 클래스 버전, 필드, 메서드, 인터페이스 등 클래스 파일에 포함된 설명 정보에, 다양한 리터럴과 심벌 참조가 저장된다

런타임 상수풀은 다른 상수풀과 다르게, 동적이라는 점이다.\
자바 언어에서는 상수가 꼭 컴파일 타임에 생성되어야 한다는 규칙이 없다.\
`String().intern()`에 특성이 반영되어있다

### 다이렉트 메모리

자바 가상머신 명세는 아니지만, 자주 쓰이는 메모리중 하나이다.

NIO에서 힙이아닌 다이렉트 버퍼를 사용할 때 이 메모리 영역을 사용한다.\
물리 메모리를 직접 할당하기 때문에 자바 힙 제약과는 무관 하다.

## 핫스팟 가상 머신에서의 객체 들여다 보기

### 객체 생성

자바는 객체 지향 언어이다 프로그램이 동작하는 동안 수시로 객체를 만들어낸다.

자바 가상머신이 `new` 명령에 해당하는 바이트 코드를 만나면, 이 명령의 매개변수가 상수 풀 안의 클래스인지를 확인ㄷ한다. 그다음 이 클래스가 로딩,해석, 초기화 되었는지 확인한다

로딩이 완료되면 새 객체를 담을 메모리를 할당한다. 객체의 필요한 메모리의 크기는 클래스를 로딩하면 정확하게 알 수 있다. 자바 힙이 규칙적인 경우에는 사용중인 메모리는 한쪽에, 여유 반대쪽에, 포인터는 두 사이에 자리잡게 된다.

하지만 자바 힙은 규칙적이지 않다. 사용 메모리와 여유 메모리가 뒤섞여 있어 포인터 밀어내기가 까다롭게된다.\
그 대신 가용 메모리 블록을 목록으로 관리하여, 인스턴스를 담기에 충분한 공간을 찾아 할당하는데 이를 `여유 목록` 이라고 한다

어떤 방식을 쓸지는 자바 힙의 규칙성에 따라 달라진다.&#x20;

여유 메모리의 포인터를 지정하는 부분도  스레드가 동시에 접근하려고 할때 문제가 될 수 있게되는데, 메모리 할당하고 포인터를 지정하는 과정에서, 다른 스레드가 포인터를 이용하는 경우가 이에 해당된다.

이를 해결 하는 방법은 크게 두가지가 존재한다

1. 메모리 할당을 동시화 한다.
2. 스레드 마다 다른 공간을 할당한다

2처럼 스레드를 미리 할당해두는 것을 TLAB라고한다.  스레드 로컬 할당 버퍼를 사용하면, 객체 인스턴스 필드를 초기화 하지 않고도 사용할 수 있게된다.

## 메모리 객체 레이아웃

가상 머신은 객체를 세 부분으로 나눠 힙에 저장한다.\
객체 헤더, 인스턴스 데이터, 정렬 패딩이 이에 해당된다

<img src="../../../.gitbook/assets/file.excalidraw (52).svg" alt="" class="gitbook-drawing">

### 객체 헤더

#### Mark Word
객체 헤더의 첫 번째 유형은 객체 자체의 런타임 데이터이다. \
객체 자체의 런타임 데이터, 해시코드, GC 세대 나이, 락 상태 플래그 스레드 아이디 등의 정보를 담고 있다. \
이 부분을 마크워드(Mark Word)라고 한다

객체는 아주 많은 양의 런타임 데이터를 필요로해서, 32&64비트에는 전부 담을 수 없다. \
마크 워드는 최대한 효율적으로 데이터를 써야하는데, 그리하여 동적으로 다른 의미를 가지게 된다.

#### Klass Word

객체 헤더의 두 번째 유형은 클래스 메타데이터를 가리키는 포인터이다.\
클래스 워드는 객체의 클래스를 가리키는 포인터이다.\
자바 가상 머신은 이 포인터를 통해 특정 객체가 어느 클래스의 인스턴스 인지 런타임에 알 수 있다.

#### Instance Data

객체 헤더 다음에는 인스턴스 데이터가 위치한다. 인스턴스 데이터는 객체가 실제로 담고 있는 정보이다. \
다양한 타입의 필드 관련 내용, 부모 클래스 유무, 부모 클래스에서 정의한 모든 필드가 이 부분에 기록된다

#### Padding

세번째 부분은 정렬 패딩이다. 이부분은 존재하지 않을 수도 있으며, 특별한 의미 없이 자리를 확보하는 역할을 한다.
객체의 데이터 조건을 충족하기 위해 사용된다.

### 객체 접근

대 다수의 객체는 다른 객체 여러 개를 조합하여 만들어 진다. \ 
자바 프로그램은 스택에 있는 참조 데이터를 통해 힙에 들어있는 객체들에 접근하여 이를 조작한다. \ 
객체에 접근하는 방법은 두가지가 있다.  \

> 핸들방식 \
   핸들 방식은 핸들 풀에 참조를 저장하고, 이 핸들을 통해 객체에 접근하는 방식이다. \
   안정적인 방식으로 핸들의 주소가 저장된다.
  
> 직접 포인터 방식 \
    직접 포인터 방식은 객체에 직접 참조를 저장하는 방식이다. \
    이 방식은 인스턴스 데이터 뿐만 아니라 타입 데이터에 대한 포인터도 저장한다. \
    
## OutofMemoryError

